
----- /Users/mac/Downloads/my_project_troti-vf/src/Dto/ReservationSearchCriteria.php -----
<?php

namespace App\Dto;

use App\Enum\ReservationStatus;
use App\Enum\Paiement;

class ReservationSearchCriteria
{
    public ?\DateTimeInterface $dateDebut = null;
    public ?\DateTimeInterface $dateFin = null;
    public ?ReservationStatus $status = null;
    public ?Paiement $paiement = null;
    public ?string $montantMin = null;
    public ?string $montantMax = null;
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Dto/ReclamationSearchCriteria.php -----
<?php
namespace App\Dto;

class ReclamationSearchCriteria
{
    public ?\DateTimeInterface $dateDebut = null;
    public ?\DateTimeInterface $dateFin = null;
    public ?string $typeReclamation = null;
    public ?string $userEmail = null;
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/ReclamationRepository.php -----
<?php

namespace App\Repository;

use App\Entity\Reclamation;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

class ReclamationRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Reclamation::class);
    }

    /**
     * Trouver toutes les réclamations, triées par date de création (plus récentes d'abord)
     */
    public function findAllOrderedByDate()
    {
        return $this->createQueryBuilder('r')
            ->orderBy('r.date_creation', 'DESC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Trouver une réclamation par son ID
     */
    public function findById($id)
    {
        return $this->createQueryBuilder('r')
            ->andWhere('r.id = :id')
            ->setParameter('id', $id)
            ->getQuery()
            ->getOneOrNullResult();
    }

    /**
     * Trouver les réclamations par email de l'utilisateur
     */
    public function findByUserEmail($email)
    {
        return $this->createQueryBuilder('r')
            ->andWhere('r.user_email = :email')
            ->setParameter('email', $email)
            ->getQuery()
            ->getResult();
    }

    /**
     * Trouver toutes les réclamations d'un type spécifique
     */
    public function findByType($type)
    {
        return $this->createQueryBuilder('r')
            ->andWhere('r.type_reclamation = :type')
            ->setParameter('type', $type)
            ->getQuery()
            ->getResult();
    }

    /**
     * Trouver les réclamations en fonction de l'utilisateur (relation utilisateur)
     */
    public function findByUtilisateur($utilisateurId)
    {
        return $this->createQueryBuilder('r')
            ->andWhere('r.utilisateur = :utilisateur')
            ->setParameter('utilisateur', $utilisateurId)
            ->getQuery()
            ->getResult();
    }

    /**
     * Trouver les réclamations liées à une trottinette (relation trottinette)
     */
    public function findByTrottinette($trottinetteId)
    {
        return $this->createQueryBuilder('r')
            ->andWhere('r.trottinette = :trottinette')
            ->setParameter('trottinette', $trottinetteId)
            ->getQuery()
            ->getResult();
    }

    public function findByCriteriaQuery(\App\Dto\ReclamationSearchCriteria $criteria)
{
    $qb = $this->createQueryBuilder('r');

    if ($criteria->dateDebut) {
        $qb->andWhere('r.date_creation >= :dateDebut')
           ->setParameter('dateDebut', $criteria->dateDebut);
    }

    if ($criteria->dateFin) {
        $qb->andWhere('r.date_creation <= :dateFin')
           ->setParameter('dateFin', $criteria->dateFin);
    }

    if ($criteria->typeReclamation) {
        $qb->andWhere('r.type_reclamation LIKE :type')
           ->setParameter('type', '%' . $criteria->typeReclamation . '%');
    }

    if ($criteria->userEmail) {
        $qb->andWhere('r.user_email LIKE :email')
           ->setParameter('email', '%' . $criteria->userEmail . '%');
    }

    return $qb->orderBy('r.date_creation', 'DESC')->getQuery();
}

}



----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/PointRelaisRepository.php -----
<?php

namespace App\Repository;

use App\Entity\PointRelais;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

/**
 * @extends ServiceEntityRepository<PointRelais>
 */
class PointRelaisRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, PointRelais::class);
    }

    //    /**
    //     * @return PointRelais[] Returns an array of PointRelais objects
    //     */
    //    public function findByExampleField($value): array
    //    {
    //        return $this->createQueryBuilder('p')
    //            ->andWhere('p.exampleField = :val')
    //            ->setParameter('val', $value)
    //            ->orderBy('p.id', 'ASC')
    //            ->setMaxResults(10)
    //            ->getQuery()
    //            ->getResult()
    //        ;
    //    }

    //    public function findOneBySomeField($value): ?PointRelais
    //    {
    //        return $this->createQueryBuilder('p')
    //            ->andWhere('p.exampleField = :val')
    //            ->setParameter('val', $value)
    //            ->getQuery()
    //            ->getOneOrNullResult()
    //        ;
    //    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/UtilisateurRepository.php -----
<?php
// src/Repository/UtilisateurRepository.php
namespace App\Repository;

use App\Entity\Utilisateur;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;
use Knp\Component\Pager\PaginatorInterface;
use Symfony\Component\Security\Core\Exception\UnsupportedUserException;
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
use Symfony\Component\Security\Core\User\PasswordUpgraderInterface;
use Doctrine\ORM\Tools\Pagination\Paginator; // <-- Import Paginator
use Knp\Bundle\PaginatorBundle\Pagination\SlidingPagination; // <--- MAKE SURE THIS LINE EXISTS AND IS CORRECT
/**
 * @extends ServiceEntityRepository<Utilisateur>
 * @implements PasswordUpgraderInterface<Utilisateur>
 */
class UtilisateurRepository extends ServiceEntityRepository implements PasswordUpgraderInterface
{
    private PaginatorInterface $paginator; // <-- MUST HAVE THIS PROPERTY

    // <-- MUST INJECT PaginatorInterface HERE -->
    public function __construct(ManagerRegistry $registry, PaginatorInterface $paginator)
    {
        parent::__construct($registry, Utilisateur::class);
        $this->paginator = $paginator; // <-- MUST STORE IT HERE
    }


    /**
     * Used to upgrade (rehash) the user's password automatically over time.
     */
    public function upgradePassword(PasswordAuthenticatedUserInterface $user, string $newHashedPassword): void
    {
        if (!$user instanceof Utilisateur) {
            throw new UnsupportedUserException(sprintf('Instances of "%s" are not supported.', $user::class));
        }

        $user->setPassword($newHashedPassword);
        $this->getEntityManager()->persist($user);
        $this->getEntityManager()->flush();
    }

    public function save(Utilisateur $entity, bool $flush = false): void
    {
        $this->getEntityManager()->persist($entity);
        if ($flush) {
            $this->getEntityManager()->flush();
        }
    }

    public function remove(Utilisateur $entity, bool $flush = false): void
    {
        $this->getEntityManager()->remove($entity);
        if ($flush) {
            $this->getEntityManager()->flush();
        }
    }


    /**
     * Find users based on criteria with pagination and sorting.
     *
     * @param array $criteria ['search' => string, 'role' => string]
     * @param int $page
     * @param int $limit
     * @param string $sortField DQL field path (e.g., 'u.nom')
     * @param string $sortDirection 'asc' or 'desc'
     * @param array $sortFieldWhitelist Allowed DQL sort fields
     * @return SlidingPagination // <--- CORRECTED RETURN TYPE HINT (uses the imported class)
     */
    public function findByCriteria(
        array $criteria = [],
        int $page = 1,
        int $limit = 15,
        string $sortField = 'u.nom',
        string $sortDirection = 'asc',
        array $sortFieldWhitelist = ['u.id', 'u.nom', 'u.prenom', 'u.email', 'u.roleInterne', 'u.isActive', 'u.isVerified']
    ): SlidingPagination // <--- CORRECTED RETURN TYPE HINT (uses the imported class)
    {
        $qb = $this->createQueryBuilder('u');

        // --- Apply Filters ---
        if (!empty($criteria['search'])) {
            $searchTerm = '%' . trim($criteria['search']) . '%';
            $qb->andWhere($qb->expr()->orX(
                $qb->expr()->like('LOWER(u.nom)', ':searchLower'),
                $qb->expr()->like('LOWER(u.prenom)', ':searchLower'),
                $qb->expr()->like('LOWER(u.email)', ':searchLower')
            ))
                ->setParameter('searchLower', mb_strtolower($searchTerm));
        }

        if (!empty($criteria['role'])) {
            $qb->andWhere('u.roleInterne = :role')
                ->setParameter('role', $criteria['role']);
        }

        // --- Apply Sorting ---
        if (in_array($sortField, $sortFieldWhitelist)) {
            $qb->orderBy($sortField, $sortDirection);
        } else {
            $qb->orderBy('u.nom', 'asc');
        }
        $qb->addOrderBy('u.id', 'ASC');

        $query = $qb->getQuery();

        // --- Use KNP Paginator Service ---
        // This part is already correct based on the error message!
        return $this->paginator->paginate(
            $query,
            $page,
            $limit,
            [
                'sortFieldWhitelist' => $sortFieldWhitelist,
                'defaultSortFieldName' => $sortField,
                'defaultSortDirection' => $sortDirection,
                'distinct' => false,
            ]
        );
    }
 }


----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/MaintenanceRepository.php -----
<?php

namespace App\Repository;

use App\Entity\Maintenance;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\ORM\QueryBuilder; // <-- Import QueryBuilder
use Doctrine\Persistence\ManagerRegistry;
use Doctrine\ORM\Tools\Pagination\Paginator; // <-- Import Paginator

/**
 * @extends ServiceEntityRepository<Maintenance>
 *
 * @method Maintenance|null find($id, $lockMode = null, $lockVersion = null)
 * @method Maintenance|null findOneBy(array $criteria, array $orderBy = null)
 * @method Maintenance[]    findAll()
 * @method Maintenance[]    findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null)
 */
class MaintenanceRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Maintenance::class);
    }
    /**
     * Creates a QueryBuilder for filtering maintenances.
     * Used by KnpPaginatorBundle in the controller.
     *
     * @param array $criteria Filter criteria
     * @return QueryBuilder
     */
    public function createFilteredQueryBuilder(array $criteria): QueryBuilder
    {
        $qb = $this->createQueryBuilder('m')
            ->select('m', 't') // Select both entities if needed
            ->leftJoin('m.trottinette', 't');

        // Apply filters (same logic as findFilteredPaginated)
        if (!empty($criteria['statut'])) {
            $qb->andWhere('m.statut = :statut')
                ->setParameter('statut', $criteria['statut']);
        }

        // Filter by Trottinette ID
        if (!empty($criteria['trottinette']) && is_numeric($criteria['trottinette'])) {
            $qb->andWhere('t.id = :trottinetteId')
                ->setParameter('trottinetteId', $criteria['trottinette']);
        }
        // Filter by Search Term (add if your filter form has 'search')
        if (!empty($criteria['search'])) {
            $searchTerm = '%' . $criteria['search'] . '%';
            $qb->andWhere($qb->expr()->orX(
                $qb->expr()->like('m.description', ':search'),
                $qb->expr()->like('t.numeroSerie', ':search'), // Example: Search trottinette serial
                $qb->expr()->like('t.modele', ':search')      // Example: Search trottinette model
            // Add other searchable fields
            ))
                ->setParameter('search', $searchTerm);
        }


        // Filter by date range
        if (!empty($criteria['dateDebutFrom']) && $criteria['dateDebutFrom'] instanceof \DateTimeInterface) {
            $qb->andWhere('m.dateDebut >= :dateDebutFrom')
                ->setParameter('dateDebutFrom', $criteria['dateDebutFrom']);
        }
        if (!empty($criteria['dateDebutTo']) && $criteria['dateDebutTo'] instanceof \DateTimeInterface) {
            $dateTo = (clone $criteria['dateDebutTo'])->setTime(23, 59, 59);
            $qb->andWhere('m.dateDebut <= :dateDebutTo')
                ->setParameter('dateDebutTo', $dateTo);
        }

        // Default order
        $qb->orderBy('m.dateDebut', 'DESC');

        return $qb; // Return the QueryBuilder
    }

    /**
     * Finds maintenances based on filter criteria with pagination.
     * Mirrors the structure of UtilisateurRepository::findByCriteria.
     *
     * @param array $criteria Associative array of filter criteria (e.g., ['statut' => 'EN_COURS', 'trottinette' => 5])
     * @param int $page The current page number (starting from 1)
     * @param int $limit The number of items per page
     * @return Paginator The paginator object containing the results
     */
    public function findFilteredPaginated(array $criteria, int $page = 1, int $limit = 15): Paginator // Default values optional
    {
        // 1. Create QueryBuilder
        $qb = $this->createQueryBuilder('m') // 'm' is the alias for Maintenance
        ->select('m', 't')               // Select Maintenance and associated Trottinette
        ->leftJoin('m.trottinette', 't'); // Join Trottinette using 't' alias

        // 2. Apply filter criteria dynamically
        if (!empty($criteria['statut'])) {
            $qb->andWhere('m.statut = :statut')
                ->setParameter('statut', $criteria['statut']);
        }

        // Filter by Trottinette ID (assuming filter returns an ID)
        if (!empty($criteria['trottinette'])) {
            // Ensure it's a numeric ID before using it
            if (is_numeric($criteria['trottinette'])) {
                $qb->andWhere('t.id = :trottinetteId')
                    ->setParameter('trottinetteId', $criteria['trottinette']);
            }
            // Alternative: if your filter form returns the full Trottinette entity:
            /* elseif ($criteria['trottinette'] instanceof Trottinette) {
                 $qb->andWhere('m.trottinette = :trottinetteEntity')
                    ->setParameter('trottinetteEntity', $criteria['trottinette']);
             } */
        }

        // Filter by date range (assuming filter form keys 'dateDebutFrom'/'dateDebutTo')
        if (!empty($criteria['dateDebutFrom']) && $criteria['dateDebutFrom'] instanceof \DateTimeInterface) {
            $qb->andWhere('m.dateDebut >= :dateDebutFrom')
                ->setParameter('dateDebutFrom', $criteria['dateDebutFrom']);
        }
        if (!empty($criteria['dateDebutTo']) && $criteria['dateDebutTo'] instanceof \DateTimeInterface) {
            // Add time to include the whole day
            $dateTo = clone $criteria['dateDebutTo'];
            $dateTo = $dateTo->setTime(23, 59, 59);
            $qb->andWhere('m.dateDebut <= :dateDebutTo')
                ->setParameter('dateDebutTo', $dateTo);
        }

        // Add other filters as needed based on your MaintenanceFilterType form...

        // 3. Add Ordering (optional but good practice)
        $qb->orderBy('m.dateDebut', 'DESC'); // Example: Order by start date, newest first
        // $qb->addOrderBy('t.modele', 'ASC'); // Example: Add secondary ordering

        // 4. Set Pagination Limits
        $query = $qb->getQuery()
            ->setFirstResult(($page - 1) * $limit)
            ->setMaxResults($limit);

        // 5. Create and return Paginator
        // 'true' fetches the join collection (Trottinette) efficiently
        return new Paginator($query, true);
    }

    /**
     * Counts maintenances by a specific status.
     *
     * @param string $status The status value (e.g., 'EN_COURS')
     * @return int The count of maintenances with that status
     */
    public function countByStatus(string $status): int
    {
        return (int) $this->createQueryBuilder('m')
            ->select('count(m.id)')
            ->where('m.statut = :status')
            ->setParameter('status', $status)
            ->getQuery()
            ->getSingleScalarResult();
    }

    public function save(Maintenance $entity, bool $flush = false): void
    {
        $this->getEntityManager()->persist($entity);

        if ($flush) {
            $this->getEntityManager()->flush();
        }
    }

    public function remove(Maintenance $entity, bool $flush = false): void
    {
        $this->getEntityManager()->remove($entity);

        if ($flush) {
            $this->getEntityManager()->flush();
        }
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/ReservationRepository.php -----
<?php

namespace App\Repository;

use App\Entity\Reservation;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

/**
 * @extends ServiceEntityRepository<Reservation>
 */
class ReservationRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Reservation::class);
    }

    // src/Repository/ReservationRepository.php
    public function findByCriteriaQuery(\App\Dto\ReservationSearchCriteria $criteria)
    {
        $qb = $this->createQueryBuilder('r');
    
        if ($criteria->dateDebut) {
            $qb->andWhere('r.dateDebut >= :dateDebut')
               ->setParameter('dateDebut', $criteria->dateDebut);
        }
    
        if ($criteria->dateFin) {
            $qb->andWhere('r.dateFin <= :dateFin')
               ->setParameter('dateFin', $criteria->dateFin);
        }
    
        if ($criteria->status) {
            $qb->andWhere('r.status = :status')
               ->setParameter('status', $criteria->status);
        }
    
        if ($criteria->paiement) {
            $qb->andWhere('r.paiement = :paiement')
               ->setParameter('paiement', $criteria->paiement);
        }
    
        if ($criteria->montantMin) {
            $qb->andWhere('r.montant >= :montantMin')
               ->setParameter('montantMin', $criteria->montantMin);
        }
    
        if ($criteria->montantMax) {
            $qb->andWhere('r.montant <= :montantMax')
               ->setParameter('montantMax', $criteria->montantMax);
        }
    
        return $qb->orderBy('r.dateCreation', 'DESC')
                  ->getQuery(); // return Query, not results
    }

    public function countByStatus(): array
    {
        $qb = $this->createQueryBuilder('r')
            ->select('r.status AS status, COUNT(r.id) AS total')
            ->groupBy('r.status');
    
        $results = $qb->getQuery()->getResult();
    
        $formatted = [];
        foreach ($results as $row) {
            $status = $row['status'];
            
            // if status is an enum or object, convert it to a string:
            if (is_object($status)) {
                if (method_exists($status, 'label')) {
                    $status = $status->label();
                } else {
                    $status = (string) $status;
                }
            }
    
            $formatted[$status] = (int) $row['total'];
        }
    
        return $formatted;
    }
    


    //    /**
    //     * @return Reservation[] Returns an array of Reservation objects
    //     */
    //    public function findByExampleField($value): array
    //    {
    //        return $this->createQueryBuilder('r')
    //            ->andWhere('r.exampleField = :val')
    //            ->setParameter('val', $value)
    //            ->orderBy('r.id', 'ASC')
    //            ->setMaxResults(10)
    //            ->getQuery()
    //            ->getResult()
    //        ;
    //    }

    //    public function findOneBySomeField($value): ?Reservation
    //    {
    //        return $this->createQueryBuilder('r')
    //            ->andWhere('r.exampleField = :val')
    //            ->setParameter('val', $value)
    //            ->getQuery()
    //            ->getOneOrNullResult()
    //        ;
    //    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/ResetPasswordRequestRepository.php -----
<?php
// src/Repository/ResetPasswordRequestRepository.php
namespace App\Repository;

use App\Entity\ResetPasswordRequest; // Ensure correct entity path
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;
use SymfonyCasts\Bundle\ResetPassword\Model\ResetPasswordRequestInterface;
use SymfonyCasts\Bundle\ResetPassword\Persistence\Repository\ResetPasswordRequestRepositoryTrait; // <-- Make sure this line exists
use SymfonyCasts\Bundle\ResetPassword\Persistence\ResetPasswordRequestRepositoryInterface;

/**
 * @extends ServiceEntityRepository<ResetPasswordRequest>
 */
class ResetPasswordRequestRepository extends ServiceEntityRepository implements ResetPasswordRequestRepositoryInterface
{
    use ResetPasswordRequestRepositoryTrait; // <-- Make sure this line exists

    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, ResetPasswordRequest::class);
    }

    public function createResetPasswordRequest(object $user, \DateTimeInterface $expiresAt, string $selector, string $hashedToken): ResetPasswordRequestInterface
    {
        // Ensure the user is a UserInterface before creating the request object
        if (!$user instanceof \Symfony\Component\Security\Core\User\UserInterface) {
            throw new \InvalidArgumentException(sprintf('The first argument of %s() must be an instance of %s, "%s" given.', __METHOD__, \Symfony\Component\Security\Core\User\UserInterface::class, get_debug_type($user)));
        }

        return new ResetPasswordRequest( // Use the correct entity
            $user,
            $expiresAt,
            $selector,
            $hashedToken
        );
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/ReponseRepository.php -----
<?php
// src/Repository/ReponseRepository.php

namespace App\Repository;

use App\Entity\Reponse;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

class ReponseRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Reponse::class);
    }

    /**
     * Find all responses for a specific reclamation ordered by date of response (earliest first)
     */
    public function findByReclamationOrderedByDate($reclamation)
    {
        return $this->createQueryBuilder('r')
            ->andWhere('r.reclamation = :reclamation')
            ->setParameter('reclamation', $reclamation)
            ->orderBy('r.date_reponse', 'ASC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Find a specific response by its ID
     */
    public function findById($id)
    {
        return $this->createQueryBuilder('r')
            ->andWhere('r.id = :id')
            ->setParameter('id', $id)
            ->getQuery()
            ->getOneOrNullResult();
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/TrottinetteRepository.php -----
<?php
// src/Repository/TrottinetteRepository.php
namespace App\Repository;

use App\Entity\Trottinette;
use App\Enum\TrottinetteStatus;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;
use Knp\Component\Pager\PaginatorInterface; // <-- Import Paginator
 use Knp\Bundle\PaginatorBundle\Pagination\SlidingPagination; // <-- Import the concrete class

/**
 * @extends ServiceEntityRepository<Trottinette>
 */
class TrottinetteRepository extends ServiceEntityRepository
{
    private PaginatorInterface $paginator; // <-- Add property


    public function __construct(ManagerRegistry $registry, PaginatorInterface $paginator)
    {
        parent::__construct($registry, Trottinette::class);
        $this->paginator = $paginator;
    }


    /**
     * Find trottinettes based on DB criteria (search, status, battery) with pagination.
     * Autonomy filtering will happen in PHP after this.
     *
     * @param array $criteria ['search', 'status', 'batterie_min']  <- Note: 'autonomie_min' is ignored here
     * @param int $page
     * @param int $limit
     * @param string $sortField
     * @param string $sortDirection
     * @return SlidingPagination
     */
    public function findFilteredPaginated(
        array $criteria,
        int $page,
        int $limit,
        string $sortField = 't.dateAjout',
        string $sortDirection = 'DESC'
    ): SlidingPagination // Adjust return type if needed
    {
        $qb = $this->createQueryBuilder('t')
            ->leftJoin('t.pointRelais', 'pr')
            ->leftJoin('t.utilisateur', 'u')
            ->addSelect('pr', 'u');

        // Apply Search filter
        if (!empty($criteria['search'])) {
            $searchTerm = '%' . mb_strtolower(trim($criteria['search'])) . '%';
            $qb->andWhere($qb->expr()->orX(
                $qb->expr()->like('LOWER(t.modele)', ':search'),
                $qb->expr()->like('LOWER(t.numeroSerie)', ':search'),
                $qb->expr()->like('LOWER(t.localisation)', ':search'),
                $qb->expr()->like('LOWER(pr.nom)', ':search')
            ))
                ->setParameter('search', $searchTerm);
        }

        // Apply Status filter
        if (!empty($criteria['status'])) {
            $statusEnum = TrottinetteStatus::tryFrom($criteria['status']);
            if ($statusEnum) {
                $qb->andWhere('t.etat = :etat')
                    ->setParameter('etat', $statusEnum);
            }
        } else {
            // Default for public view: Only show DISPONIBLE if no status is selected
            $qb->andWhere('t.etat = :defaultEtat')
                ->setParameter('defaultEtat', TrottinetteStatus::DISPONIBLE);
        }

        // Apply Battery Minimum Filter
        if (!empty($criteria['batterie_min']) && is_numeric($criteria['batterie_min'])) {
            $qb->andWhere('t.batterie >= :batterie_min')
                ->setParameter('batterie_min', (int)$criteria['batterie_min']);
        }

        // --- AUTONOMY FILTER REMOVED FROM DQL ---

        // Apply Sorting (Let KNP handle it based on request params)
        // $qb->orderBy($sortField, $sortDirection); // KNP will override this

        $query = $qb->getQuery();

        // Paginate based on DB results (BEFORE PHP filtering)
        return $this->paginator->paginate(
            $query,
            $page,
            $limit,
            [ // KNP Options
                'pageParameterName'          => 'page',
                'sortFieldParameterName'     => 'sort',
                'sortDirectionParameterName' => 'direction',
                'defaultSortFieldName'       => $sortField,
                'defaultSortDirection'       => $sortDirection,
                'distinct'                   => false,
                'allowEmptyFields'           => true,
            ]
        );
    }

    // Keep save/remove if needed
    public function save(Trottinette $entity, bool $flush = false): void
    {
        $this->getEntityManager()->persist($entity);
        if ($flush) { $this->getEntityManager()->flush(); }
    }
    public function remove(Trottinette $entity, bool $flush = false): void
    {
        $this->getEntityManager()->remove($entity);
        if ($flush) { $this->getEntityManager()->flush(); }
    }

    // Keep findAvailable if used elsewhere
    public function findAvailable(): array
    {
        return $this->createQueryBuilder('t')
            ->where('t.etat = :etat')
            ->setParameter('etat', TrottinetteStatus::DISPONIBLE) // Use Enum case
            ->getQuery()
            ->getResult();
    }

    /**
     * Counts trottinettes by status.
     */
    public function countByEtat(TrottinetteStatus $status): int
    {
        try {
            return (int) $this->createQueryBuilder('t')
                ->select('count(t.id)')
                ->andWhere('t.etat = :status')
                ->setParameter('status', $status)
                ->getQuery()
                ->getSingleScalarResult();
        } catch (\Doctrine\ORM\NoResultException | \Doctrine\ORM\NonUniqueResultException $e) {
            return 0;
        }
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/EventRepository.php -----
<?php

namespace App\Repository;

use App\Entity\Event;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;
use Doctrine\ORM\QueryBuilder;
use App\Controller\Client\EventController; // Import controller to access constants
use Knp\Component\Pager\PaginatorInterface;
use Knp\Bundle\PaginatorBundle\Pagination\SlidingPagination;

/**
 * @extends ServiceEntityRepository<Event>
 *
 * @method Event|null find($id, $lockMode = null, $lockVersion = null)
 * @method Event|null findOneBy(array $criteria, array $orderBy = null)
 * @method Event[]    findAll()
 * @method Event[]    findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null)
 */
class EventRepository extends ServiceEntityRepository
{
    private PaginatorInterface $paginator;

    public function __construct(ManagerRegistry $registry, PaginatorInterface $paginator)
    {
        parent::__construct($registry, Event::class);
        $this->paginator = $paginator;
    }

    /**
     * Finds events based on criteria and returns a paginated result.
     * Sorting is handled by KNP Paginator.
     *
     * @param array $criteria ['search', 'status', 'date_filter']
     * @param int   $page
     * @param int   $limit
     * @param string $defaultSortField Default DQL field if KNP doesn't sort
     * @param string $defaultSortDirection Default direction if KNP doesn't sort
     * @return SlidingPagination
     */
    public function findFilteredPaginated(
        array $criteria,
        int $page,
        int $limit,
        string $defaultSortField = 'e.dateDebut',
        string $defaultSortDirection = 'desc'
    ): SlidingPagination // Adjust return type if needed
    {
        $qb = $this->createQueryBuilder('e')
            ->leftJoin('e.participations', 'p')
            ->addSelect('p');

        // Apply Search filter
        if (!empty($criteria['search'])) {
            $searchTerm = '%' . mb_strtolower(trim($criteria['search'])) . '%';
            $qb->andWhere($qb->expr()->orX(
                'LOWER(e.titre)       LIKE :q',
                'LOWER(e.description) LIKE :q',
                'LOWER(e.state)       LIKE :q' // Assuming state is string-like or castable
            ))
                ->setParameter('q', $searchTerm);
        }

        // Apply Status Filter
        if (!empty($criteria['status'])) {
            $qb->andWhere('e.statut = :status')->setParameter('status', $criteria['status']);
        }

        // Apply Date Filter
        $now = new \DateTimeImmutable();
        if (!empty($criteria['date_filter'])) {
            if ($criteria['date_filter'] === 'upcoming') {
                $qb->andWhere('e.dateDebut >= :now')->setParameter('now', $now);
            } elseif ($criteria['date_filter'] === 'past') {
                $qb->andWhere('e.dateDebut < :now')->setParameter('now', $now);
            }
        }

        // REMOVE Explicit orderBy - KNP handles it

        $query = $qb->getQuery();

        // Pass default sort options and WHITELIST to KNP Paginator
        return $this->paginator->paginate(
            $query,
            $page,
            $limit,
            [
                'pageParameterName' => 'page',
                'sortFieldParameterName' => 'sort', // KNP looks for DQL path here
                'sortDirectionParameterName' => 'direction',
                'defaultSortFieldName' => $defaultSortField,
                'defaultSortDirection' => $defaultSortDirection,
                'distinct' => true,
                // +++ IMPORTANT: Whitelist allowed DQL sort fields +++
                // Use the constant directly from the controller where it's defined
                'sortFieldWhitelist' => array_values(EventController::ALLOWED_SORT_FIELDS)
            ]
        );
    }

    /**
     * Find upcoming events
     */
    public function findUpcomingEvents(): array
    {
        return $this->createQueryBuilder('e')
            ->andWhere('e.dateDebut > :now')
            ->setParameter('now', new \DateTime())
            ->orderBy('e.dateDebut', 'ASC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Find events by location
     */
    public function findByLocation(string $location): array
    {
        return $this->createQueryBuilder('e')
            ->andWhere('e.lieu LIKE :location')
            ->setParameter('location', '%' . $location . '%')
            ->orderBy('e.dateDebut', 'ASC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Find events by date range
     */
    public function findByDateRange(\DateTime $start, \DateTime $end): array
    {
        return $this->createQueryBuilder('e')
            ->andWhere('e.dateDebut >= :start')
            ->andWhere('e.dateFin <= :end')
            ->setParameter('start', $start)
            ->setParameter('end', $end)
            ->orderBy('e.dateDebut', 'ASC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Find events by minimum scooter autonomy
     */
    public function findByMinScooterAutonomy(int $minAutonomy): array
    {
        return $this->createQueryBuilder('e')
            ->andWhere('e.trottinetteMinAutonomie <= :minAutonomy')
            ->setParameter('minAutonomy', $minAutonomy)
            ->orderBy('e.dateDebut', 'ASC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Counts events by status.
     */
    // --- CORRECTED METHOD NAME ---
    public function countByStatus(string $statut): int // Changed parameter name to match entity property
    {
        try {
            return (int) $this->createQueryBuilder('e')
                ->select('count(e.id)')
                ->andWhere('e.statut = :statut') // Use the correct property name 'statut'
                ->setParameter('statut', $statut) // Bind the parameter
                ->getQuery()
                ->getSingleScalarResult();
        } catch (\Doctrine\ORM\NoResultException | \Doctrine\ORM\NonUniqueResultException $e) {
            return 0;
        }
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/ParticipationRepository.php -----
<?php

namespace App\Repository;

use App\Entity\Participation;
use App\Entity\Event;
use App\Entity\Utilisateur;
use App\Enum\ParticipationStatus;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

/**
 * @extends ServiceEntityRepository<Participation>
 *
 * @method Participation|null find($id, $lockMode = null, $lockVersion = null)
 * @method Participation|null findOneBy(array $criteria, array $orderBy = null)
 * @method Participation[]    findAll()
 * @method Participation[]    findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null)
 */
class ParticipationRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Participation::class);
    }

    /**
     * Finds all participations for a given user, ordered by inscription date descending.
     *
     * @param Utilisateur $user The user entity.
     * @return Participation[] Returns an array of Participation objects.
     */
    public function findByUser(Utilisateur $user): array
    {
        return $this->createQueryBuilder('p')
            ->andWhere('p.utilisateur = :user')
            ->setParameter('user', $user)
            ->orderBy('p.dateInscription', 'DESC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Finds all participations for a given event, ordered by inscription date ascending.
     *
     * @param Event $event The event entity.
     * @return Participation[] Returns an array of Participation objects.
     */
    public function findByEvent(Event $event): array
    {
        return $this->createQueryBuilder('p')
            // Optionally join user if you often need user details with this query
            // ->leftJoin('p.utilisateur', 'u')
            // ->addSelect('u')
            ->andWhere('p.event = :event')
            ->setParameter('event', $event)
            ->orderBy('p.dateInscription', 'ASC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Finds all participations for a given event and status, ordered by inscription date ascending.
     *
     * @param Event $event The event entity.
     * @param ParticipationStatus $status The desired status.
     * @return Participation[] Returns an array of Participation objects.
     */
    public function findByEventAndStatus(Event $event, ParticipationStatus $status): array
    {
        return $this->createQueryBuilder('p')
            ->andWhere('p.event = :event')
            ->andWhere('p.statut = :status')
            ->setParameter('event', $event)
            ->setParameter('status', $status)
            ->orderBy('p.dateInscription', 'ASC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Finds a single participation record for a specific user and event, if it exists.
     * Useful for checking if a user is already registered (active or cancelled).
     *
     * @param Utilisateur $user The user entity.
     * @param Event $event The event entity.
     * @return Participation|null Returns the Participation object or null if not found.
     */
    public function findOneByUserAndEvent(Utilisateur $user, Event $event): ?Participation
    {
        return $this->createQueryBuilder('p')
            ->andWhere('p.utilisateur = :user')
            ->andWhere('p.event = :event')
            ->setParameter('user', $user)
            ->setParameter('event', $event)
            ->setMaxResults(1) // We only need one result
            ->getQuery()
            ->getOneOrNullResult();
    }

    /**
     * Counts the total number of participations for a given event.
     *
     * @param Event $event The event entity.
     * @return int The total count of participations.
     */
    public function countByEvent(Event $event): int
    {
        // Use try-catch for potential NoResultException if needed, though count usually returns 0
        try {
            return (int) $this->createQueryBuilder('p')
                ->select('count(p.id)') // Count primary keys for efficiency
                ->andWhere('p.event = :event')
                ->setParameter('event', $event)
                ->getQuery()
                ->getSingleScalarResult(); // Efficiently gets a single value
        } catch (\Doctrine\ORM\NoResultException | \Doctrine\ORM\NonUniqueResultException $e) {
            // Handle exception or just return 0
            return 0;
        }
    }

    /**
     * Counts the number of participations for a given event with a specific status.
     *
     * @param Event $event The event entity.
     * @param ParticipationStatus $status The status to count.
     * @return int The count of participations with the given status.
     */
    public function countByEventAndStatus(Event $event, ParticipationStatus $status): int
    {
        try {
            return (int) $this->createQueryBuilder('p')
                ->select('count(p.id)')
                ->andWhere('p.event = :event')
                ->andWhere('p.statut = :status') // Add the status condition
                ->setParameter('event', $event)
                ->setParameter('status', $status)
                ->getQuery()
                ->getSingleScalarResult();
        } catch (\Doctrine\ORM\NoResultException | \Doctrine\ORM\NonUniqueResultException $e) {
            return 0;
        }
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/ReponseType.php -----
<?php
// src/Form/ReponseType.php
namespace App\Form;

use App\Entity\Reponse;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\TextareaType;
use Symfony\Component\Form\Extension\Core\Type\SubmitType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class ReponseType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('message', TextareaType::class, [
                'label' => 'Votre Réponse',
                'attr' => ['placeholder' => 'Écrivez votre réponse ici...'],
            ])
            ->add('submit', SubmitType::class, [
                'label' => 'Envoyer la Réponse',
                'attr' => ['class' => 'btn btn-primary'],
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Reponse::class,
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Form/PointRelaisType.php -----
<?php

namespace App\Form;

use App\Entity\PointRelais;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\Extension\Core\Type\DateType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Form\Extension\Core\Type\HiddenType;


class PointRelaisType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('nom', TextType::class, [
                'required' => true,
                'attr' => [
                    'class' => 'form-control'
                ]
            ])
            ->add('addresse', HiddenType::class)
            ->add('HoraireOuverture', DateType::class, [
                'required' => true,
                'widget' => 'single_text',
                'property_path' => 'HoraireOuverture',
                'attr' => [
                    'class' => 'form-control'
                ]
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => PointRelais::class,
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Form/MaintenanceFilterType.php -----
<?php
// src/Form/MaintenanceFilterType.php
namespace App\Form;

use App\Enum\MaintenanceStatus; // Import your enum if you use it
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class MaintenanceFilterType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('search', TextType::class, [
                'label' => 'Rechercher',
                'required' => false,
                'attr' => [
                    'placeholder' => 'Description, ID Trottinette...',
                    'class' => 'form-input', // Add your Tailwind class
                ],
            ])
            ->add('statut', ChoiceType::class, [ // Use 'statut' to match entity property
                'label' => 'Statut',
                'required' => false,
                'placeholder' => 'Tous les statuts', // Optional placeholder
                'choices' => [
                    // Use the enum values or strings directly
                    'En cours' => 'EN_COURS', // Match the values stored in DB / Enum
                    'Terminée' => 'TERMINEE',
                    'Annulée' => 'ANNULEE',
                    // If using an Enum:
                    // 'En cours' => MaintenanceStatus::EN_COURS->value,
                    // 'Terminée' => MaintenanceStatus::TERMINEE->value,
                    // 'Annulée' => MaintenanceStatus::ANNULEE->value,
                ],
                'attr' => [
                    'class' => 'form-select', // Add your Tailwind class
                ],
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            // Configure your form options here
            'method' => 'GET', // Use GET for filter forms
            'csrf_protection' => false, // Disable CSRF for GET filters
            'data_class' => null, // Filter forms typically don't map to a specific entity instance
        ]);
    }

    // Optional: Define a block prefix if needed (helps avoid form name conflicts)
    public function getBlockPrefix(): string
    {
        return 'maintenance_filter'; // Prevents form fields like name="search"
        // instead uses name="maintenance_filter[search]"
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/AdminUserType.php -----
<?php
// src/Form/AdminUserType.php
namespace App\Form;

use App\Entity\Utilisateur;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\CheckboxType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
use Symfony\Component\Form\Extension\Core\Type\EmailType;
use Symfony\Component\Form\Extension\Core\Type\PasswordType;
use Symfony\Component\Form\Extension\Core\Type\RepeatedType;
use Symfony\Component\Form\Extension\Core\Type\TelType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Validator\Constraints\Length;

class AdminUserType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('nom', TextType::class, ['label' => 'Nom'])
            ->add('prenom', TextType::class, ['label' => 'Prénom'])
            ->add('email', EmailType::class, ['label' => 'Email'])
            ->add('telephone', TelType::class, ['label' => 'Téléphone', 'required' => false])
            ->add('roleInterne', ChoiceType::class, [
                'label' => 'Rôle',
                'choices' => [
                    'Client' => 'client',
                    'Partenaire' => 'partenaire',
                    'Administrateur' => 'admin',
                ],
                'attr' => ['class' => 'form-select'],
                'placeholder' => 'Choisir un rôle',
            ])
            ->add('isVerified', CheckboxType::class, [
                'label' => 'Compte Vérifié ?',
                'required' => false,
            ])

            ->add('isActive', CheckboxType::class, [
                'label'    => 'Compte Actif ?',
                'required' => false,
                'row_attr' => ['class' => 'form-check form-switch mb-3'],
                'attr'     => ['class' => 'form-check-input'],
                'label_attr' => ['class' => 'form-check-label'],
                'help'     => 'Décochez pour désactiver l’utilisateur.',
            ])
            // --- ADD CKEDITOR FIELD ---
            ->add('details', CKEditorType::class, [
                'label' => 'Détails / Bio',
                'required' => false, // Make it optional
                // Optionally configure the editor instance for this field
                // 'config_name' => 'my_custom_config', // If you defined one in fos_ckeditor.yaml
                // 'config' => [
                //    'toolbar' => 'basic', // Force a specific toolbar
                // ],
            ])
            // --- END CKEDITOR FIELD ---

            ->add('plainPassword', RepeatedType::class, [
                'type' => PasswordType::class,
                'mapped' => false,
                'required' => false,
                'options' => ['attr' => ['autocomplete' => 'new-password']],
                'first_options' => [
                    'label' => 'Nouveau Mot de passe',
                    'help' => 'Laisser vide pour ne pas changer le mot de passe.',
                    'attr' => ['placeholder' => 'Nouveau mot de passe'],
                ],
                'second_options' => [
                    'label' => 'Confirmer le Nouveau Mot de passe',
                    'attr' => ['placeholder' => 'Retapez le mot de passe'],
                ],

                'invalid_message' => 'Les mots de passe doivent correspondre.',
                'constraints' => [
                    new Length([
                        'min' => 6,
                        'minMessage' => 'Le mot de passe doit contenir au moins {{ limit }} caractères.',
                        'max' => 4096,
                    ]),
                ],
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Utilisateur::class,
            'attr' => ['novalidate' => 'novalidate'],
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/ChangePasswordFormType.php -----
<?php
// src/Form/ChangePasswordFormType.php
namespace App\Form;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\PasswordType;
use Symfony\Component\Form\Extension\Core\Type\RepeatedType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Validator\Constraints\Length;
use Symfony\Component\Validator\Constraints\NotBlank;

class ChangePasswordFormType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('plainPassword', RepeatedType::class, [
                'type' => PasswordType::class,
                'options' => [
                    'attr' => [ 'autocomplete' => 'new-password', ],
                ],
                'first_options' => [
                    'constraints' => [
                        new NotBlank([ 'message' => 'Veuillez entrer un mot de passe', ]),
                        new Length([
                            'min' => 6,
                            'minMessage' => 'Votre mot de passe doit contenir au moins {{ limit }} caractères',
                            'max' => 4096,
                        ]),
                    ],
                    'label' => 'Nouveau mot de passe',
                    'attr' => ['placeholder' => 'Entrez le nouveau mot de passe'],
                ],
                'second_options' => [
                    'label' => 'Confirmer le mot de passe',
                    'attr' => ['placeholder' => 'Retapez le nouveau mot de passe'],
                ],
                'invalid_message' => 'Les mots de passe doivent correspondre.',
                'mapped' => false, // Don't map to User entity directly
            ])
        ;
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/AdminReclamationType.php -----
<?php
// src/Form/AdminReclamationType.php

namespace App\Form;

use App\Entity\Reclamation;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\Extension\Core\Type\TextareaType;
use Symfony\Component\Form\Extension\Core\Type\SubmitType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Form\Extension\Core\Type\EmailType;
use Symfony\Component\Form\Extension\Core\Type\IntegerType;

class AdminReclamationType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder
            ->add('titre', TextType::class, [
                'label' => 'Titre',
                'attr' => ['placeholder' => 'Entrez le titre de la réclamation'],
            ])
            ->add('description', TextareaType::class, [
                'label' => 'Description',
                'attr' => ['placeholder' => 'Détaillez votre réclamation'],
            ])
            ->add('type_reclamation', TextType::class, [
                'label' => 'Type de réclamation',
                'attr' => ['placeholder' => 'Ex : Facturation incorrecte'],
            ])
            ->add('user_email', EmailType::class, [
                'label' => 'Email de l\'utilisateur',
                'attr' => ['placeholder' => 'Votre adresse email'],
            ])
            ->add('id_trottinette', IntegerType::class, [
                'label' => 'ID de la trottinette',
                'attr' => ['placeholder' => 'ID de la trottinette concernée'],
            ])
            // Admin-only fields, like status or assignment
/*            ->add('status', TextType::class, [
                'label' => 'Statut',
                'attr' => ['placeholder' => 'État actuel de la réclamation'],
            ])
            ->add('assigned_to', TextType::class, [
                'label' => 'Assigné à',
                'attr' => ['placeholder' => 'Nom de l\'administrateur'],
            ])*/
            ->add('save', SubmitType::class, ['label' => 'Sauvegarder la réclamation']);
    }

    public function configureOptions(OptionsResolver $resolver)
    {
        $resolver->setDefaults([
            'data_class' => Reclamation::class,
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Form/ResetPasswordRequestFormType.php -----
<?php
// src/Form/ResetPasswordRequestFormType.php
namespace App\Form;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\EmailType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Validator\Constraints\NotBlank;
use App\Validator\RecaptchaV2; // Import the custom constraint

class ResetPasswordRequestFormType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('email', EmailType::class, [
                'label' => 'Votre adresse e-mail',
                'attr' => ['autocomplete' => 'email', 'placeholder' => 'adresse@example.com'],
                'constraints' => [
                    new NotBlank([ 'message' => 'Veuillez entrer votre adresse e-mail', ]),
                    // ---> Apply the reCAPTCHA constraint here <---
                    // It doesn't matter which field it's attached to,
                    // as the validator checks the request data directly.
                    // Applying it to the email field is convenient.
                    new RecaptchaV2(),
                ],
                'help' => 'Entrez l\'adresse e-mail associée à votre compte.',
            ])
            // NO CaptchaType field needed here anymore
            // ->add('captcha', CaptchaType::class, [ ... ]) // REMOVE THIS LINE
        ;
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/TrottinetteType.php -----
<?php

namespace App\Form;

use App\Entity\Trottinette;
use App\Enum\TrottinetteStatus;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\EnumType;
use Symfony\Component\Form\Extension\Core\Type\IntegerType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Bridge\Doctrine\Form\Type\EntityType;
use App\Entity\PointRelais;

class TrottinetteType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('modele', TextType::class, [
                'label' => 'Modèle',
                'required' => true,
                'attr' => [
                    'class' => 'form-control',
                    'placeholder' => 'Ex: Xiaomi Pro 2',
                ],
                'error_bubbling' => true,
            ])
            ->add('numeroSerie', TextType::class, [
                'label' => 'Numéro de Série',
                'required' => true,
                'attr' => [
                    'class' => 'form-control',
                    'placeholder' => 'Ex: TROT-1234-XYZ',
                ],
                'error_bubbling' => true,
            ])
            ->add('etat', EnumType::class, [
                'class' => TrottinetteStatus::class,
                'label' => 'État',
                'required' => true,
                'choice_label' => function (TrottinetteStatus $choice) {
                    return match($choice) {
                        TrottinetteStatus::DISPONIBLE => 'Disponible',
                        TrottinetteStatus::EN_LOCATION => 'En Location',
                        TrottinetteStatus::EN_MAINTENANCE => 'En Maintenance',
                    };
                },
                'attr' => ['class' => 'form-select'],
                'error_bubbling' => true,
                'placeholder' => 'Sélectionnez un état',
            ])
            ->add('batterie', IntegerType::class, [
                'label' => 'Batterie (%)',
                'required' => false,
                'attr' => [
                    'class' => 'form-control',
                    'placeholder' => 'Ex: 85',
                    'min' => 0,
                    'max' => 100,
                ],
                'error_bubbling' => true,
            ])
            ->add('localisation', TextType::class, [
                'label' => 'Localisation',
                'required' => false,
                'attr' => [
                    'class' => 'form-control',
                    'placeholder' => 'Ex: Tunis Centre',
                ],
                'error_bubbling' => true,
            ])
            ->add('autonomie', TextType::class, [
                'label' => 'Autonomie',
                'required' => false,
                'attr' => [
                    'class' => 'form-control',
                    'placeholder' => 'Ex: 25 km ou 2 heures',
                ],
                'error_bubbling' => true,
            ])
            ->add('pointRelais', EntityType::class, [
                'class' => PointRelais::class,
                'label' => 'Point Relais',
                'choice_label' => 'nom',
                'required' => false,
                'placeholder' => 'Sélectionnez un point relais',
                'attr' => ['class' => 'form-select'],
                'error_bubbling' => true,
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Trottinette::class,
            'html5_validation' => false,
            'attr' => ['novalidate' => 'novalidate'],
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Form/RegistrationFormType.php -----
<?php
// src/Form/RegistrationFormType.php
namespace App\Form;

use App\Entity\Utilisateur;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\CheckboxType; // Add this
use Symfony\Component\Form\Extension\Core\Type\EmailType;
use Symfony\Component\Form\Extension\Core\Type\PasswordType;
use Symfony\Component\Form\Extension\Core\Type\RepeatedType;
use Symfony\Component\Form\Extension\Core\Type\TelType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
// REMOVE HiddenType if it was previously imported for face data
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Validator\Constraints\IsTrue; // Add this
use Symfony\Component\Validator\Constraints\Length;
use Symfony\Component\Validator\Constraints\NotBlank;

class RegistrationFormType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('nom', TextType::class, [
                'label' => 'Nom',
                'attr' => ['placeholder' => 'Votre nom de famille']
            ])
            ->add('prenom', TextType::class, [
                'label' => 'Prénom',
                'attr' => ['placeholder' => 'Votre prénom']
            ])
            ->add('email', EmailType::class, [
                'label' => 'Adresse Email',
                'attr' => ['placeholder' => 'adresse@example.com']
            ])
            ->add('telephone', TelType::class, [
                'label' => 'Numéro de téléphone',
                'attr' => ['placeholder' => 'Ex: +216 XX XXX XXX'],
                'required' => true // Make it required if necessary
            ])
            ->add('plainPassword', RepeatedType::class, [
                'type' => PasswordType::class,
                'options' => ['attr' => ['autocomplete' => 'new-password']],
                'first_options' => [
                    'label' => 'Mot de passe',
                    'attr' => ['placeholder' => 'Minimum 6 caractères'],
                    'constraints' => [
                        new NotBlank(['message' => 'Veuillez entrer un mot de passe.']),
                        new Length([
                            'min' => 6,
                            'minMessage' => 'Votre mot de passe doit contenir au moins {{ limit }} caractères.',
                            'max' => 4096, // Max length supported by Symfony's password hasher
                        ]),
                    ],
                ],
                'second_options' => [
                    'label' => 'Confirmer le mot de passe',
                    'attr' => ['placeholder' => 'Retapez votre mot de passe'],
                ],
                'invalid_message' => 'Les mots de passe doivent correspondre.',
                // Instead of being set onto the object directly,
                // this is read and encoded in the controller
                'mapped' => false, // IMPORTANT: Don't map directly to User entity password
            ])
            ->add('agreeTerms', CheckboxType::class, [ // Add Terms agreement
                'label' => 'J\'accepte les conditions d\'utilisation',
                'mapped' => false, // Not mapped to the User entity directly
                'constraints' => [
                    new IsTrue([
                        'message' => 'Vous devez accepter nos conditions.',
                    ]),
                ],
                'row_attr' => ['class' => 'form-check mb-3'], // Styling for checkbox
                'label_attr' => ['class' => 'form-check-label'],
                'attr' => ['class' => 'form-check-input'],
            ]);

        // --- REMOVE THE face_embedding_data FIELD ---
        // ->add('face_embedding_data', HiddenType::class, [
        //     'mapped' => false, // We handle this manually in the controller
        //     'required' => true, // Make it required
        //     'constraints' => [
        //         new NotBlank([
        //             'message' => 'La capture faciale est requise pour l\'inscription.',
        //         ]),
        //         // Optional: Add a custom constraint to validate the format if needed
        //     ],
        //     'label' => false,
        //     'attr' => ['readonly' => true] // For display, actual value set by JS
        // ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Utilisateur::class,
            'attr' => ['novalidate' => 'novalidate'], // Disable browser validation if using Symfony's
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/ReclamationType.php -----
<?php
// src/Form/ReclamationType.php

namespace App\Form;

use App\Entity\Reclamation;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\Extension\Core\Type\TextareaType;
use Symfony\Component\Form\Extension\Core\Type\SubmitType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Form\Extension\Core\Type\EmailType;
use Symfony\Component\Form\Extension\Core\Type\IntegerType;

class ReclamationType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder
            ->add('titre', TextType::class, [
                'label' => 'Titre',
                'attr' => ['placeholder' => 'Entrez le titre de votre réclamation'],
            ])
            ->add('description', TextareaType::class, [
                'label' => 'Description',
                'attr' => ['placeholder' => 'Détaillez votre réclamation'],
            ])
            ->add('type_reclamation', TextType::class, [
                'label' => 'Type de réclamation',
                'attr' => ['placeholder' => 'Ex : Facturation incorrecte'],
            ])
            ->add('user_email', EmailType::class, [
                'label' => 'Votre email',
                'attr' => ['placeholder' => 'Votre adresse email'],
            ])
            ->add('id_trottinette', IntegerType::class, [
                'label' => 'ID de la trottinette',
                'attr' => ['placeholder' => 'ID de la trottinette concernée'],
            ]);
    }

    public function configureOptions(OptionsResolver $resolver)
    {
        $resolver->setDefaults([
            'data_class' => Reclamation::class,
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Form/ReservationSearchType.php -----
<?php

// src/Form/ReservationSearchType.php
namespace App\Form;

use App\Dto\ReservationSearchCriteria;
use App\Enum\Paiement;
use App\Enum\ReservationStatus;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
use Symfony\Component\Form\Extension\Core\Type\DateType;
use Symfony\Component\Form\Extension\Core\Type\NumberType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class ReservationSearchType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('dateDebut', DateType::class, [
                'widget' => 'single_text',
                'required' => false,
                'label' => 'Date Début après'
            ])
            ->add('dateFin', DateType::class, [
                'widget' => 'single_text',
                'required' => false,
                'label' => 'Date Fin avant'
            ])
            ->add('status', ChoiceType::class, [
                'choices' => ReservationStatus::cases(),
                'choice_label' => fn($choice) => $choice->label(),
                'required' => false,
                'label' => 'Statut',
            ])
            ->add('paiement', ChoiceType::class, [
                'choices' => Paiement::cases(),
                'choice_label' => fn($choice) => $choice->label(),
                'required' => false,
                'label' => 'Mode de paiement',
            ])
            ->add('montantMin', NumberType::class, [
                'required' => false,
                'label' => 'Montant Min',
            ])
            ->add('montantMax', NumberType::class, [
                'required' => false,
                'label' => 'Montant Max',
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => ReservationSearchCriteria::class,
            'method' => 'GET', // important for search filters
            'csrf_protection' => false,
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Form/ProfileType.php -----
<?php
// src/Form/ProfileType.php
namespace App\Form;

use App\Entity\Utilisateur;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\EmailType;
use Symfony\Component\Form\Extension\Core\Type\TelType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
// Add PasswordType/RepeatedType if allowing password change here
// use Symfony\Component\Form\Extension\Core\Type\PasswordType;
// use Symfony\Component\Form\Extension\Core\Type\RepeatedType;
// use Symfony\Component\Validator\Constraints\Length;
// use Symfony\Component\Validator\Constraints\NotBlank;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class ProfileType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('nom', TextType::class, [
                'label' => 'Nom',
                'required' => true,
            ])
            ->add('prenom', TextType::class, [
                'label' => 'Prénom',
                'required' => true,
            ])
            ->add('email', EmailType::class, [
                'label' => 'Adresse Email',
                'required' => true,
                // 'disabled' => true, // Optionally disable email editing
            ])
            ->add('telephone', TelType::class, [
                'label' => 'Téléphone',
                'required' => false, // Make optional if desired
            ]);

        // Optional: Add password change fields
        /*
        ->add('plainPassword', RepeatedType::class, [
            'type' => PasswordType::class,
            'mapped' => false, // Don't map directly to entity password field
            'required' => false, // Password change is optional
            'options' => ['attr' => ['autocomplete' => 'new-password']],
            'first_options' => [
                'label' => 'Nouveau Mot de passe (laisser vide pour ne pas changer)',
                'constraints' => [
                    new Length(['min' => 6, 'max' => 4096]),
                ],
            ],
            'second_options' => [
                'label' => 'Confirmer le nouveau mot de passe',
            ],
            'invalid_message' => 'Les mots de passe doivent correspondre.',
        ])
        */
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Utilisateur::class,
            'attr' => ['novalidate' => 'novalidate'], // Disable browser validation if using Symfony validation
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/MaintenanceType.php -----
<?php

namespace App\Form;

use App\Entity\Maintenance;
use App\Entity\Trottinette;
use Symfony\Bridge\Doctrine\Form\Type\EntityType;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
use Symfony\Component\Form\Extension\Core\Type\DateTimeType;
use Symfony\Component\Form\Extension\Core\Type\TextareaType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class MaintenanceType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('trottinette', EntityType::class, [
                'class' => Trottinette::class,
                'choice_label' => function(Trottinette $trottinette) {
                    return sprintf('%s - %s', $trottinette->getModele(), $trottinette->getNumeroSerie());
                },
                'label' => 'Trottinette',
                'required' => false,
                'attr' => ['class' => 'form-control']
            ])
            ->add('dateDebut', DateTimeType::class, [
                'label' => 'Date de début',
                'required' => false,
                'widget' => 'single_text',
                'attr' => ['class' => 'form-control']
            ])
            ->add('dateFin', DateTimeType::class, [
                'label' => 'Date de fin',
                'required' => false,
                'widget' => 'single_text',
                'attr' => ['class' => 'form-control']
            ])
            ->add('description', TextareaType::class, [
                'label' => 'Description',
                'required' => false,
                'attr' => ['class' => 'form-control', 'rows' => 4]
            ])
            ->add('statut', ChoiceType::class, [
                'label' => 'Statut',
                'required' => false,
                'choices' => [
                    'En cours' => 'EN_COURS',
                    'Terminée' => 'TERMINEE', // ✔ valeur correcte attendue par l'entité
                    'Annulée' => 'ANNULE'
                ],
                'attr' => ['class' => 'form-control']
            ])
            ->add('type', ChoiceType::class, [
                'label' => 'Type de maintenance',
                'choices' => [
                    'Réparation' => 'REPARATION',
                    'Entretien' => 'ENTRETIEN',
                    'Inspection' => 'VERIFICATION',
                ],
                'required' => false,
                'attr' => ['class' => 'form-control']
            ]);
            
            // Add trottinette field at the beginning of the form
            $builder->get('trottinette')->setRequired(true);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Maintenance::class,
            'html5_validation' => false,
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/TrottinetteFilterType.php -----
<?php
// src/Form/TrottinetteFilterType.php
namespace App\Form;

use App\Enum\TrottinetteStatus; // Import the status enum
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class TrottinetteFilterType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('search', TextType::class, [
                'label' => 'Rechercher',
                'required' => false,
                'attr' => [
                    'placeholder' => 'Modèle, N° Série, Lieu...',
                    'class' => 'form-input', // Tailwind class
                ],
            ])
            ->add('etat', ChoiceType::class, [ // Use 'etat' matching the entity property
                'label' => 'État',
                'required' => false,
                'placeholder' => 'Tous les états',
                'choices' => TrottinetteStatus::choicesForForm(), // Use a helper method in Enum if you have one
                // OR list them manually:
                // 'choices' => [
                //     'Disponible' => TrottinetteStatus::DISPONIBLE->value,
                //     'En Location' => TrottinetteStatus::EN_LOCATION->value,
                //     'En Maintenance' => TrottinetteStatus::EN_MAINTENANCE->value,
                // ],
                'attr' => [
                    'class' => 'form-select', // Tailwind class
                ],
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'method' => 'GET',
            'csrf_protection' => false,
            'data_class' => null, // No specific data class for filter form
        ]);
    }

    // Optional: Define a block prefix
    public function getBlockPrefix(): string
    {
        return 'trottinette_filter';
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/EventFilterType.php -----
<?php
// src/Form/EventFilterType.php
namespace App\Form;

use App\Enum\GouvernoratEnum; // Import if filtering by Gouvernorat
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class EventFilterType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('search', TextType::class, [
                'label' => 'Rechercher',
                'required' => false,
                'attr' => [
                    'placeholder' => 'Titre, Description, Lieu...',
                    'class' => 'form-input', // Tailwind class
                ],
            ])
            // Status Filter
            ->add('status', ChoiceType::class, [
                'label' => 'Statut',
                'required' => false,
                'placeholder' => 'Tous les statuts',
                'choices' => [ // Map labels to database values
                    'À venir' => 'A_VENIR',
                    'En cours' => 'EN_COURS',
                    'Terminé' => 'TERMINE',
                    'Annulé' => 'ANNULE',
                ],
                'attr' => [
                    'class' => 'form-select', // Tailwind class
                ],
            ])
            // Date Filter (Simplified)
            ->add('date_filter', ChoiceType::class, [
                'label' => 'Période',
                'required' => false,
                'placeholder' => 'Toutes les dates',
                'choices' => [
                    'Événements à venir' => 'upcoming',
                    'Événements passés' => 'past',
                ],
                'attr' => [
                    'class' => 'form-select', // Tailwind class
                ],
            ])
            // Optional: Add Gouvernorat filter if needed
            // ->add('state', ChoiceType::class, [
            //     'label' => 'Gouvernorat',
            //     'required' => false,
            //     'placeholder' => 'Tous les gouvernorats',
            //     'choices' => array_flip(GouvernoratEnum::getChoicesForForm()), // Adjust if getChoicesForForm exists
            //     'attr' => ['class' => 'form-select'],
            // ])
        ;
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'method' => 'GET',
            'csrf_protection' => false,
            'data_class' => null,
        ]);
    }

    public function getBlockPrefix(): string
    {
        return 'event_filter'; // Unique prefix
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/UserFilterType.php -----
<?php
// src/Form/UserFilterType.php
namespace App\Form;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
use Symfony\Component\Form\Extension\Core\Type\SearchType; // Use SearchType
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class UserFilterType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('search', SearchType::class, [ // Use SearchType for semantics
                'label' => false, // Hide label, use placeholder
                'required' => false,
                'attr' => [
                    'placeholder' => 'Rechercher (Nom, Prénom, Email)...',
                    'class' => 'form-control-sm' // Optional smaller input
                ]
            ])
            ->add('role', ChoiceType::class, [
                'label' => false, // Hide label
                'required' => false,
                'placeholder' => 'Tous les rôles',
                'choices' => [
                    'Client' => 'client',
                    'Partenaire' => 'partenaire',
                    'Administrateur' => 'admin',
                ],
                'attr' => ['class' => 'form-select form-select-sm'] // Optional smaller select
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'method' => 'GET', // Use GET for filters
            'csrf_protection' => false, // No CSRF needed for GET filters
            'attr' => ['class' => 'row gx-2 gy-2 align-items-center filter-form'], // Add class for styling form row
        ]);
    }

    // Return empty block prefix to avoid prefixing field names in query string
    public function getBlockPrefix(): string
    {
        return '';
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/ReservationType.php -----
<?php
// src/Form/ReservationType.php
namespace App\Form;

use App\Entity\Reservation;
use App\Entity\Trottinette;
use App\Enum\Paiement;
use App\Enum\ReservationStatus;
use App\Repository\TrottinetteRepository;
use Symfony\Bridge\Doctrine\Form\Type\EntityType;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\DateTimeType;
use Symfony\Component\Form\Extension\Core\Type\EnumType;
use Symfony\Component\Form\Extension\Core\Type\MoneyType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Security\Core\Security;

class ReservationType extends AbstractType
{
    private Security $security;
    private TrottinetteRepository $trottinetteRepository;

    public function __construct(Security $security, TrottinetteRepository $trottinetteRepository)
    {
        $this->security = $security;
        $this->trottinetteRepository = $trottinetteRepository;
    }

    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('trottinette', EntityType::class, [
                'class' => Trottinette::class,
                'choice_label' => fn(Trottinette $t) => sprintf(
                    '%s (%s - %s%%)',
                    $t->getModele(),
                    $t->getNumeroSerie(),
                    $t->getBatterie() ?? 'N/A'
                ),
                'label' => 'Trottinette à Réserver',
                'placeholder' => 'Sélectionnez une trottinette disponible',
                'attr' => ['class' => 'form-select'],
                'query_builder' => function (TrottinetteRepository $tr) {
                    return $tr->createQueryBuilder('t')
                        ->where('t.etat = :status')
                        ->setParameter('status', \App\Enum\TrottinetteStatus::DISPONIBLE)
                        ->orderBy('t.modele', 'ASC');
                },
                'group_by' => function(Trottinette $choice, $key, $value) {
                    return $choice->getPointRelais()?->getNom() ?? 'Sans Point Relais';
                },
            ])
            ->add('dateDebut', DateTimeType::class, [
                'widget' => 'single_text',
                'label' => 'Début de la Réservation',
                'html5' => true,
                'attr' => ['min' => (new \DateTime('+5 minutes'))->format('Y-m-d\TH:i')],
            ])
            ->add('dateFin', DateTimeType::class, [
                'widget' => 'single_text',
                'label' => 'Fin de la Réservation',
                'html5' => true,
                'attr' => ['min' => (new \DateTime('+10 minutes'))->format('Y-m-d\TH:i')],
            ])
            ->add('montant', MoneyType::class, [
                'label' => 'Montant Estimé',
                'currency' => 'EUR', // Change to TND if needed
                'divisor' => 100,
                'required' => false,
                'attr' => [ 'placeholder' => '0.00' ],
                'help' => 'Le montant sera calculé précisément plus tard.',
            ])
            ->add('paiement', EnumType::class, [
                'class' => Paiement::class,
                'choice_label' => fn (Paiement $choice): string => $choice->label(),
                'label' => 'Méthode de Paiement',
                'placeholder' => 'Sélectionnez un paiement',
                'attr' => ['class' => 'form-select'],
            ])
            ->add('status', EnumType::class, [
                'class' => ReservationStatus::class, // Ensure it's pointing to your enum class
                'choice_label' => fn (ReservationStatus $status): string => $status->label(), // assuming label() method is defined in enum
                'label' => 'Statut Réservation',
                'placeholder' => 'Sélectionnez un statut',
                'attr' => ['class' => 'form-select'],
            ]);
    

        if ($options['is_admin_edit'] ?? false) {
            $builder->add('status', EnumType::class, [
                'class' => ReservationStatus::class,
                'choice_label' => fn (ReservationStatus $choice): string => $choice->label(),
                'label' => 'Statut Réservation',
                'attr' => ['class' => 'form-select'],
                'placeholder' => 'Sélectionnez un statut',
            ]);
        }
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Reservation::class,
            'is_admin_edit' => false,
            'attr' => ['novalidate' => 'novalidate'],
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/PublicTrottinetteFilterType.php -----
<?php
// src/Form/PublicTrottinetteFilterType.php
namespace App\Form;

use App\Enum\TrottinetteStatus;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
use Symfony\Component\Form\Extension\Core\Type\NumberType; // Use NumberType for range inputs
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Validator\Constraints as Assert; // For validation

class PublicTrottinetteFilterType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('search', TextType::class, [
                'label' => 'Rechercher',
                'label_attr' => ['class' => 'sr-only'], // Visually hidden label
                'required' => false,
                'attr' => [
                    'placeholder' => 'Modèle, Lieu...',
                    'class' => 'form-input text-sm', // Tailwind class
                ],
            ])
            ->add('status', ChoiceType::class, [
                'label' => 'État',
                'label_attr' => ['class' => 'sr-only'], // Visually hidden label
                'required' => false,
                'placeholder' => 'Tous les états',
                // Filter only for relevant public statuses (e.g., Disponible)
                'choices' => [
                    'Disponible' => TrottinetteStatus::DISPONIBLE->value,
                    // Add others if needed, but usually public only sees available
                ],
                'attr' => [
                    'class' => 'form-select text-sm', // Tailwind class
                ],
            ])
            ->add('batterie_min', NumberType::class, [
                'label' => 'Batterie Min.',
                'label_attr' => ['class' => 'sr-only'],
                'required' => false,
                'html5' => true, // Use HTML5 number input
                'attr' => [
                    'placeholder' => 'Batterie Min (%)',
                    'min' => 0,
                    'max' => 100,
                    'step' => 5,
                    'class' => 'form-input text-sm',
                ],
                'constraints' => [
                    new Assert\Range(['min' => 0, 'max' => 100, 'notInRangeMessage' => 'Doit être entre 0 et 100%']),
                    new Assert\Type(['type' => 'numeric', 'message' => 'Doit être un nombre.'])
                ]
            ])
            ->add('autonomie_min', NumberType::class, [ // Filter by numeric value
                'label' => 'Autonomie Min.',
                'label_attr' => ['class' => 'sr-only'],
                'required' => false,
                'html5' => true,
                'attr' => [
                    'placeholder' => 'Autonomie Min (km)',
                    'min' => 0,
                    'step' => 1,
                    'class' => 'form-input text-sm',
                ],
                'constraints' => [
                    new Assert\PositiveOrZero(['message' => 'Doit être un nombre positif.']),
                    new Assert\Type(['type' => 'numeric', 'message' => 'Doit être un nombre.'])
                ]
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'method' => 'GET',
            'csrf_protection' => false,
            'data_class' => null,
        ]);
    }

    public function getBlockPrefix(): string
    {
        // Return empty to avoid prefixing query params (e.g., ?search=... instead of ?public_trottinette_filter[search]=...)
        return '';
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/EventType.php -----
<?php
// src/Form/EventType.php
namespace App\Form;

use App\Entity\Event;
use App\Enum\GouvernoratEnum; // Import Enum
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType; // Keep for status if is_admin_edit
use Symfony\Component\Form\Extension\Core\Type\DateTimeType;
use Symfony\Component\Form\Extension\Core\Type\EnumType; // Use EnumType
use Symfony\Component\Form\Extension\Core\Type\IntegerType; // Use IntegerType
use Symfony\Component\Form\Extension\Core\Type\TextareaType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class EventType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('titre', TextType::class, [
                'label' => 'Titre de l\'Événement',
                'attr' => ['placeholder' => 'Ex: Balade collective au Parc'],
                'required' => true, // Ensure title is required
            ])
            ->add('description', TextareaType::class, [
                'label' => 'Description',
                'required' => false,
                'attr' => ['rows' => 4, 'placeholder' => 'Décrivez l\'événement...'],
            ])
            ->add('state', EnumType::class, [ // Use EnumType
                'class' => GouvernoratEnum::class,
                'label' => 'Gouvernorat / Lieu',
                'choice_label' => fn (GouvernoratEnum $choice): string => $choice->label(), // Use the label method
                'placeholder' => 'Sélectionnez le lieu',
                'attr' => ['class' => 'form-select'],
                'required' => true, // Ensure lieu is required
            ])
            ->add('dateDebut', DateTimeType::class, [
                'widget' => 'single_text',
                'label' => 'Date et Heure de Début',
                'html5' => true,
                'attr' => ['min' => (new \DateTime())->format('Y-m-d\TH:i')],
                'required' => true, // Ensure date is required
            ])
            ->add('dateFin', DateTimeType::class, [
                'widget' => 'single_text',
                'label' => 'Date et Heure de Fin',
                'html5' => true,
                'attr' => ['min' => (new \DateTime())->format('Y-m-d\TH:i')], // Basic check, validation should enforce dateFin > dateDebut
                'required' => true, // Ensure date is required
            ])
            ->add('trottinetteMinAutonomie', IntegerType::class, [ // Use IntegerType
                'label' => 'Autonomie Minimale Requise (km)',
                'required' => false,
                'attr' => ['placeholder' => 'Ex: 15', 'min' => 0],
                'help' => 'Laissez vide si non applicable.',
            ]);

        // Status field only for Admin edit form
            $builder->add('statut', ChoiceType::class, [
                'label' => 'Statut Événement',
                'choices' => [ // Translate labels
                    'À Venir' => 'A_VENIR',
                    'placeholder' => false,             // no “-- choose --” blank

                    'En Cours' => 'EN_COURS',
                    'Terminé' => 'TERMINE',
                    'Annulé' => 'ANNULE',
                ],
                'attr' => ['class' => 'form-select'],
                'placeholder' => 'Choisir un statut',
            ]);
        }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Event::class,
            'is_admin_edit' => false, // Custom option
            'attr' => ['novalidate' => 'novalidate'],
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/ReclamationSearchType.php -----
<?php
namespace App\Form;

use App\Dto\ReclamationSearchCriteria;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\DateType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class ReclamationSearchType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('dateDebut', DateType::class, [
                'widget' => 'single_text',
                'required' => false,
                'label' => 'Date Création Après',
            ])
            ->add('dateFin', DateType::class, [
                'widget' => 'single_text',
                'required' => false,
                'label' => 'Date Création Avant',
            ])
            ->add('typeReclamation', TextType::class, [
                'required' => false,
                'label' => 'Type de Réclamation',
            ])
            ->add('userEmail', TextType::class, [
                'required' => false,
                'label' => 'Email Utilisateur',
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => ReclamationSearchCriteria::class,
            'method' => 'GET',
            'csrf_protection' => false,
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Validator/RecaptchaV2Validator.php -----
<?php
// src/Validator/RecaptchaV2Validator.php
namespace App\Validator;

use Symfony\Component\HttpFoundation\RequestStack;
use Symfony\Component\Validator\Constraint;
use Symfony\Component\Validator\ConstraintValidator;
use Symfony\Component\Validator\Exception\UnexpectedTypeException;
use Symfony\Contracts\HttpClient\HttpClientInterface;
use Psr\Log\LoggerInterface; // Optional for logging

class RecaptchaV2Validator extends ConstraintValidator
{
    private RequestStack $requestStack;
    private HttpClientInterface $httpClient;
    private string $recaptchaSecretKey;
    private ?LoggerInterface $logger; // Optional

    // Inject necessary services and the secret key
    public function __construct(
        RequestStack $requestStack,
        HttpClientInterface $httpClient,
        string $recaptchaV2SecretKey, // Bind this in services.yaml or via env var directly
        ?LoggerInterface $logger = null // Optional logger
    ) {
        $this->requestStack = $requestStack;
        $this->httpClient = $httpClient;
        $this->recaptchaSecretKey = $recaptchaV2SecretKey;
        $this->logger = $logger;
    }

    public function validate(mixed $value, Constraint $constraint): void
    {
        if (!$constraint instanceof RecaptchaV2) {
            throw new UnexpectedTypeException($constraint, RecaptchaV2::class);
        }

        $request = $this->requestStack->getCurrentRequest();
        if (!$request) {
            // Cannot validate without a request context
            $this->logger?->warning('RecaptchaV2Validator: Request context not found.');
            // Optionally add violation, but likely means non-web context
            return;
        }

        // 'g-recaptcha-response' is the default name Google uses for the token
        $recaptchaResponse = $request->request->get('g-recaptcha-response');

        if (empty($recaptchaResponse)) {
            $this->context->buildViolation($constraint->message) // Use the main message
            ->addViolation();
            return;
        }

        if (!is_string($recaptchaResponse)) {
            $this->context->buildViolation($constraint->invalidInputMessage)
                ->addViolation();
            return;
        }

        try {
            $response = $this->httpClient->request('POST', 'https://www.google.com/recaptcha/api/siteverify', [
                'body' => [
                    'secret' => $this->recaptchaSecretKey,
                    'response' => $recaptchaResponse,
                    'remoteip' => $request->getClientIp(),
                ],
            ]);

            $data = $response->toArray(); // Throws exceptions on client/server errors

            if (!isset($data['success']) || $data['success'] !== true) {
                $this->logger?->warning('reCAPTCHA verification failed.', ['response_data' => $data]);
                $this->context->buildViolation($constraint->message)
                    ->setParameter('{{ error_codes }}', isset($data['error-codes']) ? implode(', ', $data['error-codes']) : 'N/A')
                    ->addViolation();
            }
            // If successful, do nothing (validation passes)

        } catch (\Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface $e) {
            $this->logger?->error('reCAPTCHA transport error: '.$e->getMessage());
            $this->context->buildViolation('Erreur de communication avec le service reCAPTCHA.')
                ->addViolation();
        } catch (\Symfony\Contracts\HttpClient\Exception\ExceptionInterface $e) {
            $this->logger?->error('reCAPTCHA client/server error: '.$e->getMessage());
            $this->context->buildViolation('Erreur lors de la vérification reCAPTCHA.')
                ->addViolation();
        } catch (\Exception $e){ // Catch potential JSON errors etc.
            $this->logger?->error('reCAPTCHA generic error: '.$e->getMessage());
            $this->context->buildViolation('Une erreur inattendue est survenue lors de la vérification.')
                ->addViolation();
        }
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Validator/RecaptchaV2.php -----
<?php
// src/Validator/RecaptchaV2.php
namespace App\Validator;

use Symfony\Component\Validator\Constraint;

#[\Attribute(\Attribute::TARGET_PROPERTY | \Attribute::TARGET_METHOD | \Attribute::IS_REPEATABLE)]
class RecaptchaV2 extends Constraint
{
    public string $message = 'La vérification reCAPTCHA a échoué. Veuillez réessayer.';
    public string $invalidInputMessage = 'La réponse reCAPTCHA n\'est pas valide.';
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Security/PasswordOnlyAuthenticator.php -----
<?php
// src/Security/PasswordOnlyAuthenticator.php
namespace App\Security;

use App\Entity\Utilisateur;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\Exception\CustomUserMessageAuthenticationException;
use Symfony\Component\Security\Http\Authenticator\AbstractLoginFormAuthenticator;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\RememberMeBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Credentials\PasswordCredentials;
use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
use Symfony\Component\Security\Http\SecurityRequestAttributes;
use Symfony\Component\Security\Http\Util\TargetPathTrait;

class PasswordOnlyAuthenticator extends AbstractLoginFormAuthenticator
{
    use TargetPathTrait;

    // Route specifically for password submission
    public const LOGIN_ROUTE = 'app_login_authenticate_password';

    private UrlGeneratorInterface $urlGenerator;

    public function __construct(UrlGeneratorInterface $urlGenerator)
    {
        $this->urlGenerator = $urlGenerator;
    }

    public function supports(Request $request): bool
    {
        // Only supports the specific password submission route and POST method
        return self::LOGIN_ROUTE === $request->attributes->get('_route')
            && $request->isMethod('POST');
    }

    public function authenticate(Request $request): Passport
    {
        $email = $request->request->get('email', ''); // Expect 'email' from the form
        $password = $request->request->get('password', ''); // Expect 'password'

        if (empty($email) || empty($password)) {
            throw new CustomUserMessageAuthenticationException('Email et mot de passe requis.');
        }

        $request->getSession()->set(SecurityRequestAttributes::LAST_USERNAME, $email);

        return new Passport(
            new UserBadge($email),
            new PasswordCredentials($password),
            [
                // NO CsrfTokenBadge here as per request
                new RememberMeBadge(),
            ]
        );
    }

    public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
    {
        $user = $token->getUser();

        if (!$user instanceof Utilisateur) {
            return new RedirectResponse($this->urlGenerator->generate('app_home'));
        }

        // --- CRITICAL CHECKS ---
        if (!$user->isActive()) {
            // Logout immediately and show message
            // Note: Since we bypassed UserChecker, we need to handle this here.
            $request->getSession()->remove('_security_main'); // Clear potential session token
            throw new CustomUserMessageAccountStatusException('Votre compte a été désactivé.');
        }
        if (!$user->isVerified()) {
            // Logout immediately and show message
            $request->getSession()->remove('_security_main');
            throw new CustomUserMessageAccountStatusException('Votre compte n\'est pas vérifié. Veuillez consulter votre e-mail.');
        }
        // --- END CRITICAL CHECKS ---


        // Redirect logic
        if ($targetPath = $this->getTargetPath($request->getSession(), $firewallName)) {
            return new RedirectResponse($targetPath);
        }

        $roles = $user->getRoles();
        if (in_array('ROLE_ADMIN', $roles, true)) {
            return new RedirectResponse($this->urlGenerator->generate('admin_dashboard'));
        } elseif (in_array('ROLE_PARTENAIRE', $roles, true)) {
            return new RedirectResponse($this->urlGenerator->generate('app_partenaire_dashboard'));
        } else {
            return new RedirectResponse($this->urlGenerator->generate('client_dashboard'));
        }
    }

    protected function getLoginUrl(Request $request): string
    {
        // URL of the page *displaying* the login form
        return $this->urlGenerator->generate('app_login_page');
    }

    // onAuthenticationFailure can remain similar, redirecting back to login page
    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): Response
    {
        if ($request->hasSession()) {
            $request->getSession()->set(SecurityRequestAttributes::AUTHENTICATION_ERROR, $exception);
        }

        $url = $this->getLoginUrl($request);

        return new RedirectResponse($url);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Security/EmailVerifier.php -----
<?php
// src/Security/EmailVerifier.php
namespace App\Security;

use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bridge\Twig\Mime\TemplatedEmail;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Mailer\Exception\TransportExceptionInterface; // Import exception
use Symfony\Component\Mailer\MailerInterface;
use Symfony\Component\Security\Core\User\UserInterface;
use SymfonyCasts\Bundle\VerifyEmail\Exception\VerifyEmailExceptionInterface;
use SymfonyCasts\Bundle\VerifyEmail\VerifyEmailHelperInterface;
use App\Entity\Utilisateur; // Your User class

class EmailVerifier
{
    public function __construct(
        private VerifyEmailHelperInterface $verifyEmailHelper,
        private MailerInterface $mailer,
        private EntityManagerInterface $entityManager
    ) {
    }

    /**
     * @throws TransportExceptionInterface
     */
    public function sendEmailConfirmation(string $verifyEmailRouteName, Utilisateur $user, TemplatedEmail $email): void
    {
        // Ensure the user object is the correct type
        if (!$user instanceof Utilisateur) {
            throw new \LogicException('User must be an instance of ' . Utilisateur::class);
        }
        if (!$user->getId()) {
            throw new \LogicException('User must have an ID to generate verification signature.');
        }
        if (!$user->getEmail()) {
            throw new \LogicException('User must have an email address.');
        }

        $signatureComponents = $this->verifyEmailHelper->generateSignature(
            $verifyEmailRouteName,
            (string) $user->getId(), // Cast ID to string
            $user->getEmail(),
            ['id' => (string) $user->getId()] // Ensure parameters match route requirements
        );

        $context = $email->getContext();
        $context['signedUrl'] = $signatureComponents->getSignedUrl();
        $context['expiresAtMessageKey'] = $signatureComponents->getExpirationMessageKey();
        $context['expiresAtMessageData'] = $signatureComponents->getExpirationMessageData();

        $email->context($context);

        $this->mailer->send($email);
    }

    /**
     * @throws VerifyEmailExceptionInterface
     */
    public function handleEmailConfirmation(Request $request, Utilisateur $user): void
    {
        // Ensure the user object is the correct type
        if (!$user instanceof Utilisateur) {
            throw new \LogicException('User must be an instance of ' . Utilisateur::class);
        }
        if (!$user->getId()) {
            throw new \LogicException('User must have an ID to validate email confirmation.');
        }
        if (!$user->getEmail()) {
            throw new \LogicException('User must have an email address.');
        }

        // The verifyEmailHelper->validateEmailConfirmation() method throws the exception if validation fails
        $this->verifyEmailHelper->validateEmailConfirmation($request->getUri(), (string) $user->getId(), $user->getEmail());

        $user->setIsVerified(true);

        // No need to persist, just flush the change
        $this->entityManager->flush();
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Security/FacialAuthenticator.php -----
<?php
// src/Security/FacialAuthenticator.php
namespace App\Security;

use App\Entity\Utilisateur; // Use your User entity
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse; // For AJAX responses
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\Exception\CustomUserMessageAuthenticationException;
use Symfony\Component\Security\Http\Authenticator\AbstractLoginFormAuthenticator;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\CsrfTokenBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\RememberMeBadge; // Optional
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Credentials\PasswordCredentials;
use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
use Symfony\Component\Security\Http\SecurityRequestAttributes;
use Symfony\Component\Security\Http\Util\TargetPathTrait;

class FacialAuthenticator extends AbstractLoginFormAuthenticator
{
    use TargetPathTrait;

    public const LOGIN_ROUTE = 'app_login_authenticate'; // Define a specific route for the *final* password submission

    private UrlGeneratorInterface $urlGenerator;

    public function __construct(UrlGeneratorInterface $urlGenerator)
    {
        $this->urlGenerator = $urlGenerator;
    }

    /**
     * Does the authenticator support the given Request?
     *
     * Check that the path and method match.
     */
    public function supports(Request $request): bool
    {
        return self::LOGIN_ROUTE === $request->attributes->get('_route')
            && $request->isMethod('POST');
    }

    /**
     * Create a passport for the current request.
     *
     * The passport contains the user, credentials and badges that are used to
     * authenticate the user. (e.g. Passport::END_SIGNAL tells skip credentials verification)
     *
     * @throws AuthenticationException
     */
    public function authenticate(Request $request): Passport
    {
        // This method is only called for the *final* password submission step
        // The email and face verification happen via AJAX calls handled by LoginController
        $email = $request->request->get('email', '');
        $password = $request->request->get('password', '');
        $csrfToken = $request->request->get('_csrf_token', '');
        // The face token is *not* directly handled here, it's checked by FacialUserChecker

        if (empty($email) || empty($password) || empty($csrfToken)) {
            throw new CustomUserMessageAuthenticationException('Email, mot de passe et jeton CSRF requis.');
        }

        $request->getSession()->set(SecurityRequestAttributes::LAST_USERNAME, $email);

        return new Passport(
            new UserBadge($email), // Finds user by email
            new PasswordCredentials($password), // Checks password
            [
                new CsrfTokenBadge('authenticate', $csrfToken), // Checks CSRF
                new RememberMeBadge(), // Optional: Enable "remember me" functionality
                // No custom badge for face token here, UserChecker intercepts earlier
            ]
        );
    }

    /**
     * Called on successfull authentication.
     *
     * @param Request $request
     * @param TokenInterface $token
     * @param string $firewallName The name of the firewall secureing the authenticator
     *
     * @return Response|null Null means continue
     */
    public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
    {
        // Redirect logic based on user roles, similar to your original manual controller
        $user = $token->getUser();

        // Clear the temporary face token from session after successful login
        $request->getSession()->remove('face_recognition_token');


        if (!$user instanceof Utilisateur) {
            // Should not happen if UserBadge works correctly
            return new RedirectResponse($this->urlGenerator->generate('app_home'));
        }

        // Ensure user is active and verified *before* redirecting
        if (!$user->isActive()) {
            // Log user out immediately and show message
            $this->logoutUser($request);
            throw new CustomUserMessageAuthenticationException('Votre compte a été désactivé.');
        }
        if (!$user->isVerified()) {
            // Log user out immediately and show message
            $this->logoutUser($request);
            throw new CustomUserMessageAuthenticationException('Votre compte n\'est pas vérifié. Veuillez consulter votre e-mail.');
        }

        // Redirect based on target path or roles
        if ($targetPath = $this->getTargetPath($request->getSession(), $firewallName)) {
            return new RedirectResponse($targetPath);
        }

        $roles = $user->getRoles();
        if (in_array('ROLE_ADMIN', $roles, true)) {
            return new RedirectResponse($this->urlGenerator->generate('admin_dashboard'));
        } elseif (in_array('ROLE_PARTENAIRE', $roles, true)) {
            return new RedirectResponse($this->urlGenerator->generate('app_partenaire_dashboard'));
        } else {
            return new RedirectResponse($this->urlGenerator->generate('client_dashboard'));
        }
    }

    /**
     * Called on failure. Used for AJAX login to return JSON.
     * For traditional forms, it's usually handled by getLoginUrl().
     *
     * @return Response
     */
    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): Response
    {
        // Store error in session to display on the login page
        // Use a specific key for facial login errors
        $request->getSession()->set(SecurityRequestAttributes::AUTHENTICATION_ERROR, $exception);

        // Ensure the temporary face token is cleared on failure too
        $request->getSession()->remove('face_recognition_token');

        // Return JSON response indicating failure for the AJAX call
        return new JsonResponse([
            'success' => false,
            // Use a generic message for security, details are in the exception if needed
            'message' => strtr($exception->getMessageKey(), $exception->getMessageData())
            // 'message' => 'Identifiants invalides ou erreur d\'authentification.'
        ], Response::HTTP_UNAUTHORIZED); // Use 401 status code
    }

    /**
     * Return the URL to the login page.
     */
    protected function getLoginUrl(Request $request): string
    {
        // URL of the page displaying the login form (not the processing route)
        return $this->urlGenerator->generate('app_login_page');
    }

    /**
     * Helper to logout user if needed during success check (e.g., inactive/unverified)
     */
    private function logoutUser(Request $request): void
    {
        // Invalidating the session and removing the token manually
        // This requires TokenStorageInterface, SessionInterface - inject if needed
        // Or rely on security system logout handlers if configured
        // For simplicity here, just clear the session attribute if set
        $request->getSession()->remove('_security_main'); // Adjust 'main' if firewall name differs
        $request->getSession()->remove('face_recognition_token');
        // Potentially call tokenStorage->setToken(null) if available
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Security/FacialUserChecker.php -----
<?php
// src/Security/FacialUserChecker.php
namespace App\Security;

use App\Entity\Utilisateur; // Your User entity
use Symfony\Component\HttpFoundation\RequestStack;
use Symfony\Component\Security\Core\Exception\CustomUserMessageAccountStatusException;
use Symfony\Component\Security\Core\User\UserCheckerInterface;
use Symfony\Component\Security\Core\User\UserInterface;

class FacialUserChecker implements UserCheckerInterface
{
    private RequestStack $requestStack;

    public function __construct(RequestStack $requestStack)
    {
        $this->requestStack = $requestStack;
    }

    /**
     * Checks the user account before authentication.
     * Verifies the temporary face recognition token.
     */
    public function checkPreAuth(UserInterface $user): void
    {
        if (!$user instanceof Utilisateur) {
            return; // Only check for your specific user type
        }

        $request = $this->requestStack->getCurrentRequest();
        if (!$request) {
            // Should not happen in a web context, but good practice
            throw new CustomUserMessageAccountStatusException("Contexte de requête introuvable.");
        }

        // Get the token submitted with the password form
        $submittedToken = $request->request->get('face_token'); // Name this field in your login JS final POST

        // Get the token stored in the session during face verification step
        $session = $this->requestStack->getSession();
        $expectedToken = $session->get('face_recognition_token');

        // Basic check: Is a token expected for this login attempt?
        // If $expectedToken is null, maybe allow standard password login?
        // For strict facial+password, we require $expectedToken.
        if ($expectedToken === null) {
            throw new CustomUserMessageAccountStatusException("Session de reconnaissance faciale invalide ou expirée. Veuillez recommencer.");
        }

        // Compare the tokens
        if (empty($submittedToken) || !hash_equals((string)$expectedToken, (string)$submittedToken)) {
            // Clear the session token on mismatch to force restart
            $session->remove('face_recognition_token');
            // Throw exception to block login
            throw new CustomUserMessageAccountStatusException("Jeton de reconnaissance faciale invalide ou manquant. Connexion bloquée.");
        }

        // Token is valid! It will be cleared in onAuthenticationSuccess of the authenticator.
        // Don't clear it here yet, as password check might still fail.
    }

    /**
     * Checks the user account after authentication.
     * (Can check for inactive, banned status here if not done elsewhere)
     */
    public function checkPostAuth(UserInterface $user): void
    {
        if (!$user instanceof Utilisateur) {
            return;
        }

        // Example: Check if account is active (can also be done in onAuthenticationSuccess)
        // if (!$user->isActive()) {
        //     throw new CustomUserMessageAccountStatusException('Votre compte est désactivé.');
        // }
        // Example: Check if email is verified (can also be done in onAuthenticationSuccess)
        // if (!$user->isVerified()) {
        //     throw new CustomUserMessageAccountStatusException('Votre compte n\'est pas vérifié.');
        // }
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Security/LoginFormAuthenticator.php -----
<?php
// src/Security/LoginFormAuthenticator.php
namespace App\Security;

use App\Entity\Utilisateur;
use Doctrine\ORM\EntityManagerInterface; // Needed if checking isVerified status before login attempt potentially
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\CustomUserMessageAuthenticationException;
use Symfony\Component\Security\Core\Security; // Deprecated, use SecurityRequestAttributes
use Symfony\Component\Security\Http\Authenticator\AbstractLoginFormAuthenticator;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\CsrfTokenBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\RememberMeBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Credentials\PasswordCredentials;
use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
use Symfony\Component\Security\Http\Util\TargetPathTrait;
use Symfony\Component\Security\Http\SecurityRequestAttributes; // Use this


class LoginFormAuthenticator extends AbstractLoginFormAuthenticator
{
    use TargetPathTrait;

    public const LOGIN_ROUTE = 'app_login';

    private UrlGeneratorInterface $urlGenerator;
    // private EntityManagerInterface $entityManager; // Inject if needed

    public function __construct(UrlGeneratorInterface $urlGenerator /*, EntityManagerInterface $entityManager*/)
    {
        $this->urlGenerator = $urlGenerator;
        // $this->entityManager = $entityManager;
    }

    public function authenticate(Request $request): Passport
    {
        $email = $request->request->get('email', '');

        $request->getSession()->set(SecurityRequestAttributes::LAST_USERNAME, $email);

        return new Passport(
            new UserBadge($email),
            new PasswordCredentials($request->request->get('password', '')),
            [
                new CsrfTokenBadge('authenticate', $request->request->get('_csrf_token')),
                new RememberMeBadge(),
            ]
        );
    }

    public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
    {
        // Check if the user's email is verified BEFORE allowing login success
        $user = $token->getUser();
        if ($user instanceof Utilisateur && !$user->isActive()) {
            throw new CustomUserMessageAuthenticationException('Votre compte a été désactivé.');
        }
        if ($user instanceof Utilisateur && !$user->isVerified()) {
            // Optionally flash a message
            $this->addFlash($request, 'warning', 'Votre compte n\'est pas encore vérifié. Veuillez consulter votre email.');

            // Throw an exception to prevent login - this will redirect to login page with the flash message
            // You might want a custom exception if you want different handling
            throw new CustomUserMessageAuthenticationException('Compte non vérifié.');

            // Alternative: Redirect explicitly, but user remains technically authenticated for this request
            // return new RedirectResponse($this->urlGenerator->generate('app_login'));
        }


        if ($targetPath = $this->getTargetPath($request->getSession(), $firewallName)) {
            return new RedirectResponse($targetPath);
        }

        // Redirect based on role
        if ($user instanceof Utilisateur) { // Check if user object is available
            if (in_array('ROLE_ADMIN', $user->getRoles(), true)) {
                return new RedirectResponse($this->urlGenerator->generate('app_admin_dashboard'));
            }
            if (in_array('ROLE_PARTENAIRE', $user->getRoles(), true)) {
                return new RedirectResponse($this->urlGenerator->generate('app_partenaire_dashboard'));
            }
            // Default for ROLE_USER or others
            return new RedirectResponse($this->urlGenerator->generate('client_dashboard')); // Default to client dashboard
        }

        // Fallback redirect
        return new RedirectResponse($this->urlGenerator->generate('app_home'));
    }

    protected function getLoginUrl(Request $request): string
    {
        return $this->urlGenerator->generate(self::LOGIN_ROUTE);
    }

    // Helper function to add flash messages
    private function addFlash(Request $request, string $type, string $message): void
    {
        // Check if the session factory is available
        if ($request->hasSession()) {
            $request->getSession()->getFlashBag()->add($type, $message);
        }
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Maintenance.php -----
<?php

namespace App\Entity;

use App\Repository\MaintenanceRepository;
use Doctrine\ORM\Mapping as ORM;
use DateTime;
use Symfony\Component\Validator\Constraints as Assert;

#[ORM\Entity(repositoryClass: MaintenanceRepository::class)]
#[ORM\Table(name: 'maintenance')]
class Maintenance
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\Column(name: "trottinetteId", type: "integer")]
    private ?int $trottinetteId = null;

    #[ORM\ManyToOne(targetEntity: Trottinette::class)]
    #[ORM\JoinColumn(name: 'trottinetteId', referencedColumnName: 'id', nullable: false)]
    #[Assert\NotNull(message: 'Une trottinette doit être associée à la maintenance.')]
    private ?Trottinette $trottinette = null;

    #[ORM\Column(type: 'text')]
    #[Assert\NotBlank(message: 'La description ne peut pas être vide.')]
    #[Assert\Length(
        min: 10,
        minMessage: 'La description doit comporter au moins {{ limit }} caractères.'
    )]
    private string $description;

    #[ORM\Column(name: 'dateDebut', type: 'datetime')]
    #[Assert\NotNull(message: 'La date de début est requise.')]
    #[Assert\Type("\DateTime", message: 'La valeur {{ value }} n\'est pas une date valide.')]
    private DateTime $dateDebut;

    #[ORM\Column(name: 'dateFin', type: 'datetime', nullable: true)]
    #[Assert\Type("\DateTime", message: 'La valeur {{ value }} n\'est pas une date valide.')]
    #[Assert\GreaterThan(
        propertyPath: "dateDebut",
        message: "La date de fin doit être postérieure à la date de début."
    )]
    private ?DateTime $dateFin = null;

    #[ORM\Column(name: "statut", type: "string", columnDefinition: "ENUM('EN_COURS','TERMINEE','ANNULEE')")]
    #[Assert\NotBlank(message: 'Le statut ne peut pas être vide.')]
    #[Assert\Choice(
        choices: ['EN_COURS', 'TERMINEE', 'ANNULEE'],
        message: 'Le statut choisi n\'est pas valide. Statuts autorisés: EN_COURS, TERMINEE, ANNULEE.'
    )]
    private ?string $statut = null;

    /**
     * Virtual property for type that is not mapped to database
     * Use this for forms and display but don't persist it
     */
    #[Assert\Choice(
        choices: ['REPARATION', 'ENTRETIEN', 'VERIFICATION'],
        message: 'Le type choisi n\'est pas valide. Types autorisés: REPARATION, ENTRETIEN, VERIFICATION.'
    )]
    private ?string $type = null;

    public function __construct()
    {
        $this->dateDebut = new DateTime();
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getTrottinetteId(): ?int
    {
        return $this->trottinetteId;
    }

    public function setTrottinetteId(?int $trottinetteId): self
    {
        $this->trottinetteId = $trottinetteId;
        return $this;
    }

    public function getTrottinette(): ?Trottinette
    {
        return $this->trottinette;
    }

    public function setTrottinette(?Trottinette $trottinette): self
    {
        $this->trottinette = $trottinette;
        return $this;
    }

    public function getDateDebut(): DateTime
    {
        return $this->dateDebut;
    }

    public function setDateDebut(DateTime $dateDebut): self
    {
        $this->dateDebut = $dateDebut;
        return $this;
    }

    public function getDateFin(): ?DateTime
    {
        return $this->dateFin;
    }

    public function setDateFin(?DateTime $dateFin): self
    {
        $this->dateFin = $dateFin;
        return $this;
    }

    public function getDescription(): string
    {
        return $this->description;
    }

    public function setDescription(string $description): self
    {
        $this->description = $description;
        return $this;
    }

    public function getStatut(): ?string
    {
        return $this->statut;
    }

    public function setStatut(string $statut): self
    {
        $this->statut = $statut;
        return $this;
    }

    public function getType(): ?string
    {
        return $this->type;
    }

    public function setType(?string $type): self
    {
        $this->type = $type;
        return $this;
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Event.php -----
<?php
// src/Entity/Event.php
namespace App\Entity;

use App\Enum\GouvernoratEnum; // Import Enum
use App\Repository\EventRepository;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Doctrine\DBAL\Types\Types;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Validator\Constraints as Assert;
use DateTimeInterface; // Use DateTimeInterface

#[ORM\Entity(repositoryClass: EventRepository::class)]
#[ORM\Table(name: 'event')]
class Event
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\Column(length: 255)] // Removed nullable=true, added constraints
    #[Assert\NotBlank(message: "Le titre de l'événement est obligatoire.")]
    #[Assert\Length(min: 5, max: 255, minMessage: "Le titre doit faire entre 5 et 255 caractères.")]
    private ?string $titre = null;

    #[ORM\Column(type: Types::TEXT, nullable: true)]
    private ?string $description = null;

    #[ORM\Column(name: "dateDebut", type: Types::DATETIME_MUTABLE)] // Removed name, nullable=true, added constraints
    #[Assert\NotNull(message: "La date de début est obligatoire.")]
    #[Assert\Type("\DateTimeInterface")]
    #[Assert\GreaterThanOrEqual("today", message: "La date de début ne peut être dans le passé.")]
    private ?DateTimeInterface $dateDebut = null;

    #[ORM\Column(name: "dateFin", type: Types::DATETIME_MUTABLE)] // Removed name, nullable=true, added constraints
    #[Assert\NotNull(message: "La date de fin est obligatoire.")]
    #[Assert\Type("\DateTimeInterface")]
    #[Assert\GreaterThan(propertyPath: "dateDebut", message: "La date de fin doit être après la date de début.")]
    private ?DateTimeInterface $dateFin = null;

    #[ORM\Column(length: 50, enumType: GouvernoratEnum::class)] // Use EnumType, set length, removed nullable
    #[Assert\NotNull(message: "Le lieu (gouvernorat) est obligatoire.")]
    private ?GouvernoratEnum $state = null;

    #[ORM\Column(type: 'string', length: 50, options: ["default" => "A_VENIR"])] // Define length, use string type
    #[Assert\Choice(choices: ["A_VENIR", "EN_COURS", "TERMINE", "ANNULE"], message: "Statut d'événement invalide.")]
    private string $statut = 'A_VENIR';

    #[ORM\Column(name: "trottinetteMinAutonomie",type: 'integer', nullable: true)] // Removed name, changed type
    #[Assert\PositiveOrZero(message: "L'autonomie minimale doit être un nombre positif ou zéro.")]
    private ?int $trottinetteMinAutonomie = 0; // In km, assume default 0

    #[ORM\OneToMany(mappedBy: 'event', targetEntity: Participation::class, cascade: ['persist', 'remove'], orphanRemoval: true)]
    private Collection $participations;

    // Removed $state and $gouvernorat properties

    public function __construct()
    {
        $this->participations = new ArrayCollection();
    }

    // Getters and Setters (Standard - ensure type hints match)
    public function getId(): ?int { return $this->id; }
    public function getTitre(): ?string { return $this->titre; }
    public function setTitre(?string $titre): static { $this->titre = $titre; return $this; }
    public function getDescription(): ?string { return $this->description; }
    public function setDescription(?string $description): static { $this->description = $description; return $this; }
    public function getDateDebut(): ?DateTimeInterface { return $this->dateDebut; }
    public function setDateDebut(?DateTimeInterface $dateDebut): static { $this->dateDebut = $dateDebut; return $this; }
    public function getDateFin(): ?DateTimeInterface { return $this->dateFin; }
    public function setDateFin(?DateTimeInterface $dateFin): static { $this->dateFin = $dateFin; return $this; }
    public function getState(): ?GouvernoratEnum { return $this->state; } // Return Enum
    public function setState(?GouvernoratEnum $state): static { $this->state = $state; return $this; } // Accept Enum
    public function getStatut(): string { return $this->statut; }
    public function setStatut(string $statut): static { $this->statut = $statut; return $this; }
    public function getTrottinetteMinAutonomie(): ?int { return $this->trottinetteMinAutonomie; }
    public function setTrottinetteMinAutonomie(?int $trottinetteMinAutonomie): static { $this->trottinetteMinAutonomie = $trottinetteMinAutonomie; return $this; }

    /** @return Collection<int, Participation> */
    public function getParticipations(): Collection { return $this->participations; }
    public function addParticipation(Participation $participation): static { if (!$this->participations->contains($participation)) { $this->participations->add($participation); $participation->setEvent($this); } return $this; }
    public function removeParticipation(Participation $participation): static { if ($this->participations->removeElement($participation)) { if ($participation->getEvent() === $this) { $participation->setEvent(null); } } return $this; }

    // Helper for display
    public function getLieuValue(): ?string { return $this->state?->value; }

    public function __toString(): string
    {
        return $this->titre ?? 'Événement Inconnu';
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Reponse.php -----
<?php
// src/Entity/Reponse.php

namespace App\Entity;

use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Validator\Constraints as Assert;

#[ORM\Entity(repositoryClass: ReponseRepository::class)]
class Reponse
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private $id;

    #[ORM\ManyToOne(targetEntity: Reclamation::class, inversedBy: 'reponses')]
    #[ORM\JoinColumn(nullable: false)]
    private $reclamation;

    #[ORM\Column(type: 'text')]
    #[Assert\NotBlank(message: 'Le message ne peut pas être vide')]
    private $message;

    #[ORM\Column(type: 'datetime')]
    private $date_reponse;

    #[ORM\Column(type: 'string', length: 255)]
    #[Assert\NotBlank(message: 'Le type d\'utilisateur est requis')]
    private $user_type;

    // Getters and Setters

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getReclamation(): ?Reclamation
    {
        return $this->reclamation;
    }

    public function setReclamation(?Reclamation $reclamation): self
    {
        $this->reclamation = $reclamation;

        return $this;
    }

    public function getMessage(): ?string
    {
        return $this->message;
    }

    public function setMessage(string $message): self
    {
        $this->message = $message;

        return $this;
    }

    public function getDateReponse(): ?\DateTimeInterface
    {
        return $this->date_reponse;
    }

    public function setDateReponse(\DateTimeInterface $date_reponse): self
    {
        $this->date_reponse = $date_reponse;

        return $this;
    }

    public function getUserType(): ?string
    {
        return $this->user_type;
    }

    public function setUserType(string $user_type): self
    {
        $this->user_type = $user_type;

        return $this;
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Utilisateur.php -----
<?php
// src/Entity/Utilisateur.php
namespace App\Entity;

use App\Repository\UtilisateurRepository;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
use Symfony\Component\Security\Core\User\UserInterface;
use Symfony\Component\Validator\Constraints as Assert;
use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;

#[ORM\Entity(repositoryClass: UtilisateurRepository::class)]
#[ORM\Table(name: 'utilisateurs')]
#[UniqueEntity(fields: ['email'], message: 'Cette adresse email est déjà utilisée.')]
class Utilisateur implements UserInterface, PasswordAuthenticatedUserInterface
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\Column(length: 180, unique: true)]
    #[Assert\NotBlank(message: 'L\'email ne peut pas être vide.')]
    #[Assert\Email(message: 'L\'adresse email {{ value }} n\'est pas valide.')]
    #[Assert\Length(max: 180, maxMessage: 'L\'email ne peut pas dépasser {{ limit }} caractères.')]
    private ?string $email = null;
    // --- NEW DETAILS FIELD ---
    #[ORM\Column(type: 'text', nullable: true)]
    private ?string $details = null;

    /**
     * Internal role representation (simple string) - Corrected column name
     */
    #[ORM\Column(name: "role_interne", length: 50)]
    #[Assert\NotBlank(message: 'Le rôle ne peut pas être vide.')]
    #[Assert\Choice(
        choices: ['admin', 'client', 'partenaire'],
        message: 'Le rôle choisi n\'est pas valide. Rôles autorisés: admin, client, partenaire.'
    )]
    private string $roleInterne = 'client'; // Default role

    /**
     * @var string The hashed password - Corrected column name mapping
     */
    #[ORM\Column(name: "password")] // Map to 'password' column if changed from mot_de_passe_hash
    private ?string $password = null;

    #[ORM\Column(length: 255, name: "nom")]
    #[Assert\NotBlank(message: 'Le nom ne peut pas être vide.')]
    #[Assert\Length(min: 2, max: 255, minMessage: 'Le nom doit comporter au moins {{ limit }} caractères.', maxMessage: 'Le nom ne peut pas dépasser {{ limit }} caractères.')]
    private ?string $nom = null;

    #[ORM\Column(length: 255, name: "prenom")]
    #[Assert\NotBlank(message: 'Le prénom ne peut pas être vide.')]
    #[Assert\Length(min: 2, max: 255, minMessage: 'Le prénom doit comporter au moins {{ limit }} caractères.', maxMessage: 'Le prénom ne peut pas dépasser {{ limit }} caractères.')]
    private ?string $prenom = null;

    #[ORM\Column(length: 50, name: "telephone")]
    #[Assert\NotBlank(message: 'Le numéro de téléphone ne peut pas être vide.')]
    #[Assert\Regex(pattern: '/^[0-9+\s\-().]{8,15}$/', message: 'Le numéro de téléphone n\'est pas valide.')]
    private ?string $telephone = null;

    #[ORM\Column(type: 'boolean')]
    private bool $isVerified = false;

    #[ORM\Column(type: 'boolean', options: ['default' => true])]
    private bool $isActive = true;

    // --- NEW: Facial Recognition Embedding ---
    #[ORM\Column(type: 'text', nullable: true)]
    private ?string $faceEmbedding = null;
    // --- END NEW ---

    #[ORM\OneToMany(mappedBy: 'utilisateur', targetEntity: Reservation::class, cascade: ['persist', 'remove'], orphanRemoval: true)]
    private Collection $reservations;

    #[ORM\OneToMany(mappedBy: 'utilisateur', targetEntity: Reclamation::class, cascade: ['persist', 'remove'], orphanRemoval: true)]
    private Collection $reclamations;

    #[ORM\OneToMany(mappedBy: 'utilisateur', targetEntity: Participation::class, cascade: ['persist', 'remove'], orphanRemoval: true)]
    private Collection $participations;

    // Removed Trottinettes collection unless explicit partner relation needed

    public function __construct()
    {
        $this->reservations = new ArrayCollection();
        $this->reclamations = new ArrayCollection();
        $this->participations = new ArrayCollection();
    }

    // --- GETTERS AND SETTERS ---

    public function getId(): ?int { return $this->id; }
    public function getEmail(): ?string { return $this->email; }
    public function setEmail(string $email): static { $this->email = $email; return $this; }

    /** @see UserInterface */
    public function getUserIdentifier(): string { return (string) $this->email; }

    public function isActive(): bool { return $this->isActive; }
    public function setIsActive(bool $isActive): static { $this->isActive = $isActive; return $this; }

    /** @see UserInterface */
    public function getRoles(): array
    {
        $roleMap = [
            'admin' => ['ROLE_ADMIN', 'ROLE_PARTENAIRE', 'ROLE_USER'],
            'partenaire' => ['ROLE_PARTENAIRE', 'ROLE_USER'],
            'client' => ['ROLE_USER']
        ];
        $roles = $roleMap[$this->roleInterne] ?? ['ROLE_USER'];
        $roles[] = 'ROLE_USER'; // Guarantee ROLE_USER
        return array_unique($roles);
    }

    // --- GETTER AND SETTER FOR NEW DETAILS FIELD ---
    public function getDetails(): ?string
    {
        return $this->details;
    }

    public function setDetails(?string $details): static
    {
        $this->details = $details;
        return $this;
    }
    public function getRoleInterne(): string { return $this->roleInterne; }
    public function setRoleInterne(string $roleInterne): static {
        if (!in_array($roleInterne, ['admin', 'client', 'partenaire'])) {
            throw new \InvalidArgumentException("Invalid role");
        }
        $this->roleInterne = $roleInterne;
        return $this;
    }

    /** @see PasswordAuthenticatedUserInterface */
    public function getPassword(): ?string { return $this->password; } // Return nullable
    public function setPassword(string $password): static { $this->password = $password; return $this; }

    /** @see UserInterface */
    public function getSalt(): ?string { return null; } // Not needed

    /** @see UserInterface */
    public function eraseCredentials(): void { /* $this->plainPassword = null; */ }

    public function getNom(): ?string { return $this->nom; }
    public function setNom(string $nom): static { $this->nom = $nom; return $this; }
    public function getPrenom(): ?string { return $this->prenom; }
    public function setPrenom(string $prenom): static { $this->prenom = $prenom; return $this; }
    public function getTelephone(): ?string { return $this->telephone; }
    public function setTelephone(?string $telephone): static { $this->telephone = $telephone; return $this; }
    public function isVerified(): bool { return $this->isVerified; }
    public function setIsVerified(bool $isVerified): static { $this->isVerified = $isVerified; return $this; }
    public function getFullName(): string { return $this->prenom . ' ' . $this->nom; }

    // --- NEW: Getters and Setters for Face Embedding ---
    public function getFaceEmbedding(): ?string
    {
        return $this->faceEmbedding;
    }

    public function setFaceEmbedding(?string $faceEmbedding): static
    {
        $this->faceEmbedding = $faceEmbedding;
        return $this;
    }
    // --- END NEW ---


    // --- Collection Methods ---
    /** @return Collection<int, Reservation> */
    public function getReservations(): Collection { return $this->reservations; }
    public function addReservation(Reservation $reservation): static { if (!$this->reservations->contains($reservation)) { $this->reservations->add($reservation); $reservation->setUtilisateur($this); } return $this; }
    public function removeReservation(Reservation $reservation): static { if ($this->reservations->removeElement($reservation)) { if ($reservation->getUtilisateur() === $this) { $reservation->setUtilisateur(null); } } return $this; }
    /** @return Collection<int, Reclamation> */
    public function getReclamations(): Collection { return $this->reclamations; }
    public function addReclamation(Reclamation $reclamation): static { if (!$this->reclamations->contains($reclamation)) { $this->reclamations->add($reclamation); $reclamation->setUtilisateur($this); } return $this; }
    public function removeReclamation(Reclamation $reclamation): static { if ($this->reclamations->removeElement($reclamation)) { if ($reclamation->getUtilisateur() === $this) { $reclamation->setUtilisateur(null); } } return $this; }
    /** @return Collection<int, Participation> */
    public function getParticipations(): Collection { return $this->participations; }
    public function addParticipation(Participation $participation): static { if (!$this->participations->contains($participation)) { $this->participations->add($participation); $participation->setUtilisateur($this); } return $this; }
    public function removeParticipation(Participation $participation): static { if ($this->participations->removeElement($participation)) { if ($participation->getUtilisateur() === $this) { $participation->setUtilisateur(null); } } return $this; }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/PointRelais.php -----
<?php

namespace App\Entity;

use App\Repository\PointRelaisRepository;
use Doctrine\DBAL\Types\Types;
use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity(repositoryClass: PointRelaisRepository::class)]
class PointRelais
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\Column(length: 255)]
    #[Assert\NotBlank(message: 'Le nom est obligatoire.')]
    #[Assert\Length(
        max: 255,
        maxMessage: 'Le nom ne peut pas dépasser {{ limit }} caractères.'
    )]
    private ?string $nom = null;

    #[ORM\Column(length: 255)]
    #[Assert\NotBlank(message: 'L\'adresse est obligatoire.')]
    #[Assert\Length(
        max: 255,
        maxMessage: 'L\'adresse ne peut pas dépasser {{ limit }} caractères.'
    )]
    private ?string $addresse = null;

    #[ORM\Column(type: Types::DATE_MUTABLE)]
    #[Assert\NotBlank(message: 'La date d\'ouverture est obligatoire.')]
    #[Assert\Type(
        type: \DateTimeInterface::class,
        message: 'La valeur {{ value }} n\'est pas une date valide.'
    )]
    private ?\DateTimeInterface $HoraireOuverture = null;

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getNom(): ?string
    {
        return $this->nom;
    }

    public function setNom(?string $nom): static
    {
        $this->nom = $nom;

        return $this;
    }

    public function getAddresse(): ?string
    {
        return $this->addresse;
    }

    public function setAddresse(?string $addresse): static
    {
        $this->addresse = $addresse;

        return $this;
    }

    public function getHoraireOuverture(): ?\DateTimeInterface
    {
        return $this->HoraireOuverture;
    }

    public function setHoraireOuverture(?\DateTimeInterface $HoraireOuverture): static
    {
        $this->HoraireOuverture = $HoraireOuverture;

        return $this;
    }


    public function __toString(): string
    {
        return $this->nom ?? 'PointRelais';
    }

}



----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Participation.php -----
<?php

namespace App\Entity;

use App\Repository\ParticipationRepository;
use App\Enum\ParticipationStatus;
use Doctrine\ORM\Mapping as ORM;
use DateTime;
use DateTimeInterface;

#[ORM\Entity(repositoryClass: ParticipationRepository::class)]
#[ORM\Table(name: 'participation')]
class Participation
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\ManyToOne(targetEntity: Event::class, inversedBy: 'participations')]
    #[ORM\JoinColumn(name: 'eventId', referencedColumnName: 'id', nullable: false)]
    private ?Event $event = null;

    #[ORM\Column(name: 'dateInscription', type: 'datetime', nullable: true)]
    private ?DateTimeInterface $dateInscription = null;

    #[ORM\Column(name: 'statut', type: 'string', enumType: ParticipationStatus::class)]
    private ?ParticipationStatus $statut = null;

    #[ORM\ManyToOne(targetEntity: Utilisateur::class, inversedBy: 'participations')]
    #[ORM\JoinColumn(name: 'utilisateurId', referencedColumnName: 'id', nullable: true)]
    private ?Utilisateur $utilisateur = null;

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getEvent(): ?Event
    {
        return $this->event;
    }

    public function setEvent(?Event $event): static
    {
        $this->event = $event;
        return $this;
    }

    public function getDateInscription(): ?DateTimeInterface
    {
        return $this->dateInscription;
    }

    public function setDateInscription(?DateTimeInterface $dateInscription): static
    {
        $this->dateInscription = $dateInscription;
        return $this;
    }

    public function getStatut(): ?ParticipationStatus
    {
        return $this->statut;
    }

    public function setStatut(ParticipationStatus $statut): static
    {
        $this->statut = $statut;
        return $this;
    }

    public function getUtilisateur(): ?Utilisateur
    {
        return $this->utilisateur;
    }

    public function setUtilisateur(?Utilisateur $utilisateur): static
    {
        $this->utilisateur = $utilisateur;
        return $this;
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Reservation.php -----
<?php
// src/Entity/Reservation.php
namespace App\Entity;

use App\Repository\ReservationRepository;
use Doctrine\DBAL\Types\Types;
use Doctrine\ORM\Mapping as ORM;
use App\Enum\Paiement;
use App\Enum\ReservationStatus;
use Symfony\Component\Validator\Constraints as Assert;
use DateTimeInterface;

#[ORM\Entity(repositoryClass: ReservationRepository::class)]
#[ORM\Table(name: 'reservation')] // Explicit table name
class Reservation
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\ManyToOne(targetEntity: Utilisateur::class, inversedBy: 'reservations')]
    #[ORM\JoinColumn(name: 'utilisateur_id', referencedColumnName: 'id', nullable: false)]
    #[Assert\NotNull(message: 'L\'utilisateur est requis.')]
    private ?Utilisateur $utilisateur = null;

    #[ORM\ManyToOne(targetEntity: Trottinette::class, inversedBy: 'reservations')]
    #[ORM\JoinColumn(name: 'trottinette_id', referencedColumnName: 'id', nullable: false)]
    #[Assert\NotNull(message: 'La trottinette est requise.')]
    private ?Trottinette $trottinette = null;

    #[ORM\Column(type: Types::DATETIME_MUTABLE)] // Changed name
    #[Assert\NotNull(message: 'La date de début de réservation est obligatoire.')]
    #[Assert\Type("\DateTimeInterface")]
    #[Assert\GreaterThanOrEqual("today", message: "La date de début ne peut pas être dans le passé.")]
    private ?DateTimeInterface $dateDebut = null;

    #[ORM\Column(type: Types::DATETIME_MUTABLE)] // Added dateFin
    #[Assert\NotNull(message: 'La date de fin de réservation est obligatoire.')]
    #[Assert\Type("\DateTimeInterface")]
    #[Assert\GreaterThan(propertyPath: "dateDebut", message: "La date de fin doit être postérieure à la date de début.")]
    private ?DateTimeInterface $dateFin = null;

    #[ORM\Column(type: Types::DECIMAL, precision: 10, scale: 2)] // Use scale 2 for currency
    #[Assert\NotBlank(message: 'Le montant est requis.')]
    #[Assert\PositiveOrZero(message: 'Le montant doit être positif ou nul.')] // Changed to PositiveOrZero
    private ?string $montant = null;

    #[ORM\Column(type: Types::STRING, enumType: ReservationStatus::class)]
    #[Assert\NotNull(message: 'Le statut est requis.')]
    private ?ReservationStatus $status = ReservationStatus::PENDING; // Default

    #[ORM\Column(type: Types::STRING, enumType: Paiement::class)]
    #[Assert\NotNull(message: 'Le mode de paiement est requis.')]
    private ?Paiement $paiement = null;

    #[ORM\Column(type: Types::DATETIME_MUTABLE)] // Added dateCreation
    private ?DateTimeInterface $dateCreation;

    public function __construct()
    {
        $this->dateCreation = new \DateTime(); // Set dateCreation
    }

    // Getters & Setters (Standard for all properties)
    public function getId(): ?int { return $this->id; }
    public function getUtilisateur(): ?Utilisateur { return $this->utilisateur; }
    public function setUtilisateur(?Utilisateur $utilisateur): static { $this->utilisateur = $utilisateur; return $this; }
    public function getTrottinette(): ?Trottinette { return $this->trottinette; }
    public function setTrottinette(?Trottinette $trottinette): static { $this->trottinette = $trottinette; return $this; }
    public function getDateDebut(): ?DateTimeInterface { return $this->dateDebut; }
    public function setDateDebut(?DateTimeInterface $dateDebut): static { $this->dateDebut = $dateDebut; return $this; }
    public function getDateFin(): ?DateTimeInterface { return $this->dateFin; }
    public function setDateFin(?DateTimeInterface $dateFin): static { $this->dateFin = $dateFin; return $this; }
    public function getMontant(): ?string { return $this->montant; }
    public function setMontant(?string $montant): static { $this->montant = $montant; return $this; }
    public function getStatus(): ?ReservationStatus { return $this->status; }
    public function setStatus(?ReservationStatus $status): self { $this->status = $status; return $this; }
    public function getPaiement(): ?Paiement { return $this->paiement; }
    public function setPaiement(?Paiement $paiement): self { $this->paiement = $paiement; return $this; }
    public function getDateCreation(): ?DateTimeInterface { return $this->dateCreation; }
    public function setDateCreation(DateTimeInterface $dateCreation): static { $this->dateCreation = $dateCreation; return $this; }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/ResetPasswordRequest.php -----
<?php
// src/Entity/ResetPasswordRequest.php
namespace App\Entity;

use App\Repository\ResetPasswordRequestRepository; // Make sure namespace is correct
use Doctrine\ORM\Mapping as ORM;
use SymfonyCasts\Bundle\ResetPassword\Model\ResetPasswordRequestInterface;
use SymfonyCasts\Bundle\ResetPassword\Model\ResetPasswordRequestTrait;
use Symfony\Component\Security\Core\User\UserInterface; // Use the interface

#[ORM\Entity(repositoryClass: ResetPasswordRequestRepository::class)]
class ResetPasswordRequest implements ResetPasswordRequestInterface
{
    // Add the trait provided by the bundle
    use ResetPasswordRequestTrait;

    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    // Define the relationship to your User entity
    #[ORM\ManyToOne(targetEntity: Utilisateur::class)] // Use YOUR User entity class here (Utilisateur seems correct based on your files)
    #[ORM\JoinColumn(nullable: false)]
    private object $user; // Store the User object

    // Constructor required by the trait and repository
    public function __construct(object $user, \DateTimeInterface $expiresAt, string $selector, string $hashedToken)
    {
        // Ensure the user is compatible before setting
        if (!$user instanceof UserInterface) {
            throw new \InvalidArgumentException(sprintf('The first argument of %s() must be an instance of %s, "%s" given.', __METHOD__, UserInterface::class, get_debug_type($user)));
        }
        $this->user = $user;
        $this->initialize($expiresAt, $selector, $hashedToken); // Call the trait's initializer
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getUser(): object // Return type matches property
    {
        return $this->user;
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Trottinette.php -----
<?php

namespace App\Entity;

use App\Repository\TrottinetteRepository;
use Doctrine\ORM\Mapping as ORM;
use DateTime;
use App\Enum\TrottinetteStatus;
use Symfony\Component\Validator\Constraints as Assert;
use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;

#[ORM\Entity(repositoryClass: TrottinetteRepository::class)]
#[ORM\Table(name: 'trottinette')]
#[UniqueEntity(fields: ['numeroSerie'], message: 'Ce numéro de série est déjà utilisé par une autre trottinette.')]
class Trottinette
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\ManyToOne(targetEntity: Utilisateur::class)]
    #[ORM\JoinColumn(name: 'idUser', referencedColumnName: 'id')]
    #[Assert\Valid]
    private ?Utilisateur $utilisateur = null;

    #[ORM\Column(name: 'modele', length: 100, nullable: true)]
    #[Assert\NotBlank(message: 'Le modèle est obligatoire')]
    #[Assert\Length(
        min: 2,
        max: 100,
        minMessage: 'Le modèle doit contenir au moins {{ limit }} caractères',
        maxMessage: 'Le modèle ne peut pas dépasser {{ limit }} caractères.'
    )]
    #[Assert\Regex(
        pattern: '/^[A-Za-z0-9\s\-\.]+$/',
        message: 'Le modèle ne peut contenir que des lettres, des chiffres, des espaces, des points et des tirets.'
    )]
    private ?string $modele = null;

    #[ORM\Column(name: 'numeroSerie', length: 100, nullable: true)]
    #[Assert\NotBlank(message: 'Le numéro de série est obligatoire')]
    #[Assert\Length(
        min: 4,
        max: 100,
        minMessage: 'Le numéro de série doit contenir au moins {{ limit }} caractères',
        maxMessage: 'Le numéro de série ne peut pas dépasser {{ limit }} caractères.'
    )]
    #[Assert\Regex(
        pattern: '/^[A-Za-z0-9\-]+$/',
        message: 'Le numéro de série ne peut contenir que des lettres, des chiffres et des tirets'
    )]
    private ?string $numeroSerie = null;

    #[ORM\Column(name: 'etat', type: 'string', enumType: TrottinetteStatus::class)]
    #[Assert\NotBlank(message: 'L\'état est obligatoire')]
    private TrottinetteStatus $etat = TrottinetteStatus::DISPONIBLE;

    #[ORM\Column(name: 'batterie', nullable: true)]
    #[Assert\NotBlank(message: 'batterie est obligatoire')]
    #[Assert\Type(
        type: 'integer',
        message: 'La valeur {{ value }} n\'est pas un nombre entier valide.'
    )]
    #[Assert\Range(
        min: 0,
        max: 100,
        notInRangeMessage: 'La batterie doit être comprise entre {{ min }}% et {{ max }}%'
    )]
    private ?int $batterie = null;

    #[ORM\Column(name: 'localisation', length: 100, nullable: true)]
    #[Assert\NotBlank(message: 'La localisation est obligatoire')]
    #[Assert\Length(
        max: 100,
        maxMessage: 'La localisation ne peut pas dépasser {{ limit }} caractères.'
    )]
    private ?string $localisation = null;

    #[ORM\Column(name: 'dateAjout', type: 'datetime', nullable: true)]
    #[Assert\Type("\DateTime", message: 'La valeur {{ value }} n\'est pas une date valide.')]
    #[Assert\LessThanOrEqual('now', message: 'La date d\'ajout ne peut pas être dans le futur.')]
    private ?DateTime $dateAjout = null;

    #[ORM\ManyToOne(targetEntity: PointRelais::class)]
    #[ORM\JoinColumn(name: 'pointRelaisId', referencedColumnName: 'id', nullable: true)]  // Define the foreign key
    private ?PointRelais $pointRelais = null;


    #[ORM\Column(name: 'autonomie', length: 45, nullable: true)]
    #[Assert\NotBlank(message: 'L\'autonomie est obligatoire')]
    #[Assert\Length(
        max: 45,
        maxMessage: 'L\'autonomie ne peut pas dépasser {{ limit }} caractères.'
    )]
    #[Assert\Regex(
        pattern: '/^\d+\s*(km|heures?)$/i',
        message: 'Le format d\'autonomie doit être comme "25 km" ou "2 heures"'
    )]
    private ?string $autonomie = null;

    #[Assert\Callback]
    public function validateBatteryAndAutonomy($context)
    {
        if ($this->batterie !== null && $this->batterie < 10 && $this->etat === TrottinetteStatus::DISPONIBLE) {
            $context->buildViolation('Une trottinette disponible doit avoir au moins 10% de batterie.')
                ->atPath('batterie')
                ->addViolation();
        }

        if ($this->etat === TrottinetteStatus::EN_MAINTENANCE && $this->batterie > 95) {
            $context->buildViolation('Une trottinette en maintenance ne devrait pas avoir une batterie presque pleine.')
                ->atPath('batterie')
                ->addViolation();
        }
    }

    // ======== GETTERS & SETTERS ========

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getUtilisateur(): ?Utilisateur
    {
        return $this->utilisateur;
    }

    public function setUtilisateur(?Utilisateur $utilisateur): self
    {
        $this->utilisateur = $utilisateur;
        return $this;
    }

    public function getModele(): ?string
    {
        return $this->modele;
    }

    public function setModele(?string $modele): self
    {
        $this->modele = $modele;
        return $this;
    }

    public function getNumeroSerie(): ?string
    {
        return $this->numeroSerie;
    }

    public function setNumeroSerie(?string $numeroSerie): self
    {
        $this->numeroSerie = $numeroSerie;
        return $this;
    }

    public function getEtat(): TrottinetteStatus
    {
        return $this->etat;
    }

    public function setEtat($etat): self
    {
        if (is_string($etat)) {
            $this->etat = TrottinetteStatus::from($etat);
        } else {
            $this->etat = $etat;
        }
        return $this;
    }

    public function getBatterie(): ?int
    {
        return $this->batterie;
    }

    public function setBatterie(?int $batterie): self
    {
        $this->batterie = $batterie;
        return $this;
    }

    public function getLocalisation(): ?string
    {
        return $this->localisation;
    }

    public function setLocalisation(?string $localisation): self
    {
        $this->localisation = $localisation;
        return $this;
    }

    public function getDateAjout(): ?DateTime
    {
        return $this->dateAjout;
    }

    public function setDateAjout(?DateTime $dateAjout): self
    {
        $this->dateAjout = $dateAjout;
        return $this;
    }

    public function getPointRelais(): ?PointRelais
    {
        return $this->pointRelais;
    }

    public function setPointRelais(?PointRelais $pointRelais): self
    {
        $this->pointRelais = $pointRelais;
        return $this;
    }


    public function getAutonomie(): ?string
    {
        return $this->autonomie;
    }

    public function setAutonomie(?string $autonomie): self
    {
        $this->autonomie = $autonomie;
        return $this;
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Reclamation.php -----
<?php
// src/Entity/Reclamation.php

namespace App\Entity;

use App\Repository\ReclamationRepository;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Validator\Constraints as Assert;

#[ORM\Entity(repositoryClass: ReclamationRepository::class)]
class Reclamation
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private ?int $id = null;

    #[ORM\Column(type: 'string', length: 255)]
    #[Assert\NotBlank(message: 'Le titre ne peut pas être vide')]
    #[Assert\Length(max: 255, maxMessage: 'Le titre ne peut pas dépasser 255 caractères')]
    #[Assert\Regex(
        pattern: '/^[a-zA-Z\s&]+$/u',
        message: 'Le titre ne doit contenir que des lettres, espaces et le caractère "&"'
    )]
    private string $titre;

    #[ORM\Column(type: 'text')]
    #[Assert\NotBlank(message: 'La description ne peut pas être vide')]
    private string $description;

    #[ORM\Column(type: 'datetime')]
    private \DateTimeInterface $date_creation;

    #[ORM\Column(type: 'string', length: 255)]
    #[Assert\NotBlank(message: 'Le type de réclamation est requis')]
    private string $type_reclamation;

    #[ORM\Column(type: 'string', length: 255)]
    #[Assert\NotBlank(message: 'L\'email de l\'utilisateur est requis')]
    #[Assert\Email(message: 'L\'email "{{ value }}" n\'est pas un email valide')]
    private string $user_email;

    #[ORM\Column(type: 'integer')]
    #[Assert\NotBlank(message: 'L\'ID de la trottinette est requis')]
    #[Assert\Positive(message: 'L\'ID de la trottinette doit être un nombre strictement positif')]
    private int $id_trottinette;

    #[ORM\OneToMany(mappedBy: 'reclamation', targetEntity: Reponse::class, cascade: ['persist', 'remove'])]
    private Collection $reponses;

    public function __construct()
    {
        $this->reponses = new ArrayCollection();
        $this->date_creation = new \DateTime();  // Date actuelle par défaut
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getTitre(): ?string
    {
        return $this->titre;
    }

    public function setTitre(string $titre): self
    {
        $this->titre = $titre;
        return $this;
    }

    public function getDescription(): ?string
    {
        return $this->description;
    }

    public function setDescription(string $description): self
    {
        $this->description = $description;
        return $this;
    }

    public function getDateCreation(): ?\DateTimeInterface
    {
        return $this->date_creation;
    }

    public function setDateCreation(\DateTimeInterface $date_creation): self
    {
        $this->date_creation = $date_creation;
        return $this;
    }

    public function getTypeReclamation(): ?string
    {
        return $this->type_reclamation;
    }

    public function setTypeReclamation(string $type_reclamation): self
    {
        $this->type_reclamation = $type_reclamation;
        return $this;
    }

    public function getUserEmail(): ?string
    {
        return $this->user_email;
    }

    public function setUserEmail(string $user_email): self
    {
        $this->user_email = $user_email;
        return $this;
    }

    public function getIdTrottinette(): ?int
    {
        return $this->id_trottinette;
    }

    public function setIdTrottinette(int $id_trottinette): self
    {
        $this->id_trottinette = $id_trottinette;
        return $this;
    }

    public function getReponses(): Collection
    {
        return $this->reponses;
    }

    public function addReponse(Reponse $reponse): self
    {
        if (!$this->reponses->contains($reponse)) {
            $this->reponses[] = $reponse;
            $reponse->setReclamation($this);
        }
        return $this;
    }

    public function removeReponse(Reponse $reponse): self
    {
        if ($this->reponses->removeElement($reponse)) {
            if ($reponse->getReclamation() === $this) {
                $reponse->setReclamation(null);
            }
        }
        return $this;
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Enum/ParticipationStatus.php -----
<?php

namespace App\Enum;

enum ParticipationStatus: string
{
    case INSCRIT = 'INSCRIT';
    case ANNULE = 'ANNULE';
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Enum/GouvernoratEnum.php -----
<?php

namespace App\Enum;

enum GouvernoratEnum: string
{
    case ARIANA = 'Ariana';
    case BEJA = 'Béja';
    case BEN_AROUS = 'Ben Arous';
    case BIZERTE = 'Bizerte';
    case GABES = 'Gabès';
    case GAFSA = 'Gafsa';
    case JENDOUBA = 'Jendouba';
    case KAIROUAN = 'Kairouan';
    case KASSERINE = 'Kasserine';
    case KEBILI = 'Kébili';
    case KEF = 'Le Kef';
    case MAHDIA = 'Mahdia';
    case MANOUBA = 'La Manouba';
    case MEDENINE = 'Médenine';
    case MONASTIR = 'Monastir';
    case NABEUL = 'Nabeul';
    case SFAX = 'Sfax';
    case SIDI_BOUZID = 'Sidi Bouzid';
    case SILIANA = 'Siliana';
    case SOUSSE = 'Sousse';
    case TATAOUINE = 'Tataouine';
    case TOZEUR = 'Tozeur';
    case TUNIS = 'Tunis';
    case ZAGHOUAN = 'Zaghouan';
    
    /**
     * Returns all available choices as an array
     * @return array<string, string>
     */
    public static function getChoicesForForm(): array
    {
        $choices = [];
        foreach (self::cases() as $case) {
            $choices[$case->value] = $case->name;
        }
        return $choices;
    }


    
    /**
     * Returns the string representation of this enum (its value)
     * @return string
     */
    public function toString(): string
    {

        return $this->value;
    }

    /**
     * Retourne une étiquette lisible (label) pour chaque case.
     */
    public function label(): string
    {

        return match ($this) {
            self::ARIANA => 'Ariana',
            self::BEJA => 'Béja',
            self::BEN_AROUS => 'Ben Arous',
            self::BIZERTE => 'Bizerte',
            self::GABES => 'Gabès',
            self::GAFSA => 'Gafsa',
            self::JENDOUBA => 'Jendouba',
            self::KAIROUAN => 'Kairouan',
            self::KASSERINE => 'Kasserine',
            self::KEBILI => 'Kébili',
            self::KEF => 'Le Kef',
            self::MAHDIA => 'Mahdia',
            self::MANOUBA => 'La Manouba',
            self::MEDENINE => 'Médenine',
            self::MONASTIR => 'Monastir',
            self::NABEUL => 'Nabeul',
            self::SFAX => 'Sfax',
            self::SIDI_BOUZID => 'Sidi Bouzid',
            self::SILIANA => 'Siliana',
            self::SOUSSE => 'Sousse',
            self::TATAOUINE => 'Tataouine',
            self::TOZEUR => 'Tozeur',
            self::TUNIS => 'Tunis',
            self::ZAGHOUAN => 'Zaghouan',
        };
    }



}


----- /Users/mac/Downloads/my_project_troti-vf/src/Enum/ReservationStatus.php -----
<?php

namespace App\Enum;

enum ReservationStatus: string
{
    case PENDING = 'pending';
    case CONFIRMED = 'confirmed';
    case CANCELLED = 'cancelled';

    public function label(): string
    {
        return match($this) {
            self::PENDING => 'Pending',
            self::CONFIRMED => 'Confirmed',
            self::CANCELLED => 'Cancelled',
        };
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Enum/TrottinetteStatus.php -----
<?php

namespace App\Enum;

enum TrottinetteStatus: string
{
    case DISPONIBLE = 'DISPONIBLE';
    case EN_LOCATION = 'EN_LOCATION';
    case EN_MAINTENANCE = 'EN_MAINTENANCE';

    public function toString(): string
    {
        return match($this) {
            self::DISPONIBLE => 'Disponible',
            self::EN_LOCATION => 'En Location',
            self::EN_MAINTENANCE => 'En Maintenance'
        };
    }
    /**
     * Provides a user-friendly label for each status.
     */
    public function label(): string // Renamed from toString for clarity, can keep toString if preferred
    {
        return match($this) {
            self::DISPONIBLE => 'Disponible',
            self::EN_LOCATION => 'En Location',
            self::EN_MAINTENANCE => 'En Maintenance'
        };
    }
    /**
     * Returns an array suitable for Symfony Form ChoiceType choices.
     * Format: ['Label visible to user' => 'Database/Enum Value', ...]
     *
     * @return array<string, string>
     */
    public static function choicesForForm(): array
    {
        $choices = [];
        foreach (self::cases() as $case) {
            // Use the label() method for the user-visible key
            // Use the enum's value for the actual submitted value
            $choices[$case->label()] = $case->value;
        }
        return $choices;

        /* Example output:
         * [
         *   'Disponible' => 'DISPONIBLE',
         *   'En Location' => 'EN_LOCATION',
         *   'En Maintenance' => 'EN_MAINTENANCE',
         * ]
         */
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Enum/Paiement.php -----
<?php
namespace App\Enum;

enum Paiement: string
{
    case CARTE = 'carte';
    case CHEQUE = 'cheque';
    case ESPECE = 'espece';

    public function label(): string
    {
        return match($this) {
            self::CARTE => 'Carte bancaire',
            self::CHEQUE => 'Chèque',
            self::ESPECE => 'Espèce',
        };
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Enum/MaintenanceStatus.php -----
<?php

namespace App\Enum;

enum MaintenanceStatus: string
{
    case EN_COURS = 'EN_COURS';
    case TERMINE = 'TERMINE';
    case TERMINEE = 'TERMINEE';
    case ANNULEE = 'ANNULEE';


}


----- /Users/mac/Downloads/my_project_troti-vf/src/Enum/MaintenanceType.php -----
<?php

namespace App\Enum;

enum MaintenanceType: string
{
    const REPARATION = 'REPARATION';
    const ENTRETIEN = 'ENTRETIEN';
    const VERIFICATION = 'VERIFICATION';
    const AUTRE = 'AUTRE';


}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/HomeController.php -----
<?php
// src/Controller/HomeController.php

namespace App\Controller;

use App\Repository\EventRepository;
use App\Repository\TrottinetteRepository;
use Psr\Log\LoggerInterface; // Import Logger
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route; // Use Attribute instead if using PHP 8+

// Using #[Route] attribute for the route definition
class HomeController extends AbstractController
{
    private LoggerInterface $logger;

    // Inject repositories and logger via constructor
    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    #[Route('/', name: 'app_home', methods: ['GET'])] // Define the route here
    public function index(
        TrottinetteRepository $trottinetteRepository,
        EventRepository $eventRepository
    ): Response {
        $this->logger->info('HomeController::index processing started.');

        $scootersForView = [];
        $eventsForView = [];

        try {

            // Fetch available scooters (e.g., limit to 4 for homepage)
            $availableScooters = $trottinetteRepository->findBy([], ['dateAjout' => 'DESC'], 4);

            $this->logger->info(sprintf('Fetched %d available scooters.', count($availableScooters)));

            // Fetch upcoming events (e.g., limit to 3 for homepage)
            if (method_exists($eventRepository, 'findUpcomingEvents')) {
                $upcomingEvents = $eventRepository->findUpcomingEvents();

            } else {
                $this->logger->warning('Method findUpcomingEvents not found in EventRepository.');
                $upcomingEvents = $eventRepository->findBy([], ['dateDebut' => 'ASC'], 3);
            }
            $this->logger->info(sprintf('Fetched %d upcoming events.', count($upcomingEvents)));

            // --- Prepare Scooter Card Data ---
            foreach ($availableScooters as $scooter) {
                $scootersForView[] = [
                    'entity' => $scooter,
                    'distanceString' => "Adresse: " . ($scooter->getLocalisation() ?: 'Inconnue'), // Placeholder
                    'pricePerMinute' => "0.15 TND/min", // Placeholder
                    'image_url' => null // Add logic if needed
                ];
            }

            // --- Prepare Event Card Data ---
            foreach ($upcomingEvents as $event) {
                $eventsForView[] = [
                    'entity' => $event,
                    // Use state (Gouvernorat) for location if available
                    'location' => $event->getState()?->label() ?? 'Lieu à définir'
                ];
            }

        } catch (\Exception $e) {
            $this->logger->error('Error preparing homepage data: ' . $e->getMessage(), ['exception' => $e]);
            $this->addFlash('error', 'Une erreur est survenue lors du chargement des données.');
            // Keep arrays empty on error
            $scootersForView = [];
            $eventsForView = [];
        }

        // --- Prepare Context for Rendering ---
        $context = [
            'scooters' => $scootersForView,         // Pass the prepared array for scooters
            'upcoming_events' => $eventsForView,    // Pass the prepared array for events
            'heroTitle' => 'Découvrez la ville autrement',
            'heroSubtitle' => 'Louez nos trottinettes électriques facilement. Disponibles 24/7, écologiques et fun !',
        ];

        $this->logger->debug('Rendering home/index.html.twig with keys: ' . implode(', ', array_keys($context)));

        // Render the specific template 'home/index.html.twig'
        return $this->render('home/index.html.twig', $context);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/SecurityController.php -----
<?php
// src/Controller/SecurityController.php

namespace App\Controller;

use App\Entity\Utilisateur;
use App\Repository\UtilisateurRepository; // Use the specific Repository
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\RedirectResponse; // For redirects
use Symfony\Component\HttpFoundation\Session\SessionInterface;
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface; // Needed for manual token setting
use Symfony\Component\Security\Core\Authentication\Token\UsernamePasswordToken; // Needed for manual token creation
use Symfony\Component\Security\Csrf\CsrfToken; // Needed for CSRF check
use Symfony\Component\Security\Csrf\CsrfTokenManagerInterface; // Needed for CSRF check
use Symfony\Component\Security\Http\SecurityRequestAttributes; // For LAST_USERNAME constant

class SecurityController extends AbstractController
{
    // =========================================================================
    // == MANUAL AUTHENTICATION IMPLEMENTATION (REVISED & CORRECTED)        ==
    // =========================================================================
    // == WARNING: This implements login/logout manually. While corrected to ==
    // == integrate with Symfony's session context for authorization        ==
    // == (#[IsGranted], access_control), it bypasses standard authenticators.==
    // == Ensure thorough testing and understanding.                          ==
    // =========================================================================

    #[Route('/connexion', name: 'app_login', methods: ['GET', 'POST'])]
    public function login(
        Request $request,
        UtilisateurRepository $userRepository, // Use specific repository
        UserPasswordHasherInterface $passwordHasher,
        CsrfTokenManagerInterface $csrfTokenManager,
        TokenStorageInterface $tokenStorage,
        SessionInterface $session
    ): Response {
        // --- Redirect if already logged in ---
        // Check if a security token exists AND represents an authenticated user
        if ($session->has('_security_main') && $tokenStorage->getToken()?->getUser() instanceof Utilisateur) {
            $roles = $tokenStorage->getToken()->getRoleNames(); // Get roles from the active token
            if (in_array('ROLE_ADMIN', $roles, true)) {
                return $this->redirectToRoute('admin_dashboard'); // Use your actual route names
            }
            if (in_array('ROLE_PARTENAIRE', $roles, true)) {
                return $this->redirectToRoute('app_partenaire_dashboard'); // Use your actual route names
            }
            if (in_array('ROLE_CLIENT', $roles, true)) {
                return $this->redirectToRoute('client_dashboard'); // Use your actual route names
            }
            // Fallback if roles don't match expected dashboards
            return $this->redirectToRoute('app_home');
        }

        $error = null;
        // Get last username entered (if any) for pre-filling the form
        $lastUsername = $request->getSession()->get(SecurityRequestAttributes::LAST_USERNAME);

        if ($request->isMethod('POST')) {
            $email = $request->request->get('email'); // Use '_username' as standard convention
            $password = $request->request->get('password'); // Use '_password' as standard convention
            $csrfToken = $request->request->get('_csrf_token');

            // Store the submitted email in the session for pre-filling if login fails
            $request->getSession()->set(SecurityRequestAttributes::LAST_USERNAME, $email);

            // 1. CSRF Validation (CRITICAL for security)
            $token = new CsrfToken('authenticate', $csrfToken);


            // 2. Find User by Email
            $user = $userRepository->findOneBy(['email' => $email]);
// **New**: Block if not active
            if ($user && !$user->isActive()) {
                $this->addFlash('error', 'Votre compte a été désactivé. Contactez un administrateur.');
                return $this->render('security/login.html.twig', [
                    'last_username' => $email,
                    'error'         => 'Votre compte est désactivé.',
                ]);
            }

            // 3. Validate User and Password
            if (!$user || !$passwordHasher->isPasswordValid($user, $password)) {
                $this->addFlash('error', 'Identifiants invalides.');
                // Render the login form again
                return $this->render('security/login.html.twig', [
                    'last_username' => $email,
                    'error' => 'Identifiants invalides.',
                ]);
            }

            // --- If validation passes: MANUAL SESSION START & TOKEN CREATION ---

            // 4. Create the Security Token
            // 'main' MUST match the firewall name in security.yaml
            $securityToken = new UsernamePasswordToken($user, 'main', $user->getRoles());

            // 5. Manually set the token in the Token Storage for the current request
            $tokenStorage->setToken($securityToken);

            // 6. Manually store the token in the session for subsequent requests.
            // This is the key part for making #[IsGranted], access_control, etc., work.
            // Symfony's ContextListener should pick this up. Use the conventional key.
            $session->set('_security_main', serialize($securityToken));

            // 7. Regenerate session ID to prevent session fixation attacks
            $session->migrate(true);

            // 8. Clear the last username from session after successful login
            $request->getSession()->remove(SecurityRequestAttributes::LAST_USERNAME);

            $this->addFlash('success', 'Connexion réussie ! Bienvenue ' . $user->getPrenom() . '.');

            // 9. Redirect based on role
            $roles = $user->getRoles(); // Use roles from the user entity
            if (in_array('ROLE_ADMIN', $roles, true)) {
                return $this->redirectToRoute('admin_dashboard'); // Use your actual route names
            } elseif (in_array('ROLE_PARTENAIRE', $roles, true)) {
                return $this->redirectToRoute('app_partenaire_dashboard'); // Use your actual route names
            } else { // Default for ROLE_CLIENT or ROLE_USER
                return $this->redirectToRoute('client_dashboard'); // Use your actual route names
            }
        }

        // --- Render the login form on GET request or if POST validation failed before step 4 ---
        // Check for authentication errors stored by previous attempts (e.g., if using firewall exceptions)
        // Note: With this fully manual approach, direct errors are less common here unless
        // you explicitly throw Symfony security exceptions. Flash messages are primary.
        // $authError = $request->getSession()->get(SecurityRequestAttributes::AUTHENTICATION_ERROR);
        // if ($authError) {
        //     $error = $authError->getMessageKey(); // Or getMessage()
        //     $request->getSession()->remove(SecurityRequestAttributes::AUTHENTICATION_ERROR); // Clear error
        //     $this->addFlash('error', $error); // Add as flash message
        // }


        return $this->render('security/login.html.twig', [
            'last_username' => $lastUsername,
            'error' => $error, // Pass any direct error message (though flash is preferred)
        ]);
    }

    #[Route('/deconnexion', name: 'app_logout', methods: ['GET'])]
    public function logout(
        Request $request, // Request might be needed if clearing cookies etc.
        TokenStorageInterface $tokenStorage,
        SessionInterface $session
    ): Response {
        // MANUAL LOGOUT IMPLEMENTATION

        // 1. Clear the security token from token storage for the current request
        $tokenStorage->setToken(null);

        // 2. Remove the security token from the session storage
        $session->remove('_security_main');

        // 3. Invalidate the entire session and regenerate CSRF token
        // This clears all session data and generates a new session ID.
        $session->invalidate();

        $this->addFlash('success', 'Vous avez été déconnecté.');

        // Redirect to homepage or login page
        return $this->redirectToRoute('app_home');

        // NOTE: Symfony's security.yaml 'logout' path configuration is NOT used here.
        // The route '/deconnexion' directly triggers this manual logout action.
        // Throwing an exception here is unnecessary and typically not done for logout.
        // throw new \LogicException('This method should not be reached!');
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/ParticipationController.php -----
<?php
// src/Controller/ParticipationController.php
namespace App\Controller;

use App\Entity\Participation;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Symfony\Component\Routing\Annotation\Route;

class ParticipationController extends AbstractController
{
    #[Route('/participation/{id}/details', name: 'participation_details', requirements: ['id' => '\d+'], methods: ['GET'])]
    public function showDetails(Participation $participation): Response
    {
        // ParamConverter automatically fetches the Participation by ID.
        // If not found, it throws a 404 exception.

        $event = $participation->getEvent();
        $user = $participation->getUtilisateur();

        if (!$event || !$user) {
            // This should ideally not happen if data integrity is maintained
            throw new NotFoundHttpException('Données associées à la participation introuvables.');
        }

        return $this->render('participation/details.html.twig', [
            'participation' => $participation,
            'event' => $event,
            'user' => $user,
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/TrottinetteController.php -----
<?php

namespace App\Controller;

use App\Entity\Trottinette;
use App\Entity\Utilisateur;
use App\Form\TrottinetteType;
use App\Repository\TrottinetteRepository;
use App\Repository\UtilisateurRepository;
use App\Service\DataFixturesService;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Form\FormError;

#[Route('/trottinette')]
class TrottinetteController extends AbstractController
{
   
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/EventController.php -----
<?php

namespace App\Controller;

use App\Entity\Event;
use App\Entity\Participation;
use App\Entity\Utilisateur;
use App\Enum\ParticipationStatus;
use App\Form\EventType;
use App\Repository\EventRepository;
use App\Repository\ParticipationRepository; // Make sure this is injected
use App\Repository\UtilisateurRepository;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Mailer\Exception\TransportExceptionInterface;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\HttpFoundation\RedirectResponse; // Added for redirects
use Symfony\Component\Mailer\MailerInterface;        // ← import this
use Symfony\Component\Mime\Email;                    // ← and this
use Symfony\Contracts\HttpClient\HttpClientInterface;

#[Route('/event')]
class EventController extends AbstractController
{
    // Inject ParticipationRepository in the constructor if it's used in multiple methods often
    private ParticipationRepository $participationRepository;
    private EntityManagerInterface $entityManager;
    private HttpClientInterface $client;

    public function __construct(ParticipationRepository $participationRepository, EntityManagerInterface $entityManager,HttpClientInterface $client)
    {
        $this->participationRepository = $participationRepository;
        $this->entityManager = $entityManager;
        $this->client = $client;

    }

    #[Route('/', name: 'app_event_index', methods: ['GET'])]
    public function index(EventRepository $eventRepository): Response
    {
        // Consider showing upcoming events by default for a better user experience
        return $this->render('event/index.html.twig', [
            'events' => $eventRepository->findUpcomingEvents(), // Or findAll() if intended
        ]);
    }

    #[Route('/new', name: 'app_event_new', methods: ['GET', 'POST'])]
    public function new(Request $request): Response // EntityManager injected via constructor
    {
        $event = new Event();
        // $event->setStatut('active'); // This 'active' status seems incorrect based on the entity enum/choices ('A_VENIR', etc.)
        $event->setStatut('A_VENIR'); // Set a valid default status

        $form = $this->createForm(EventType::class, $event);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->persist($event);
            $this->entityManager->flush();
            $this->addFlash('success', 'Événement créé avec succès.');
            return $this->redirectToRoute('app_event_index');
        }

        return $this->render('event/new.html.twig', [
            'event' => $event,
            'form' => $form->createView(), // Pass form view
        ]);
    }

    #[Route('/{id}/participate', name: 'app_event_participate', methods: ['POST'])]
    public function participate(Request $request, Event $event, UtilisateurRepository $utilisateurRepository,

                                MailerInterface $mailer        // ← inject it here

    ): Response // EntityManager injected via constructor
    {

        // WARNING: No security check! Relies on getUser() or fallback.
        $user = $this->getUser();
        if (!$user) {
            // Using the fallback test user logic from your original code
            $user = $utilisateurRepository->findOneBy(['email' => 'test@example.com']);
            if (!$user) {
                // Create a default test user for participation testing
                $user = new Utilisateur();
                $user->setEmail('test@example.com');
                $user->setNom('Test');
                $user->setPrenom('User');
                // Note: Password hashing should ideally use the PasswordHasher service
                $user->setPassword(password_hash('test1234', PASSWORD_DEFAULT)); // Use default hash
                $user->setRoleInterne('client'); // Use setRoleInterne
                $user->setTelephone('0123456789'); // Required field in database
                $user->setIsVerified(true); // Assume verified for test
                $this->entityManager->persist($user);
                $this->entityManager->flush();
            }
        }
         $email = (new Email())
            ->from('aymen.labidi@esprit.tn')
            ->to('aymenlabidi21@gmail.com')
            ->subject('Hello via SMTP!')
            ->text('This email was sent over SMTP using Symfony Mailer.')
            ->html('<p>This email was sent over <strong>SMTP</strong> using Symfony Mailer.</p>');
        $dateDebut = $event->getDateDebut()->format('d/m/Y \à H\hi'); // e.g. "27/04/2025 à 14h30"
        $dateFin   = $event->getDateFin()  ->format('d/m/Y \à H\hi'); // e.g. "27/04/2025 à 16h00"

        $url = 'https://hook.eu1.make.com/36nvslbc06ues77g2f69w5nloy1ra98j';

                            $body = <<<EOT
                    Bonjour,</br>
                    
                    Félicitations ! Vous êtes inscrit(e) à l'événement "{$event->getTitre()}". ✅</br>
                    
                    📅 Date : {$dateDebut} - {$dateFin}</br>
                    📍 Lieu : {$event->getLieuValue()} ({$event->getState()->label()})</br>
                    ⚡ Autonomie minimale requise pour les trottinettes : {$event->getTrottinetteMinAutonomie()} km</br>
                    
                    🎫 Présentez ce mail comme preuve de votre inscription.</br>
                    
                    À très bientôt ! 🚀
                    EOT;
        $payload = [
            'email' => $user->getEmail(),
            'body'  => $body,
            'title' => "Confirmation de participation à 'événement",
        ];
        $headers = [
            'Content-Type' => 'application/json',
            'Cookie'       => '__cf_bm=hfXrt7n0TJKswki1VkcZXgyCGyrUOG7LcPSmsuwLAUQ-1745745305-1.0.1.1-N9CHYn3bbnDqxifvbWFL9WPEDH1DMGIol16jHCmyIGxdm1RMOXrxAOUN4k6iNJtOlX35E0QzCR8t.BZudJltHyTg0nWihxkmMK5TL2.ia28',
        ];

        $response = $this->client->request('POST', $url, [
            'headers' => $headers,
            'json'    => $payload,
        ]);

        // get status and body if you want
        $status  = $response->getStatusCode();
        $content = $response->getContent(false);


        try {

            $mailer->send($email);
            $this->addFlash('success', 'Email envoyé !');



        } catch (TransportExceptionInterface $e) {
            // SMTP refused it, DNS failure, auth error, etc.
            $this->addFlash('error', 'L’email n’a pas pu être envoyé : '.$e->getMessage());

            // In dev, you might re-throw to see the full trace
            if ($this->getParameter('kernel.debug')) {
                throw $e;
            }
        }


        // Check if user already actively registered
        $activeParticipation = $this->participationRepository->findOneBy([
            'event' => $event,
            'utilisateur' => $user,
            'statut' => ParticipationStatus::INSCRIT
        ]);

        if ($activeParticipation) {
            $this->addFlash('warning', 'Vous êtes déjà inscrit à cet événement.');
            return $this->redirectToRoute('app_event_show', ['id' => $event->getId()]);
        }

        // Check if user has a cancelled registration for this event
        $cancelledParticipation = $this->participationRepository->findOneBy([
            'event' => $event,
            'utilisateur' => $user,
            'statut' => ParticipationStatus::ANNULE
        ]);

        if ($cancelledParticipation) {
            // Reactivate the cancelled participation
            $cancelledParticipation->setStatut(ParticipationStatus::INSCRIT);
            $cancelledParticipation->setDateInscription(new \DateTime()); // Update inscription date
            $this->entityManager->persist($cancelledParticipation);
            $this->addFlash('success', 'Votre inscription a été réactivée !');
        } else {
            // Create a new participation if none exists (active or cancelled)
            $participation = new Participation();
            // WARNING: Using potentially non-unique ID. Database composite key (eventId, userId) is preferred.
            $participation->setEvent($event);
            $participation->setUtilisateur($user);
            $participation->setDateInscription(new \DateTime());
            $participation->setStatut(ParticipationStatus::INSCRIT);
            $this->entityManager->persist($participation);
            $this->addFlash('success', 'Vous êtes maintenant inscrit à cet événement !');
        }

        $this->entityManager->flush();

        return $this->redirectToRoute('app_event_show', ['id' => $event->getId()]);
    }

    // --- Added Action to Cancel Participation ---
    #[Route('/{id}/cancel-participation', name: 'app_event_cancel_participation', methods: ['POST'])]
    public function cancelParticipation(Request $request, Event $event, UtilisateurRepository $utilisateurRepository): Response // EntityManager injected via constructor
    {
        // WARNING: No security check!
        $user = $this->getUser();
        if (!$user) {
            // Using the fallback test user logic from your original code (less ideal for cancel)
            $user = $utilisateurRepository->findOneBy(['email' => 'test@example.com']);
            if (!$user) {
                $this->addFlash('warning', 'Utilisateur non trouvé pour annuler la participation.');
                return $this->redirectToRoute('app_event_show', ['id' => $event->getId()]);
            }
        }

        // Find the ACTIVE participation to cancel
        $participation = $this->participationRepository->findOneBy([
            'event' => $event,
            'utilisateur' => $user,
            'statut' => ParticipationStatus::INSCRIT // Only cancel if currently 'INSCRIT'
        ]);

        if (!$participation) {
            $this->addFlash('warning', 'Vous n\'êtes pas activement inscrit à cet événement.');
            return $this->redirectToRoute('app_event_show', ['id' => $event->getId()]);
        }

        // Change status to Cancelled
        $participation->setStatut(ParticipationStatus::ANNULE);
        $this->entityManager->persist($participation); // Persist the change
        $this->entityManager->flush();

        $this->addFlash('success', 'Votre participation à l\'événement a été annulée.');
        return $this->redirectToRoute('app_event_show', ['id' => $event->getId()]);
    }
    // --- End Added Action ---


    #[Route('/{id}', name: 'app_event_show', methods: ['GET'])]
    public function show(Event $event): Response // ParticipationRepository injected via constructor
    {
        $user = $this->getUser();
        $user_participation = null;
        if ($user instanceof Utilisateur) {
            // Find specific participation (active or cancelled) for this user/event
            $user_participation = $this->participationRepository->findOneBy(['event' => $event, 'utilisateur' => $user]);
        }

        return $this->render('event/show.html.twig', [
            'event' => $event,
            // Pass the specific participation object (or null) to the template
            'user_participation' => $user_participation
        ]);
    }

    #[Route('/{id}/edit', name: 'app_event_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Event $event): Response // EntityManager injected via constructor
    {
        $form = $this->createForm(EventType::class, $event);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->flush();
            $this->addFlash('success', 'Événement mis à jour.');
            // Redirect back to the show page or index
            return $this->redirectToRoute('app_event_show', ['id' => $event->getId()]);
        }

        return $this->render('event/edit.html.twig', [
            'event' => $event,
            'form' => $form->createView(), // Pass form view
        ]);
    }

    #[Route('/{id}', name: 'app_event_delete', methods: ['POST'])]
    public function delete(Request $request, Event $event): Response // EntityManager injected via constructor
    {
        // WARNING: Original code has Csrf check but redirects to admin dashboard.
        // Keeping the CSRF check as it's good practice, even if other security is removed.
        // Redirecting to event index instead of admin dashboard.
        // Also, need to handle deletion of related participations.
        if (true) {

            // Manually remove participations before removing event (if cascade={"remove"} isn't set or doesn't work)
            $participations = $this->participationRepository->findBy(['event' => $event]);
            foreach ($participations as $participation) {
                $this->entityManager->remove($participation);
            }
            // Flush removals if necessary, though often can be done in one flush
            // $this->entityManager->flush();

            $this->entityManager->remove($event);
            $this->entityManager->flush();
            $this->addFlash('success', 'Événement supprimé.');
        } else {
            $this->addFlash('danger', 'Action invalide (CSRF token mismatch).');
            return $this->redirectToRoute('app_event_show', ['id' => $event->getId()]); // Redirect back if token fails
        }

        return $this->redirectToRoute('app_admin_events'); // Redirect to event list
    }

    #[Route('/{id}/participants', name: 'app_event_participants', methods: ['GET'])]
    public function participants(Event $event): Response // ParticipationRepository injected via constructor
    {
        // This action remains the same, just lists participants.
        $participants = $this->participationRepository->findByEvent($event);

        // Render the view for showing participants (assuming this view exists and is correct)
        return $this->render('event/participants.html.twig', [
            'event' => $event,
            'participants' => $participants,
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/LoginController.php -----
<?php
// src/Controller/LoginController.php
namespace App\Controller;

use App\Entity\Utilisateur;
use App\Repository\UtilisateurRepository;
use App\Service\FacialRecognitionService;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Session\SessionInterface; // Needed for manual login
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface; // Needed? Maybe not here.
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface; // Needed for manual login
use Symfony\Component\Security\Core\Authentication\Token\UsernamePasswordToken; // Needed for manual login
use Symfony\Component\Security\Core\Exception\CustomUserMessageAccountStatusException; // For errors
use Symfony\Component\Security\Http\Authentication\AuthenticationUtils;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface; // For redirects

class LoginController extends AbstractController
{
    private UrlGeneratorInterface $urlGenerator;

    public function __construct(UrlGeneratorInterface $urlGenerator)
    {
        $this->urlGenerator = $urlGenerator;
    }

    /**
     * Displays the login page.
     */
    #[Route('/connexion-page', name: 'app_login_page', methods: ['GET'])]
    public function loginPage(AuthenticationUtils $authenticationUtils): Response
    {
        // Logic to redirect if already logged in
        if ($this->getUser()) {
            // Redirect logic... (as before)
            if ($this->isGranted('ROLE_ADMIN')) return $this->redirectToRoute('admin_dashboard');
            if ($this->isGranted('ROLE_PARTENAIRE')) return $this->redirectToRoute('app_partenaire_dashboard');
            return $this->redirectToRoute('client_dashboard');
        }

        $error = $authenticationUtils->getLastAuthenticationError();
        $lastUsername = $authenticationUtils->getLastUsername();

        return $this->render('security/login.html.twig', [
            'last_username' => $lastUsername,
            'error' => $error,
        ]);
    }

    /**
     * Route for password form submission (handled by PasswordOnlyAuthenticator)
     */
    #[Route('/login/authenticate-password', name: 'app_login_authenticate_password', methods: ['POST'])]
    public function loginAuthenticatePassword(): void
    {
        // Handled by PasswordOnlyAuthenticator::authenticate()
        throw new \LogicException('This method should not be reached. Check security firewall.');
    }

    /**
     * AJAX: Checks email existence and available login methods.
     */
    #[Route('/login/check-email-caps', name: 'app_login_check_email_caps', methods: ['POST'])]
    public function checkEmailAndCapabilities(Request $request, UtilisateurRepository $userRepository): JsonResponse
    {
        $email = $request->request->get('email');
        if (empty($email)) {
            return new JsonResponse(['success' => false, 'message' => 'Email manquant.'], Response::HTTP_BAD_REQUEST);
        }

        /** @var Utilisateur|null $user */
        $user = $userRepository->findOneBy(['email' => $email]);

        if (!$user) {
            return new JsonResponse(['success' => false, 'message' => 'Aucun compte trouvé pour cet email.'], Response::HTTP_NOT_FOUND);
        }

        // Determine capabilities
        $canLoginWithPassword = !empty($user->getPassword()); // Check if password hash exists
        $canLoginWithFace = !empty($user->getFaceEmbedding());

        if (!$canLoginWithPassword && !$canLoginWithFace) {
            return new JsonResponse(['success' => false, 'message' => 'Aucune méthode de connexion configurée pour ce compte.'], Response::HTTP_FORBIDDEN);
        }

        // Optional: Add checks for isActive and isVerified here for better UX
        if (!$user->isActive()) {
            return new JsonResponse(['success' => false, 'message' => 'Ce compte est désactivé.'], Response::HTTP_FORBIDDEN);
        }
        if (!$user->isVerified()) {
            return new JsonResponse(['success' => false, 'message' => 'Ce compte n\'est pas vérifié. Consultez votre e-mail.'], Response::HTTP_FORBIDDEN);
        }

        return new JsonResponse([
            'success' => true,
            'canLoginWithPassword' => $canLoginWithPassword,
            'canLoginWithFace' => $canLoginWithFace,
            'message' => 'Choisissez votre méthode de connexion.'
        ]);
    }

    /**
     * AJAX: Handles facial login attempt and performs manual authentication.
     */
    #[Route('/login/authenticate-face', name: 'app_login_authenticate_face', methods: ['POST'])]
    public function authenticateFace(
        Request $request,
        UtilisateurRepository $userRepository,
        FacialRecognitionService $faceRecService,
        TokenStorageInterface $tokenStorage, // For manual login
        SessionInterface $session // For manual login
    ): JsonResponse {
        $email = $request->request->get('email');
        $faceData = $request->request->get('face_data'); // Expect comma-separated string

        if (empty($email) || empty($faceData)) {
            return new JsonResponse(['success' => false, 'message' => 'Données email ou faciales manquantes.'], Response::HTTP_BAD_REQUEST);
        }

        /** @var Utilisateur|null $user */
        $user = $userRepository->findOneBy(['email' => $email]);

        // Verify user exists and has face data configured
        if (!$user || empty($user->getFaceEmbedding())) {
            return new JsonResponse(['success' => false, 'message' => 'Utilisateur ou configuration faciale introuvable.'], Response::HTTP_NOT_FOUND);
        }

        // --- CRITICAL CHECKS before expensive face comparison ---
        if (!$user->isActive()) {
            return new JsonResponse(['success' => false, 'message' => 'Ce compte est désactivé.'], Response::HTTP_FORBIDDEN);
        }
        if (!$user->isVerified()) {
            return new JsonResponse(['success' => false, 'message' => 'Ce compte n\'est pas vérifié.'], Response::HTTP_FORBIDDEN);
        }
        // --- END CRITICAL CHECKS ---

        // Compare Faces using the Service
        $isMatch = $faceRecService->compareFaces($faceData, $user->getFaceEmbedding());

        if ($isMatch) {
            // Face matches! Manually Authenticate the User
            try {
                // 1. Create the Security Token ('main' = firewall name)
                $securityToken = new UsernamePasswordToken($user, 'main', $user->getRoles());

                // 2. Set token in Token Storage (for current request)
                $tokenStorage->setToken($securityToken);

                // 3. Set token in Session (for subsequent requests)
                // Use the standard key Symfony's ContextListener looks for
                $session->set('_security_main', serialize($securityToken));

                // 4. Regenerate session ID
                $session->migrate(true);

                // 5. Determine Redirect URL
                $redirectUrl = $session->get('_security.main.target_path'); // <--- CORRECT LINE (assuming firewall name is 'main')
                if (!$redirectUrl) {
                    $roles = $user->getRoles();
                    if (in_array('ROLE_ADMIN', $roles, true)) $redirectUrl = $this->urlGenerator->generate('admin_dashboard');
                    elseif (in_array('ROLE_PARTENAIRE', $roles, true)) $redirectUrl = $this->urlGenerator->generate('app_partenaire_dashboard');
                    else $redirectUrl = $this->urlGenerator->generate('client_dashboard');
                }

                // 6. Return success with redirect URL for JS
                return new JsonResponse([
                    'success' => true,
                    'message' => 'Authentification faciale réussie.',
                    'redirectUrl' => $redirectUrl
                ]);

            } catch (\Exception $e) {
                // Log internal errors during token creation/session setting
                error_log("Manual facial login error: " . $e->getMessage());
                return new JsonResponse(['success' => false, 'message' => 'Erreur interne lors de la connexion.'], Response::HTTP_INTERNAL_SERVER_ERROR);
            }
        } else {
            // Face does not match
            return new JsonResponse([
                'success' => false,
                'message' => 'Visage non reconnu. Réessayez.'
            ], Response::HTTP_UNAUTHORIZED); // 401 Unauthorized
        }
    }

    #[Route(path: '/logout', name: 'app_logout')]
    public function logout(): void
    {
        // Intercepted by the logout key in security.yaml
        throw new \LogicException('This method can be blank - intercepted by the logout key.');
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/TrottinetteController.php -----
<?php

// src/Controller/Admin/TrottinetteController.php
namespace App\Controller\Admin;

use App\Entity\Trottinette;
use App\Enum\TrottinetteStatus;
use App\Form\TrottinetteFilterType;
use App\Form\TrottinetteType;
use App\Repository\TrottinetteRepository;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Annotation\Route;
use Doctrine\ORM\EntityManagerInterface;
use App\Repository\UtilisateurRepository;
use App\Service\DataFixturesService;
use Symfony\Component\HttpFoundation\Response;
use App\Entity\PointRelais;
use Symfony\Contracts\HttpClient\HttpClientInterface;

#[Route('/admin/trottinettes')]
class TrottinetteController extends AbstractController
{
    private $entityManager;
    private DataFixturesService $dataFixturesService;
    private HttpClientInterface $client;
    // Define allowed limits for items per page
    private const ALLOWED_LIMITS = [10, 15, 25, 50, 100];
    private const DEFAULT_LIMIT = 15; // Set your preferred default

    public function __construct(EntityManagerInterface $entityManager, DataFixturesService $dataFixturesService,HttpClientInterface $client)
    {
        $this->entityManager = $entityManager;
        $this->dataFixturesService = $dataFixturesService;
        $this->client = $client;

    }

    #[Route('/', name: 'admin_trottinette_index', methods: ['GET'])]
    public function index(Request $request, TrottinetteRepository $repository): Response
    {
        $filterForm = $this->createForm(TrottinetteFilterType::class);
        $filterForm->handleRequest($request);

        $criteria = $filterForm->isSubmitted() && $filterForm->isValid() ? $filterForm->getData() : [];

        // --- Pagination Limit Handling ---
        $limit = $request->query->getInt('limit', self::DEFAULT_LIMIT);
        if (!in_array($limit, self::ALLOWED_LIMITS)) {
            $limit = self::DEFAULT_LIMIT;
        }
        // --- End Limit Handling ---

        $pagination = $repository->findFilteredPaginated( // Call the new method
            $criteria,
            $request->query->getInt('page', 1),
            $limit
        );

        // Fetch counts for dashboard cards
        $countDisponible = $repository->countByEtat(TrottinetteStatus::DISPONIBLE);
        $countEnLocation = $repository->countByEtat(TrottinetteStatus::EN_LOCATION);
        $countEnMaintenance = $repository->countByEtat(TrottinetteStatus::EN_MAINTENANCE);

        return $this->render('admin/trottinette/index.html.twig', [
            'pagination' => $pagination, // Pass the pagination object
            'filterForm' => $filterForm->createView(),
            'countDisponible' => $countDisponible,
            'countEnLocation' => $countEnLocation,
            'countEnMaintenance' => $countEnMaintenance,
            'currentLimit' => $limit,
            'allowedLimits' => self::ALLOWED_LIMITS,
        ]);
    }


    #[Route('/new', name: 'admin_trottinette_new', methods: ['GET', 'POST'])]
    public function new(Request $request, UtilisateurRepository $utilisateurRepository): Response
    {
        $trottinette = new Trottinette();
        
        // Set default values for PointRelais and Utilisateur
        $defaultPointRelaisId = $this->dataFixturesService->getDefaultPointRelaisId();
        $pointRelais = $this->entityManager->getRepository(PointRelais::class)->find($defaultPointRelaisId);
        if ($pointRelais) {
            $trottinette->setPointRelais($pointRelais);
        }
    
        $defaultUserId = $this->dataFixturesService->getDefaultUserId();
        if ($defaultUserId) {
            $utilisateur = $utilisateurRepository->find($defaultUserId);
            if ($utilisateur) {
                $trottinette->setUtilisateur($utilisateur);
            }
        }
        
        // Create the form
        $form = $this->createForm(TrottinetteType::class, $trottinette);
        $form->handleRequest($request);
    
        if ($form->isSubmitted() && $form->isValid()) {
            $trottinette->setDateAjout(new \DateTime()); // Set the date of creation
            // Création du SMS
            $emailBodyText = "Une nouvelle trottinette a été ajoutée au système.\n\nDétails:\nID: {$trottinette->getId()}\nModèle: {$trottinette->getModele()}\nDate d'ajout: {$trottinette->getDateAjout()->format('Y-m-d H:i:s')}";
            // Optional: Create an HTML body for nicer formatting

            $trottinetteInfo = 'Trottinette #' . $trottinette->getId() . ' (' . $trottinette->getModele() . ')';

            $emailBodyHtml = "<p>Une nouvelle trottinette a été ajoutée au système.</p>
                                  <p><strong>Détails:</strong></p>
                                  <ul>
                                      <li>Batterie: {$trottinette->getBatterie()}</li>
                                      <li>Autonomie: {$trottinette->getAutonomie()}</li>
                                      <li>Modèle: {$trottinette->getModele()}</li>
                                      <li>Date d'ajout: {$trottinette->getDateAjout()->format('Y-m-d H:i:s')}</li>
                                  </ul>";
            $emailSubject = 'Nouvelle Trottinette Ajoutée: ' . $trottinetteInfo;

            $headers = [
                'Content-Type' => 'application/json',
            ];
            $payload = [
                'title' => $emailSubject,
                'body' => $emailBodyHtml,
            ];

            $this->client->request('POST', "https://hook.eu1.make.com/sfdhlqdyn553tmy0i8ldk7eq1nwrriee", [
                'headers' => $headers,
                'json' => $payload,
            ]);

            try {
                $this->entityManager->persist($trottinette);
                $this->entityManager->flush();
                $this->addFlash('success', 'La trottinette a été ajoutée avec succès.');
                return $this->redirectToRoute('admin_trottinette_index');
            } catch (\Exception $e) {
                $this->addFlash('error', 'Erreur lors de l\'ajout de la trottinette: ' . $e->getMessage());
            }
        }
    
        return $this->render('admin/trottinette/new.html.twig', [
            'form' => $form->createView(),
        ]);
    }
    #[Route('/admin/trottinettes/{id}', name: 'admin_trottinette_show', methods: ['GET'])]          
    public function show(int $id, TrottinetteRepository $trottinetteRepository): Response
    {
        // Retrieve the trottinette by its ID
        $trottinette = $trottinetteRepository->find($id);

        // Check if the trottinette exists
        if (!$trottinette) {
            throw $this->createNotFoundException('Trottinette not found');
        }

        // Render the template and pass the trottinette entity
        return $this->render('admin/trottinette/show.html.twig', [
            'trottinette' => $trottinette,
        ]);
    }
    

    #[Route('/{id}/edit', name: 'admin_trottinette_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Trottinette $trottinette, EntityManagerInterface $entityManager, UtilisateurRepository $utilisateurRepository): Response
    {
        $form = $this->createForm(TrottinetteType::class, $trottinette);
        $form->handleRequest($request);

        if ($form->isSubmitted()) {
            if ($form->isValid()) {
                try {
                    $entityManager->flush();
                    $this->addFlash('success', 'La trottinette a été modifiée avec succès.');
                    return $this->redirectToRoute('admin_trottinette_index');
                } catch (\Exception $e) {
                    $this->addFlash('error', 'Erreur lors de la modification de la trottinette: ' . $e->getMessage());
                }
            }
        }    
        return $this->render('admin/trottinette/edit.html.twig', [
            'trottinette' => $trottinette,
            'form' => $form,
        ]);
    }

    #[Route('/{id}', name: 'admin_trottinette_delete', methods: ['POST'])]
    public function delete(Request $request, Trottinette $trottinette, EntityManagerInterface $entityManager): Response
    {
        if ($this->isCsrfTokenValid('delete'.$trottinette->getId(), $request->request->get('_token'))) {
            $entityManager->remove($trottinette);
            $entityManager->flush();
            $this->addFlash('success', 'La trottinette a été supprimée avec succès.');
        }

        return $this->redirectToRoute('admin_trottinette_index');
    }

    // CRUD actions...
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/EventController.php -----
<?php

namespace App\Controller\Admin;

use App\Entity\Event;
use App\Form\EventType;
use App\Repository\EventRepository;
use App\Repository\ParticipationRepository;
use App\Enum\GouvernoratEnum;
use Doctrine\ORM\EntityManagerInterface;
use Psr\Log\LoggerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Http\Attribute\IsGranted;
use Symfony\Component\HttpFoundation\JsonResponse;
use Knp\Component\Pager\PaginatorInterface;
use Symfony\Contracts\HttpClient\HttpClientInterface;

#[IsGranted('ROLE_ADMIN')]
#[Route('/admin/events')]
class EventController extends AbstractController
{
    private LoggerInterface $logger;
    private EntityManagerInterface $entityManager;
    private HttpClientInterface $httpClient;
    private string $openAiApiKey;

    // Inject necessary services including HttpClient and the API key
    public function __construct(
        LoggerInterface $logger,
        EntityManagerInterface $entityManager,
        HttpClientInterface $httpClient,
    ) {
        $this->logger = $logger;
        $this->entityManager = $entityManager;
        $this->httpClient = $httpClient;
        $this->openAiApiKey = "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";
    }







    /**
     * Displays a specific Event entity.
     */
    #[Route('/{id}', name: 'app_admin_event_show', requirements: ['id' => '\d+'], methods: ['GET'])]
    public function show(Event $event): Response
    {
        // You might want a dedicated admin show template or reuse a public one
        return $this->render('admin/event_show.html.twig', [
            'event' => $event,
        ]);
    }

    /**
     * Displays a form to edit an existing Event entity.
     */
    #[Route('/{id}/edit', name: 'app_admin_event_edit', requirements: ['id' => '\d+'], methods: ['GET', 'POST'])]
    public function edit(Request $request, Event $event): Response
    {
        // Tell the form it IS an admin edit to show the status field
        $form = $this->createForm(EventType::class, $event, ['is_admin_edit' => true]);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->flush();

            $this->addFlash('success', 'Événement mis à jour avec succès.');
            return $this->redirectToRoute('app_admin_events'); // Redirect to index
        }

        return $this->render('admin/event_form.html.twig', [ // Use a generic form template
            'event' => $event,
            'form' => $form->createView(),
            'page_title' => 'Modifier l\'Événement',
            'button_label' => 'Mettre à jour',
        ]);
    }

    /**
     * "Deletes" (Cancels) an Event entity via POST request.
     */
    #[Route('/{id}', name: 'app_admin_event_delete', requirements: ['id' => '\d+'], methods: ['POST'])]
    public function delete(Request $request, Event $event): Response
    {
        // Use a unique token name, e.g., 'delete_admin_' prefix
        if ($this->isCsrfTokenValid('delete_admin_' . $event->getId(), $request->request->get('_token'))) {
            $newStatus = $event->getStatut(); // Keep current status by default
            $message = '';
            $success = false;

            // Instead of removing, change status to ANNULE if applicable
            if (!in_array($event->getStatut(), ['TERMINE', 'ANNULE'])) {
                $event->setStatut('ANNULE'); // Use correct status value
                $this->entityManager->flush();
                $message = 'Événement annulé avec succès.';
                $success = true;
                $newStatus = 'ANNULE';
            } else {
                $message = 'L\'événement est déjà terminé ou annulé.';
                $success = false; // Indicate no change was made
            }

            // Handle AJAX request
            if ($request->isXmlHttpRequest()) {
                return new JsonResponse([
                    'success' => $success,
                    'message' => $message,
                    'newStatut' => $newStatus // Send back new status for potential UI update
                ]);
            }

            // Standard flash message for non-AJAX requests
            $this->addFlash($success ? 'success' : 'warning', $message);

        } else {
            if ($request->isXmlHttpRequest()) {
                return new JsonResponse(['success' => false, 'error' => 'Token CSRF invalide.'], Response::HTTP_BAD_REQUEST);
            }
            $this->addFlash('error', 'Token CSRF invalide.');
        }

        return $this->redirectToRoute('app_admin_events'); // Redirect to index
    }

    /**
     * Shows participants for a specific event.
     */
    #[Route('/{id}/participants', name: 'app_admin_event_participants', requirements: ['id' => '\d+'], methods: ['GET'])]
    public function eventParticipants(Event $event, ParticipationRepository $participationRepo): Response
    {
        // Fetch participations specifically for this event
        $participations = $participationRepo->findBy(['event' => $event], ['dateInscription' => 'DESC']);

        return $this->render('admin/event_participants.html.twig', [
            'event' => $event,
            'participants' => $participations, // Pass the fetched participations
        ]);
    }







    // --- UPDATED ACTION FOR OPENAI GENERATION ---
    #[Route('/generate-details', name: 'app_admin_event_generate_details', methods: ['POST'])]
    public function generateDetailsFromDescription(Request $request): JsonResponse
    {
        $description = $request->request->get('description');

        if (empty($description)) {
            return new JsonResponse(['success' => false, 'message' => 'Description manquante.'], Response::HTTP_BAD_REQUEST);
        }


        // Use the system prompt from the Java example
        $systemPrompt = <<<PROMPT
        You are an event generator. Given an event description, output a JSON object with keys en francais: title, description, startDate (yyyy-MM-dd), endDate (yyyy-MM-dd), autonomy (an integer), and status (one of A_VENIR, EN_COURS, TERMINE, ANNULE). Example JSON: {"title":"Evenement X", "description":"Une description enrichie", "startDate":"2025-03-10", "endDate":"2025-03-12", "autonomy":"100", "status":"EN_COURS"}
        PROMPT;

        // User prompt is the description
        $userPrompt = $description;

        $apiUrl = 'https://api.openai.com/v1/chat/completions';

        try {
            $this->logger->info("Sending request to OpenAI API for event generation.");
            $this->logger->debug("Prompt sent to OpenAI:", ['system' => $systemPrompt, 'user' => $userPrompt]);

            $response = $this->httpClient->request('POST', $apiUrl, [
                'headers' => [
                    'Authorization' => 'Bearer ' . $this->openAiApiKey, // Use the injected key
                    'Content-Type' => 'application/json',
                ],
                'json' => [
                    'model' => 'gpt-4o-mini', // Or gpt-3.5-turbo as in Java example
                    'messages' => [
                        // Match the Java payload structure
                        ['role' => 'system', 'content' => $systemPrompt],
                        ['role' => 'user', 'content' => $userPrompt]
                    ],
                    'temperature' => 0.5, // Adjust temperature if needed
                    'max_tokens' => 200, // Adjust token limit
                    // 'response_format' => ['type' => 'json_object'] // Keep if supported and desired
                ],
                'timeout' => 45,
            ]);

            $statusCode = $response->getStatusCode();
            $rawApiResponseContent = $response->getContent();
            $this->logger->info("==== RAW OpenAI API Response Content ====");
            $this->logger->info($rawApiResponseContent);
            $this->logger->info("=========================================");

            $responseData = $response->toArray();

            $this->logger->debug("OpenAI API Response Status: " . $statusCode);
            $this->logger->debug("OpenAI API Response Parsed Body: ", $responseData);

            if (!isset($responseData['choices'][0]['message']['content'])) {
                $this->logger->warning("Unexpected OpenAI response structure: 'choices[0].message.content' missing.", ['response' => $responseData]);
                throw new \Exception("Format de réponse OpenAI inattendu.");
            }

            $aiContent = trim($responseData['choices'][0]['message']['content']);
            $this->logger->info("Received content string from OpenAI: " . $aiContent);

            // --- Attempt to decode the content as JSON ---
            $extractedData = [];
            if (!empty($aiContent)) {
                try {
                    // Remove potential markdown ```json ... ``` blocks if present
                    $jsonString = preg_replace('/^```json\s*|\s*```$/', '', $aiContent);
                    $extractedData = json_decode($jsonString, true, 512, JSON_THROW_ON_ERROR);
                    if (!is_array($extractedData)) {
                        throw new \JsonException("Decoded AI response is not a valid JSON object/array.");
                    }
                    $this->logger->info("Successfully decoded JSON from AI.", $extractedData);
                } catch (\JsonException $e) {
                    // If JSON decoding fails, log it but DON'T use the fallback parser from previous attempts
                    // because the Java code *expects* JSON. We should return an error if JSON isn't received.
                    $this->logger->error("Failed to decode EXPECTED JSON response from AI: " . $e->getMessage(), ['raw_response' => $aiContent]);
                    throw new \Exception("L'IA n'a pas retourné un JSON valide comme attendu.");
                }
            } else {
                $this->logger->warning("AI returned empty content string.");
                throw new \Exception("L'IA a retourné une réponse vide.");
            }

            // --- Data Cleaning and Mapping (using keys from Java example) ---
            if (!empty($extractedData) && is_array($extractedData)) {
                $cleanedData = [];

                // Titre (from 'title')
                if (!empty($extractedData['title']) && is_string($extractedData['title'])) {
                    $cleanedData['titre'] = trim($extractedData['title']);
                }
                // Description (from 'description' - overwrite original?)
                if (!empty($extractedData['description']) && is_string($extractedData['description'])) {
                    // Decide if you want to overwrite the user's description
                    // $cleanedData['description'] = trim($extractedData['description']);
                }

                // Dates (from 'startDate', 'endDate' - format for HTML input)
                if (!empty($extractedData['startDate']) && is_string($extractedData['startDate'])) {
                    $dateTime = \DateTime::createFromFormat('Y-m-d', $extractedData['startDate']); // Expecting yyyy-MM-dd
                    if ($dateTime instanceof \DateTimeInterface) {
                        $cleanedData['dateDebut'] = $dateTime->format('Y-m-d\T00:00'); // Set time to 00:00 for date-only input
                    } else { $this->logger->warning("Invalid startDate format '{$extractedData['startDate']}' from AI"); }
                }
                if (!empty($extractedData['endDate']) && is_string($extractedData['endDate'])) {
                    $dateTime = \DateTime::createFromFormat('Y-m-d', $extractedData['endDate']);
                    if ($dateTime instanceof \DateTimeInterface) {
                        $cleanedData['dateFin'] = $dateTime->format('Y-m-d\T23:59'); // Set time to end of day
                    } else { $this->logger->warning("Invalid endDate format '{$extractedData['endDate']}' from AI"); }
                }

                // Autonomie (from 'autonomy')
                if (isset($extractedData['autonomy']) && filter_var($extractedData['autonomy'], FILTER_VALIDATE_INT, ['options' => ['min_range' => 0]]) !== false) {
                    $cleanedData['trottinetteMinAutonomie'] = (int) $extractedData['autonomy'];
                } elseif (isset($extractedData['autonomy'])) {
                    $this->logger->warning("Invalid autonomy value from AI: {$extractedData['autonomy']}");
                }

                // Statut (from 'status' - mainly for reference, form likely defaults to A_VENIR)
                if (!empty($extractedData['status']) && is_string($extractedData['status']) && in_array($extractedData['status'], ["A_VENIR", "EN_COURS", "TERMINE", "ANNULE"])) {
                    // $cleanedData['statut'] = $extractedData['status']; // Not usually set by AI for new events
                }

                // --- ADD RANDOM LOCATION ---
                $governorates = GouvernoratEnum::cases();
                if (!empty($governorates)) {
                    $randomIndex = array_rand($governorates);
                    $randomGovernorate = $governorates[$randomIndex];
                    $cleanedData['state'] = $randomGovernorate->value; // Add the Enum *value* for the form select
                    $this->logger->info("Randomly selected state: " . $randomGovernorate->value);
                } else {
                    $this->logger->warning("Could not get GouvernoratEnum cases for random selection.");
                }
                // --- END RANDOM LOCATION ---

                if (empty($cleanedData)) {
                    $this->logger->warning("No usable data extracted after cleaning.", ['raw_extracted' => $extractedData]);
                    return new JsonResponse(['success' => false, 'message' => "L'IA n'a pas pu extraire d'informations exploitables."]);
                }

                $this->logger->info("Successfully extracted and processed AI data:", $cleanedData);
                return new JsonResponse(['success' => true, 'data' => $cleanedData]);

            } else {
                $this->logger->error("Initial extraction resulted in empty or non-array data.", ['initial_data' => $extractedData]);
                return new JsonResponse(['success' => false, 'message' => "L'IA n'a pas retourné de données structurées."]);
            }

        }
            // Keep existing catch blocks
        catch (\Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface $e) {
            $this->logger->error("OpenAI API Transport Error: " . $e->getMessage(), ['exception' => $e]);
            return new JsonResponse(['success' => false, 'message' => "Erreur de connexion au service OpenAI."], Response::HTTP_SERVICE_UNAVAILABLE);
        } catch (\Symfony\Contracts\HttpClient\Exception\ClientExceptionInterface $e) {
            $this->logger->error("OpenAI API Client Error: " . $e->getMessage(), ['response' => $e->getResponse()->getContent(false), 'exception' => $e]);
            if ($e->getResponse()->getStatusCode() === 401) {
                return new JsonResponse(['success' => false, 'message' => "Erreur d'authentification avec l'API OpenAI (Clé invalide?)."], Response::HTTP_INTERNAL_SERVER_ERROR);
            }
            return new JsonResponse(['success' => false, 'message' => "Erreur de l'API OpenAI: " . $e->getResponse()->getInfo('http_code')], Response::HTTP_BAD_GATEWAY);
        } catch (\Symfony\Contracts\HttpClient\Exception\ServerExceptionInterface $e) {
            $this->logger->error("OpenAI API Server Error: " . $e->getMessage(), ['response' => $e->getResponse()->getContent(false), 'exception' => $e]);
            return new JsonResponse(['success' => false, 'message' => "Le service OpenAI rencontre des problèmes. Réessayez plus tard."], Response::HTTP_BAD_GATEWAY);
        } catch (\Exception $e) {
            $this->logger->error("Error processing AI response: " . $e->getMessage(), ['description' => $description, 'prompt' => $systemPrompt."\n".$userPrompt, 'exception' => $e]);
            return new JsonResponse(['success' => false, 'message' => "Erreur interne lors de la génération des détails : " . $e->getMessage()], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Lists all events with filtering, sorting, and pagination for Admins.
     */
    // CORRECTED ROUTE FOR INDEX
    #[Route('/', name: 'app_admin_events', methods: ['GET'])]
    public function index(
        EventRepository    $events,
        Request            $request,
        PaginatorInterface $paginator
    ): Response {
        /* ---------- query parameters & sane defaults -------------------- */
        $search    = trim((string)$request->query->get('search', ''));
        $filter    =              $request->query->get('filter', 'all');
        $page      = max(1, (int) $request->query->get('page',   1));
        $limit     = max(1, (int) $request->query->get('limit', 10));

        // Define allowed sort fields mapping URL key to DQL path
        $allowedSortsMap = [
            'titre'     => 'e.titre',
            'dateDebut' => 'e.dateDebut',
            'statut'    => 'e.statut',
            'state'     => 'e.state', // Maps to Gouvernorat field
            'autonomie' => 'e.trottinetteMinAutonomie',
        ];
        $defaultSortFieldKey = 'dateDebut'; // Default KEY
        $defaultSortDirection = 'desc';

        $sortKey = $request->query->get('sort', $defaultSortFieldKey);
        $sortField = $allowedSortsMap[$sortKey] ?? $allowedSortsMap[$defaultSortFieldKey]; // Get DQL path
        $direction = strtolower($request->query->get('direction', $defaultSortDirection));
        if (!in_array($direction, ['asc', 'desc'])) {
            $direction = $defaultSortDirection;
        }

        /* ---------- query builder --------------------------------------- */
        $qb = $events->createQueryBuilder('e')
            ->leftJoin('e.participations', 'p')
            ->addSelect('COUNT(p.id) AS participantCount')
            ->groupBy('e.id');

        if ($search !== '') {
            $qb->andWhere(
                $qb->expr()->orX(
                    'LOWER(e.titre)       LIKE :q',
                    'LOWER(e.description) LIKE :q',
                    'LOWER(e.state)       LIKE :q' // Filter directly on enum value string
                )
            )->setParameter('q', '%' . mb_strtolower($search) . '%');
        }

        $now = new \DateTimeImmutable();
        switch ($filter) {
            case 'upcoming': $qb->andWhere('e.dateDebut >= :now')->setParameter('now', $now); break;
            case 'past':     $qb->andWhere('e.dateDebut <  :now')->setParameter('now', $now); break;
            // Filtering by status ENUM value
            case 'a_venir':  $qb->andWhere('e.statut = :s')->setParameter('s', 'A_VENIR');    break;
            case 'en_cours': $qb->andWhere('e.statut = :s')->setParameter('s', 'EN_COURS');   break;
            case 'termine':  $qb->andWhere('e.statut = :s')->setParameter('s', 'TERMINE');    break;
            case 'annule':   $qb->andWhere('e.statut = :s')->setParameter('s', 'ANNULE');     break;
        }

        /* ---------- pagination (KNP adds ORDER BY automatically) --------- */
        $pagination = $paginator->paginate(
            $qb->getQuery(), // Pass Query object
            $page,
            $limit,
            [
                'pageParameterName'          => 'page',
                'sortFieldParameterName'     => 'sort', // Matches the URL param KEY
                'sortDirectionParameterName' => 'direction',
                'defaultSortFieldName'       => $sortField, // Pass the DQL path
                'defaultSortDirection'       => $direction,
                'distinct'                   => false,
                'sortFieldWhitelist'         => array_values($allowedSortsMap) // Whitelist DQL paths
            ]
        );

        // Fetch status counts for dashboard cards (if needed on this page)
        $countAVenir = $events->countByStatus('A_VENIR');
        $countEnCours = $events->countByStatus('EN_COURS');
        $countTermine = $events->countByStatus('TERMINE');
        $countAnnule = $events->countByStatus('ANNULE');

        /* ---------- view ------------------------------------------------- */
        return $this->render('admin/events.html.twig', [
            'pagination'     => $pagination,
            'current_filter' => $filter,
            'search_term'    => $search,
            'limit'          => $limit,
            'sort'           => $sortKey, // Pass the KEY for active link styling
            'direction'      => $direction,
            'countAVenir' => $countAVenir,
            'countEnCours' => $countEnCours,
            'countTermine' => $countTermine,
            'countAnnule' => $countAnnule,
            'allowedLimits' => [10, 20, 50], // Example allowed limits
            'currentLimit' => $limit,
        ]);
    }





    /**
     * Displays a form to create a new Event entity.
     */
    // CORRECTED ROUTE FOR NEW
    #[Route('/new', name: 'app_admin_event_new', methods: ['GET', 'POST'])]
    public function new(Request $request): Response
    {
        $event = new Event();
        $event->setStatut('A_VENIR'); // Sensible default

        $form = $this->createForm(EventType::class, $event, ['is_admin_edit' => false]);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->persist($event);
            $this->entityManager->flush();

            $this->addFlash('success', 'Événement créé avec succès.');
            return $this->redirectToRoute('app_admin_events');
        }

        return $this->render('admin/event_form.html.twig', [
            'event' => $event,
            'form' => $form->createView(),
            'page_title' => 'Nouvel Événement',
            'button_label' => 'Créer',
            'show_ai_button' => true // Flag to show the AI button on the 'new' page
        ]);
    }





    /**
     * AJAX endpoint to generate event details from description using OpenAI.
     */


    /**
     * Attempts to map a location string (from AI) to a GouvernoratEnum value.
     * (This is less relevant now as location is generated randomly, but keep it for potential future use)
     */
    private function mapLocationToGouvernoratValue(?string $locationString): ?string
    {
        if ($locationString === null || trim($locationString) === '') return null;
        $normalizedLocation = mb_strtolower(trim($locationString));
        $mapping = [ /* ... your mapping ... */ ];
        if (isset($mapping[$normalizedLocation])) return $mapping[$normalizedLocation];
        foreach (GouvernoratEnum::cases() as $case) {
            if ($normalizedLocation === mb_strtolower($case->label()) || $normalizedLocation === mb_strtolower($case->value)) return $case->value;
        }
        return null;
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/DashboardController.php -----
<?php
// src/Controller/Admin/DashboardController.php
namespace App\Controller\Admin;

use App\Repository\EventRepository;
use App\Repository\UtilisateurRepository;
use App\Repository\TrottinetteRepository;
use App\Repository\ReservationRepository;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Http\Attribute\IsGranted;

#[Route('/admin')]
#[IsGranted('ROLE_ADMIN')]
class DashboardController extends AbstractController
{
    #[Route('/', name: 'admin_dashboard')]
    public function dashboard(
        UtilisateurRepository $userRepo,
        TrottinetteRepository $trottinetteRepo,
        ReservationRepository $reservationRepo,
        EventRepository $eventRepository
    ) {
        $events = $eventRepository->findAll();

        $eventData = [];
        foreach ($events as $event) {
            $eventData[] = [
                'event' => $event,
                'participantCount' => $event->getParticipations()->count(),
                
            ];
        }

        
        return $this->render('admin/dashboard.html.twig', [
            'eventData' => $eventData,
            'user_count' => $userRepo->count([]),
            'trottinette_count' => $trottinetteRepo->count([]),
            'reservation_count' => $reservationRepo->count([]),
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/ReservationController.php -----
<?php

namespace App\Controller\Admin;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

class ReservationController extends AbstractController
{
    // TODO: actions
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/UtilisateurController.php -----
<?php
// src/Controller/Admin/UtilisateurController.php
namespace App\Controller\Admin;

    use App\Entity\Utilisateur;
    use App\Form\AdminUserType; // Use the specific Admin form
    use App\Form\UserFilterType; // Use the filter form
    use App\Repository\UtilisateurRepository;
    use Doctrine\ORM\EntityManagerInterface;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
    use Symfony\Component\Routing\Annotation\Route;
    use Symfony\Component\Security\Http\Attribute\IsGranted;

#[Route('/admin/utilisateurs')] // Base route for admin user management
#[IsGranted('ROLE_ADMIN')] // Ensure only admins can access
class UtilisateurController extends AbstractController
{
    // --- Sorting Constants ---
    public const ALLOWED_SORT_FIELDS = [
        'id' => 'u.id',
        'nom' => 'u.nom',
        'prenom' => 'u.prenom',
        'email' => 'u.email',
        'role' => 'u.roleInterne',
        'actif' => 'u.isActive',
        'verifie' => 'u.isVerified',
    ];
    private const DEFAULT_SORT_FIELD = 'nom'; // User-friendly key from ALLOWED_SORT_FIELDS
    private const DEFAULT_SORT_DIRECTION = 'asc';
    private const DEFAULT_LIMIT = 15; // Items per page
    // --- End Sorting Constants ---

    private UserPasswordHasherInterface $passwordHasher;
    private EntityManagerInterface $entityManager;

    public function __construct(UserPasswordHasherInterface $passwordHasher, EntityManagerInterface $entityManager)
    {
        $this->passwordHasher = $passwordHasher;
        $this->entityManager = $entityManager;
    }

    #[Route('/', name: 'admin_utilisateur_index', methods: ['GET'])]
    public function index(Request $request, UtilisateurRepository $utilisateurRepository): Response
    {
        // Create and handle the filter form
        $filterForm = $this->createForm(UserFilterType::class, null, [
            'method' => 'GET', // Use GET for filters
            'csrf_protection' => false, // Disable CSRF for idempotent GET filters
        ]);
        $filterForm->handleRequest($request);

        // Get filter criteria from the form if submitted and valid, otherwise default to empty
        $criteria = $filterForm->isSubmitted() && $filterForm->isValid() ? $filterForm->getData() : [];
        // Clean empty criteria that might come from the form (like an empty search string)
        $criteria = array_filter($criteria, function($value) { return $value !== null && $value !== ''; });

        // --- Handle Sorting & Pagination Parameters ---
        $page = $request->query->getInt('page', 1);
        $limit = self::DEFAULT_LIMIT; // Use the constant

        // Get sort parameters from the request, fallback to defaults
        $sortKey = $request->query->get('sort', self::DEFAULT_SORT_FIELD);
        $direction = $request->query->get('direction', self::DEFAULT_SORT_DIRECTION);

        // Validate sort direction
        if (!in_array(strtolower($direction), ['asc', 'desc'])) {
            $direction = self::DEFAULT_SORT_DIRECTION;
        }

        // Validate sort field key against the whitelist
        if (!array_key_exists($sortKey, self::ALLOWED_SORT_FIELDS)) {
            $sortKey = self::DEFAULT_SORT_FIELD;
            $direction = self::DEFAULT_SORT_DIRECTION; // Reset direction if key is invalid
        }

        // Get the actual DQL field name from the validated key
        $sortFieldDql = self::ALLOWED_SORT_FIELDS[$sortKey];
        // Prepare the whitelist of DQL fields for the repository/paginator
        $sortFieldWhitelist = array_values(self::ALLOWED_SORT_FIELDS);
        // --- End Sorting & Pagination Parameters ---

        // Call the repository method which returns the KNP Pagination object
        // Pass criteria, pagination info, AND sorting info
        $pagination = $utilisateurRepository->findByCriteria(
            $criteria,
            $page,
            $limit,
            $sortFieldDql,        // Pass the validated DQL sort field
            $direction,           // Pass the validated sort direction
            $sortFieldWhitelist   // Pass the whitelist of allowed DQL fields
        );

        // The $pagination variable now holds an instance of Knp\Bundle\PaginatorBundle\Pagination\SlidingPagination

        // Render the template, passing the KNP pagination object and the filter form view
        return $this->render('admin/utilisateur/index.html.twig', [
            'pagination' => $pagination,
            'filterForm' => $filterForm->createView(),
            // Note: No need to pass current_sort, current_direction, or allowed_sort_fields
            // if you are using knp_pagination_sortable, as it gets info from the request.
        ]);
    }
    #[Route('/new', name: 'admin_utilisateur_new', methods: ['GET', 'POST'])]
    public function new(Request $request): Response
    {
        $utilisateur = new Utilisateur();
        // Set default role if needed, e.g., $utilisateur->setRoleInterne('client');
        $form = $this->createForm(AdminUserType::class, $utilisateur);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            // Handle password
            $plainPassword = $form->get('plainPassword')->getData();
            if (!empty($plainPassword)) {
                $hashedPassword = $this->passwordHasher->hashPassword(
                    $utilisateur,
                    $plainPassword
                );
                $utilisateur->setPassword($hashedPassword);
            } else {
                // Handle case where password is required for new user but left empty
                // This shouldn't happen if constraints are set, but good practice
                $this->addFlash('danger', 'Le mot de passe est obligatoire pour un nouvel utilisateur.');
                return $this->render('admin/utilisateur/new.html.twig', [
                    'utilisateur' => $utilisateur,
                    'form' => $form->createView(),
                ]);
            }

            // Set default verification status if needed, e.g., $utilisateur->setIsVerified(true);
            // Or trigger verification email flow

            $this->entityManager->persist($utilisateur);
            $this->entityManager->flush();

            $this->addFlash('success', 'Utilisateur créé avec succès.');

            return $this->redirectToRoute('admin_utilisateur_index', [], Response::HTTP_SEE_OTHER);
        }

        return $this->render('admin/utilisateur/new.html.twig', [
            'utilisateur' => $utilisateur,
            'form' => $form->createView(),
        ]);
    }

    #[Route('/{id}', name: 'admin_utilisateur_show', methods: ['GET'])]
    public function show(Utilisateur $utilisateur): Response
    {
        // Prevent admins from showing their own profile via this route? Optional.
        // if ($utilisateur === $this->getUser()) { ... }

        return $this->render('admin/utilisateur/show.html.twig', [
            'utilisateur' => $utilisateur,
        ]);
    }

    #[Route('/{id}/edit', name: 'admin_utilisateur_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Utilisateur $utilisateur): Response
    {
        // Prevent admins from editing their own profile via this route? Optional.
        //if ($utilisateur === $this->getUser()) {
        //   $this->addFlash('warning', 'Pour modifier votre propre profil, utilisez la section Mon Profil.');
        //   return $this->redirectToRoute('admin_utilisateur_index');
        //}

        $form = $this->createForm(AdminUserType::class, $utilisateur);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            // Handle password update ONLY if a new one was entered
            $plainPassword = $form->get('plainPassword')->getData();
            if (!empty($plainPassword)) {
                $hashedPassword = $this->passwordHasher->hashPassword(
                    $utilisateur,
                    $plainPassword
                );
                $utilisateur->setPassword($hashedPassword);
            }

            $this->entityManager->flush();

            $this->addFlash('success', 'Utilisateur mis à jour avec succès.');

            return $this->redirectToRoute('admin_utilisateur_index', [], Response::HTTP_SEE_OTHER);
        }

        return $this->render('admin/utilisateur/edit.html.twig', [
            'utilisateur' => $utilisateur,
            'form' => $form->createView(),
        ]);
    }

    #[Route('/{id}', name: 'admin_utilisateur_delete', methods: ['POST'])]
    public function delete(Request $request, Utilisateur $utilisateur): Response
    {
        // Prevent admins from deleting themselves
        if ($utilisateur === $this->getUser()) {
            $this->addFlash('danger', 'Vous ne pouvez pas supprimer votre propre compte administrateur.');
            return $this->redirectToRoute('admin_utilisateur_index');
        }

        if ($this->isCsrfTokenValid('delete'.$utilisateur->getId(), $request->request->get('_token'))) {
            try {
                $this->entityManager->remove($utilisateur);
                $this->entityManager->flush();
                $this->addFlash('success', 'Utilisateur supprimé avec succès.');
            } catch (\Exception $e) {
                // Catch potential DB constraint issues if user has related records
                $this->addFlash('danger', 'Impossible de supprimer l\'utilisateur. Il est peut-être lié à d\'autres enregistrements (réservations, etc.). Détails: ' . $e->getMessage());
            }
        } else {
            $this->addFlash('danger', 'Token CSRF invalide.');
        }


        return $this->redirectToRoute('admin_utilisateur_index', [], Response::HTTP_SEE_OTHER);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/PointRelaisController.php -----
<?php

namespace App\Controller\Admin;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

class PointRelaisController extends AbstractController
{
    // TODO: actions
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/MaintenanceController.php -----
<?php

namespace App\Controller\Admin;

use App\Entity\Maintenance;
use App\Enum\MaintenanceStatus;
use App\Enum\TrottinetteStatus;
use App\Form\MaintenanceFilterType;
use App\Form\MaintenanceType;
use App\Repository\MaintenanceRepository;
use App\Service\Texter;
use Doctrine\ORM\EntityManagerInterface;
use Knp\Component\Pager\PaginatorInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Http\Attribute\IsGranted;
use Symfony\Contracts\HttpClient\HttpClientInterface;
use App\Service\TwilioNotifierService;
use Symfony\Component\Notifier\Message\SmsMessage;
use Symfony\Component\Notifier\Bridge\Twilio\TwilioOptions;
use Symfony\Component\Notifier\TexterInterface;

#[Route('/admin/maintenance')]
#[IsGranted('ROLE_ADMIN')]
class MaintenanceController extends AbstractController
{
    private $twilioNotifierService;

    private HttpClientInterface $client;
    private EntityManagerInterface $entityManager;

    // Define allowed limits for items per page
    private const ALLOWED_LIMITS = [10, 15, 25, 50, 100];
    private const DEFAULT_LIMIT = 15; // Set your preferred default

    public function __construct(
        HttpClientInterface $client,
        EntityManagerInterface $entityManager,
        TwilioNotifierService $twilioNotifierService,

    ) {
        $this->client = $client;
        $this->entityManager = $entityManager;
        $this->twilioNotifierService = $twilioNotifierService;


    }

    #[Route('/', name: 'admin_maintenance_index', methods: ['GET'])]
    public function index(Request $request, MaintenanceRepository $maintenanceRepository,
                          PaginatorInterface $paginator // <-- Inject PaginatorInterface

    ): Response
    {
        $filterForm = $this->createForm(MaintenanceFilterType::class);
        $filterForm->handleRequest($request);

        $criteria = $filterForm->isSubmitted() && $filterForm->isValid() ? $filterForm->getData() : [];

        // --- Pagination Limit Handling ---
        $limit = $request->query->getInt('limit', self::DEFAULT_LIMIT);
        // Validate the requested limit against allowed values
        if (!in_array($limit, self::ALLOWED_LIMITS)) {
            $limit = self::DEFAULT_LIMIT;
        }
        // --- End Pagination Limit Handling ---

        $pagination = $maintenanceRepository->findFilteredPaginated(
            $criteria,
            $request->query->getInt('page', 1),
            $limit // Use the validated or default limit
        );
        $queryBuilder = $maintenanceRepository->createFilteredQueryBuilder($criteria); // Assuming this method exists now

        // --- Change: Use KnpPaginator ---
        $pagination = $paginator->paginate(
            $queryBuilder->getQuery(), // Target to paginate (Doctrine Query)
            $request->query->getInt('page', 1), // Current page number
            $limit // Limit per page
        // Optional: Paginator options array
        // ['defaultSortFieldName' => 'm.dateDebut', 'defaultSortDirection' => 'desc']
        );

        $countEnCours = $maintenanceRepository->countByStatus('EN_COURS');
        $countTerminee = $maintenanceRepository->countByStatus('TERMINEE');
        $countAnnulee = $maintenanceRepository->countByStatus('ANNULEE');

        return $this->render('maintenance/index.html.twig', [
            'pagination' => $pagination,
            'filterForm' => $filterForm->createView(),
            'countEnCours' => $countEnCours,
            'countTerminee' => $countTerminee,
            'countAnnulee' => $countAnnulee,
            // +++ Pass limit info to Twig +++
            'currentLimit' => $limit,
            'allowedLimits' => self::ALLOWED_LIMITS,
            // +++ End Pass limit info +++
        ]);
    }

    // ... (calendarView, new, show, edit, delete methods remain the same) ...
    // --- CALENDAR VIEW (Keep as is) ---
    #[Route('/calendar', name: 'admin_maintenance_calendar', methods: ['GET'])]
    public function calendarView(MaintenanceRepository $maintenanceRepository): Response
    {
        // ... (calendar logic remains the same) ...
        $maintenances = $maintenanceRepository->findAll(); // Fetch all for calendar

        $calendarEvents = [];
        foreach ($maintenances as $maintenance) {
            // ... (formatting logic remains the same) ...
            $trottinetteInfo = $maintenance->getTrottinette()
                ? 'Trott. #' . $maintenance->getTrottinetteId() . ' (' . $maintenance->getTrottinette()->getModele() . ')'
                : 'Trott. #' . $maintenance->getTrottinetteId();

            $color = match($maintenance->getStatut()) {
                'EN_COURS' => '#facc15',
                'TERMINEE' => '#4ade80',
                'ANNULEE' => '#f87171',
                default => '#9ca3af',
            };

            $calendarEvents[] = [
                'id' => $maintenance->getId(),
                'title' => $trottinetteInfo,
                'start' => $maintenance->getDateDebut()->format('Y-m-d H:i:s'),
                'end' => $maintenance->getDateFin()?->format('Y-m-d H:i:s'),
                'color' => $color,
                'extendedProps' => [
                    'description' => $maintenance->getDescription() ?: 'N/A',
                    'statut' => $maintenance->getStatut(),
                    'trottinetteId' => $maintenance->getTrottinetteId(),
                    'trottinetteModele' => $maintenance->getTrottinette()?->getModele(),
                    'trottinetteNumeroSerie' => $maintenance->getTrottinette()?->getNumeroSerie(),
                    'dateFinFormatted' => $maintenance->getDateFin() ? $maintenance->getDateFin()->format('d/m/Y H:i') : 'En cours',
                    'detailsUrl' => $this->generateUrl('admin_maintenance_show', ['id' => $maintenance->getId()])
                ]
            ];
        }

        return $this->render('maintenance/calendar.html.twig', [
            'calendarEvents' => $calendarEvents
        ]);
    }

    // --- NEW ACTION (Keep as is, ensure MaintenanceType is imported) ---
    #[Route('/new', name: 'admin_maintenance_new', methods: ['GET', 'POST'])]
    public function new(Request $request): Response // Removed EntityManager injection, using constructor's one
    {
        $maintenance = new Maintenance();
        // Maybe set default status? $maintenance->setStatut(MaintenanceStatus::EN_COURS);
        $form = $this->createForm(MaintenanceType::class, $maintenance);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            if ($maintenance->getTrottinette()) {
                $maintenance->setTrottinetteId($maintenance->getTrottinette()->getId());
                $trottinette = $maintenance->getTrottinette();
                // Only set to maintenance if not already terminated/cancelled
                if ($maintenance->getStatut() !== MaintenanceStatus::TERMINEE->value && $maintenance->getStatut() !== MaintenanceStatus::ANNULEE->value) {
                    $trottinette->setEtat(TrottinetteStatus::EN_MAINTENANCE);
                }
            }

            $this->entityManager->persist($maintenance);
            $this->entityManager->flush();

            $this->addFlash('success', 'La maintenance a été créée avec succès.');
            return $this->redirectToRoute('admin_maintenance_index', [], Response::HTTP_SEE_OTHER);
        }

        return $this->render('maintenance/new.html.twig', [ // Use new.html.twig instead of renderForm
            'maintenance' => $maintenance,
            'form' => $form->createView(), // Pass form view
        ]);
    }

    // --- SHOW ACTION (Keep as is) ---
    #[Route('/{id}', name: 'admin_maintenance_show', methods: ['GET'])]
    public function show(Maintenance $maintenance): Response
    {
        return $this->render('maintenance/show.html.twig', [
            'maintenance' => $maintenance,
        ]);
    }

    // --- EDIT ACTION (Keep mostly as is, ensure MaintenanceType is imported) ---
    #[Route('/{id}/edit', name: 'admin_maintenance_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Maintenance $maintenance): Response // Removed EntityManager injection
    {
        $originalStatus = $maintenance->getStatut(); // Store original status if needed
        $form = $this->createForm(MaintenanceType::class, $maintenance);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {

            $trottinette = $maintenance->getTrottinette();

            // Logic for updating trottinette status based on maintenance status change
            if ($trottinette) {
                $newStatusValue = $maintenance->getStatut(); // Assuming string value like 'TERMINEE'
                // Use Enum cases if your entity/form uses them directly
                // $newStatus = MaintenanceStatus::tryFrom($maintenance->getStatut());

                if ($newStatusValue === MaintenanceStatus::TERMINEE->value || $newStatusValue === MaintenanceStatus::ANNULEE->value) {
                    // Set trottinette back to DISPONIBLE only if it was previously EN_MAINTENANCE due to *this* maintenance record
                    // This check is simplistic; more complex logic might be needed if multiple maintenances overlap
                    if ($trottinette->getEtat() === TrottinetteStatus::EN_MAINTENANCE) {
                        $trottinette->setEtat(TrottinetteStatus::DISPONIBLE);
                    }



                    // SMS notification logic (only if status becomes TERMINEE)
                    if ($newStatusValue === MaintenanceStatus::TERMINEE->value) {
                        $trottinetteInfo = $trottinette
                            ? 'Trottinette #' . $maintenance->getTrottinetteId() . ' (' . $trottinette->getModele() . ')'
                            : 'Trottinette #' . $maintenance->getTrottinetteId();
                        $smsMessage = "Maintenance terminée pour {$trottinetteInfo}. Elle est maintenant disponible.";
                        $payload = ['body'  => $smsMessage];
                        $headers = ['Content-Type' => 'application/json'];

                        // Consider wrapping API call in try/catch or logging errors
                        try {
                            $texter=new Texter("AC92ce0293654b3bf92f26ad226c54270d","f0d8e15aced4230576ffa30c25700a12","+19342470919");
                            $sms = new SmsMessage('+19342470919', $smsMessage);

                            $texter->send($sms);
//                            $this->client->request('POST', "https://hook.eu1.make.com/ndgogmlq27hd1j6toex8eusathvnag8q", [
//                                'headers' => $headers,
//                                'json'    => $payload,
//                            ]);
                        } catch (\Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface $e) {
                            // Log error, flash message, etc.
                            $this->addFlash('warning', 'Maintenance mise à jour, mais l\'envoi de la notification SMS a échoué: '.$e->getMessage());
                        }
                    }

                } elseif ($newStatusValue === MaintenanceStatus::EN_COURS->value) {
                    // If status is set back to EN_COURS (or created as such), ensure trottinette is marked
                    $trottinette->setEtat(TrottinetteStatus::EN_MAINTENANCE);
                }
            }


            $this->entityManager->flush();
            $this->addFlash('success', 'La maintenance a été mise à jour avec succès.');
            return $this->redirectToRoute('admin_maintenance_index', [], Response::HTTP_SEE_OTHER);
        }

        return $this->render('maintenance/edit.html.twig', [ // Use edit.html.twig
            'maintenance' => $maintenance,
            'form' => $form->createView(), // Pass form view
        ]);
    }


    // --- DELETE ACTION (Keep mostly as is) ---
    #[Route('/{id}', name: 'admin_maintenance_delete', methods: ['POST'])]
    public function delete(Request $request, Maintenance $maintenance): Response // Removed EntityManager injection
    {
        if ($this->isCsrfTokenValid('delete'.$maintenance->getId(), $request->request->get('_token'))) {
            $trottinette = $maintenance->getTrottinette();
            // If deleting an 'EN_COURS' maintenance, set scooter back to available
            // Check if the status is indeed EN_COURS before changing scooter state
            if ($trottinette && $maintenance->getStatut() === MaintenanceStatus::EN_COURS->value) {
                if ($trottinette->getEtat() === TrottinetteStatus::EN_MAINTENANCE) {
                    // TODO: Add check: Is there ANOTHER 'EN_COURS' maintenance for this scooter?
                    // If not, set to available. Otherwise, leave it in maintenance.
                    // This requires another query - skipping for simplicity here.
                    $trottinette->setEtat(TrottinetteStatus::DISPONIBLE);
                }
            }

            $this->entityManager->remove($maintenance);
            $this->entityManager->flush();
            $this->addFlash('success', 'La maintenance a été supprimée avec succès.');
        } else {
            $this->addFlash('danger', 'Token CSRF invalide.');
        }

        return $this->redirectToRoute('admin_maintenance_index', [], Response::HTTP_SEE_OTHER); // Use SEE_OTHER for POST redirects
    }

    public function sendSms(TexterInterface $texter)
    {
        $sms = new SmsMessage('+21620692262', 'My message');
        $options = (new TwilioOptions())->statusCallback('https://your-webhook-url.com');
        $sms->options($options);

        $texter->send($sms);

        // ...
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/ReclamationController.php -----
<?php

namespace App\Controller\Admin;

use App\Entity\Reponse; // Importer l'entité Reponse
use App\Form\ReponseType; // Importer le formulaire Reponse
use App\Entity\Reclamation;
use App\Form\ReclamationType;
use App\Repository\ReclamationRepository;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

#[Route('/reclamation')]
class ReclamationController extends AbstractController
{
    // Route pour afficher toutes les réclamations
    #[Route('', name: 'reclamation_index', methods: ['GET'])]
    public function index(ReclamationRepository $reclamationRepository): Response
    {
        return $this->render('reclamation/index.html.twig', [
            'reclamations' => $reclamationRepository->findAll(),
        ]);
    }

    // Route pour la création d'une nouvelle réclamation
    #[Route('/new', name: 'reclamation_new', methods: ['GET', 'POST'])]
    public function new(Request $request, EntityManagerInterface $em): Response
    {
        $reclamation = new Reclamation();

        // Associer l'utilisateur connecté à la réclamation
        if ($this->getUser()) {
            $reclamation->setUtilisateur($this->getUser());
        } else {
            // Si pas connecté, rediriger vers la page de connexion
            $this->addFlash('error', 'Vous devez être connecté pour créer une réclamation.');
            return $this->redirectToRoute('app_login');
        }

        $form = $this->createForm(ReclamationType::class, $reclamation);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            if ($reclamation->getDateCreation() === null) {
                $reclamation->setDateCreation(new \DateTime());
            }

            $em->persist($reclamation);
            $em->flush();

            $this->addFlash('success', 'Réclamation créée avec succès.');
            return $this->redirectToRoute('reclamation_index');
        }

        return $this->render('reclamation/new.html.twig', [
            'form' => $form->createView(),
        ]);
    }
    // Route pour afficher une réclamation spécifique
    #[Route('/{id}', name: 'reclamation_show', methods: ['GET'])]
    public function show(Reclamation $reclamation): Response
    {
        return $this->render('reclamation/show.html.twig', [
            'reclamation' => $reclamation,
        ]);
    }

    // Route pour modifier une réclamation existante
    #[Route('/{id}/edit', name: 'reclamation_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Reclamation $reclamation, EntityManagerInterface $em): Response
    {
        $form = $this->createForm(ReclamationType::class, $reclamation);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $em->flush();

            $this->addFlash('success', 'Réclamation mise à jour.');
            return $this->redirectToRoute('reclamation_index');
        }

        return $this->render('reclamation/edit.html.twig', [
            'reclamation' => $reclamation,
            'form' => $form->createView(),
        ]);
    }

    // Route pour supprimer une réclamation
    #[Route('/{id}', name: 'reclamation_delete', methods: ['POST'])]
    public function delete(Request $request, Reclamation $reclamation, EntityManagerInterface $em): Response
    {
        if ($this->isCsrfTokenValid('delete'.$reclamation->getId(), $request->request->get('_token'))) {
            $em->remove($reclamation);
            $em->flush();

            $this->addFlash('success', 'Réclamation supprimée.');
        }

        return $this->redirectToRoute('reclamation_index');
    }

    // Route pour répondre à une réclamation spécifique
    #[Route('/reclamation/{id}/repondre', name: 'reclamation_repondre', methods: ['GET', 'POST'])]
    public function repondre(Request $request, Reclamation $reclamation, EntityManagerInterface $em): Response
    {
        // Crée une nouvelle réponse
        $reponse = new Reponse();
        $reponse->setReclamation($reclamation);
        $reponse->setAuteur($this->getUser()); // Assigner l'auteur de la réponse (l'utilisateur connecté)

        // Créer et gérer le formulaire
        $form = $this->createForm(ReponseType::class, $reponse);
        $form->handleRequest($request);

        // Si le formulaire est soumis et valide
        if ($form->isSubmitted() && $form->isValid()) {
            $em->persist($reponse);
            $em->flush();  // Sauvegarde la réponse dans la base de données

            $this->addFlash('success', 'Votre réponse a été ajoutée avec succès.');

            return $this->redirectToRoute('reclamation_show', ['id' => $reclamation->getId()]);
        }

        // Rendu du formulaire de réponse
        return $this->render('reclamation/repondre.html.twig', [
            'form' => $form->createView(),
            'reclamation' => $reclamation,
        ]);
    }

}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/RegistrationController.php -----
<?php
// src/Controller/RegistrationController.php

namespace App\Controller;

use App\Entity\Utilisateur;
use App\Form\RegistrationFormType;
use App\Security\EmailVerifier; // Import EmailVerifier
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bridge\Twig\Mime\TemplatedEmail; // For email template
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Mime\Address; // For email address
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use Symfony\Component\Routing\Annotation\Route;
// use SymfonyCasts\Bundle\VerifyEmail\Exception\VerifyEmailExceptionInterface; // Import if handling exceptions here

class RegistrationController extends AbstractController
{
    private EmailVerifier $emailVerifier;

    // Inject EmailVerifier
    public function __construct(EmailVerifier $emailVerifier)
    {
        $this->emailVerifier = $emailVerifier;
    }

    #[Route('/inscription', name: 'app_register', methods: ['GET', 'POST'])]
    public function register(Request $request, UserPasswordHasherInterface $passwordHasher, EntityManagerInterface $entityManager): Response
    {
        // Redirect if already logged in
        if ($this->getUser()) {
            return $this->redirectToRoute('app_home'); // Or client dashboard
        }

        $user = new Utilisateur();
        $form = $this->createForm(RegistrationFormType::class, $user);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            // Get plain password from the form
            $plainPassword = $form->get('plainPassword')->getData();

            // Ensure password is not empty (should be caught by constraints, but double-check)
            if (empty($plainPassword)) {
                $this->addFlash('danger', 'Le mot de passe ne peut être vide.');
                return $this->render('registration/register.html.twig', [
                    'registrationForm' => $form->createView(),
                ]);
            }

            // Encode the plain password
            $user->setPassword(
                $passwordHasher->hashPassword(
                    $user,
                    $plainPassword
                )
            );

            // Set default role (e.g., 'client')
            $user->setRoleInterne('client'); // Use the setter for internal role string
            $user->setIsVerified(false); // User starts as unverified
            $user->setIsActive(true); // User starts as active

            // --- REMOVE FACE EMBEDDING LOGIC ---
            // $faceEmbeddingString = $form->get('face_embedding_data')->getData();
            // if (!empty($faceEmbeddingString)) {
            //     $user->setFaceEmbedding($faceEmbeddingString); // Save the embedding string
            // } else {
            //     // This should not happen if JS/validation works, but handle it
            //     $this->addFlash('danger', 'Erreur: Données faciales manquantes après validation.');
            //     return $this->render('registration/register.html.twig', [
            //         'registrationForm' => $form->createView(),
            //     ]);
            // }
            // --- END REMOVAL ---

            $entityManager->persist($user);
            $entityManager->flush();

            // Generate a signed URL and email it to the user
            try {
                $this->emailVerifier->sendEmailConfirmation(
                    'app_verify_email', // Route name of your verification action
                    $user,
                    (new TemplatedEmail())
                        ->from(new Address('mailer@yourdomain.com', 'TrottiCare Mail Bot')) // Change sender
                        ->to(new Address($user->getEmail(), $user->getFullName()))
                        ->subject('Veuillez confirmer votre email pour TrottiCare')
                        ->htmlTemplate('registration/confirmation_email.html.twig') // Path to your email template
                );
                $this->addFlash('success', 'Inscription réussie ! Un email de vérification a été envoyé à ' . $user->getEmail() . '. Veuillez cliquer sur le lien pour activer votre compte.');

            } catch (\Symfony\Component\Mailer\Exception\TransportExceptionInterface $e) {
                $this->addFlash('error', 'Impossible d\'envoyer l\'email de vérification. Erreur: ' . $e->getMessage());
                // Consider logging the error more formally
                // Optionally, you might want to remove the user if email fails critically,
                // or mark them for manual verification.
            }


            // Redirect to login page after sending email
            return $this->redirectToRoute('app_login_page');

        } elseif ($form->isSubmitted()) {
            // Add a generic error if submitted but invalid (specific errors are shown by fields)
            $this->addFlash('danger', 'Le formulaire contient des erreurs. Veuillez vérifier.');
        }

        return $this->render('registration/register.html.twig', [
            'registrationForm' => $form->createView(),
        ]);
    }

    // --- ADD EMAIL VERIFICATION ACTION ---
    // This route needs to be defined (e.g., in routes.yaml or here)
    // Make sure it matches the name used in sendEmailConfirmation ('app_verify_email')
    #[Route('/verify/email', name: 'app_verify_email')]
    public function verifyUserEmail(Request $request, EntityManagerInterface $entityManager): Response // Removed UserRepository, not needed directly here if using VerifyEmailHelper
    {
        // This requires the user to be logged in *before* verifying.
        // If you want verification without login, the approach changes slightly (see bundle docs).
        $this->denyAccessUnlessGranted('IS_AUTHENTICATED_FULLY'); // Ensure user is logged in

        /** @var Utilisateur $user */
        $user = $this->getUser();
        if (!$user) {
            $this->addFlash('danger', 'Utilisateur non trouvé pour la vérification.');
            return $this->redirectToRoute('app_register'); // Or login
        }

        // Validate email confirmation link, sets User::isVerified=true and persists
        try {
            // Use the injected EmailVerifier service
            $this->emailVerifier->handleEmailConfirmation($request, $user); // Pass the user entity
        } catch (\SymfonyCasts\Bundle\VerifyEmail\Exception\VerifyEmailExceptionInterface $exception) {
            $this->addFlash('danger', $exception->getReason()); // Use getReason() for user-friendly messages
            return $this->redirectToRoute('app_register'); // Or login
        }

        // If successful, handleEmailConfirmation already flushes the entity manager

        $this->addFlash('success', 'Votre adresse email a été vérifiée. Vous pouvez maintenant vous connecter.');

        // Redirect to login or maybe client dashboard if you want auto-login after verification
        return $this->redirectToRoute('app_login_page');
    }

}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/ReservationController.php -----
<?php

namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;
use App\Repository\ReservationRepository;
use Symfony\Component\HttpFoundation\Request;
use Doctrine\ORM\EntityManagerInterface;
use App\Entity\Reservation;
use App\Form\ReservationType;
use Symfony\Component\Security\Core\Security;
use Knp\Component\Pager\PaginatorInterface;



#[Route('/admin/reservations')]
final class ReservationController extends AbstractController
{

    private Security $security;
    private EntityManagerInterface $entityManager;

    public function __construct(Security $security, EntityManagerInterface $entityManager)
    {
        $this->security = $security;
        $this->entityManager = $entityManager;
    }

    
        #[Route('/', name: 'reservation_index', methods: ['GET'])]
    public function index(Request $request, ReservationRepository $reservationRepository, PaginatorInterface $paginator): Response
    {
        $criteria = new \App\Dto\ReservationSearchCriteria();
        $form = $this->createForm(\App\Form\ReservationSearchType::class, $criteria);
        $form->handleRequest($request);

        $query = $reservationRepository->findByCriteriaQuery($criteria); // ⚡ Change: we will use a Query, not Result!

        $pagination = $paginator->paginate(
            $query, // query, not results
            $request->query->getInt('page', 1), // page number
            10 // items per page
        );

        return $this->render('reservation/index.html.twig', [
            'pagination' => $pagination,
            'searchForm' => $form->createView(),
        ]);
    }
    #[Route('/stats', name: 'reservation_stats', methods: ['GET'])]
    public function stats(ReservationRepository $reservationRepository): Response
    {
        $stats = $reservationRepository->countByStatus();

        return $this->json($stats);
    }



    #[Route('/new', name: 'reservation_new', methods: ['GET', 'POST'])]
    public function new(Request $request): Response
    {
        // Crée une nouvelle réservation
        $reservation = new Reservation();

        // Récupérer l'utilisateur authentifié
        $utilisateur = $this->security->getUser();
        if ($utilisateur) {
            // Associer l'utilisateur à la réservation
            $reservation->setUtilisateur($utilisateur);
        }

        // Créer le formulaire pour la réservation
        $form = $this->createForm(ReservationType::class, $reservation);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            // Sauvegarder la réservation dans la base de données
            $this->entityManager->persist($reservation);
            $this->entityManager->flush();

            // Ajouter un message flash de succès
            $this->addFlash('success', 'Réservation effectuée avec succès.');

            // Rediriger l'utilisateur vers une autre page après la soumission du formulaire
            return $this->redirectToRoute('reservation_index'); // Ajustez le chemin de redirection
        }

        // Afficher le formulaire
        return $this->render('reservation/new.html.twig', [
            'form' => $form->createView(),
        ]);
    }

#[Route('/{id}', name: 'reservation_show', methods: ['GET'])]
public function show(Reservation $reservation): Response
{
    return $this->render('reservation/show.html.twig', [
        'reservation' => $reservation,
    ]);
}

#[Route('/{id}/edit', name: 'reservation_edit', methods: ['GET', 'POST'])]
public function edit(Request $request, Reservation $reservation, EntityManagerInterface $em): Response
{
    $form = $this->createForm(ReservationType::class, $reservation);
    $form->handleRequest($request);

    if ($form->isSubmitted() && $form->isValid()) {
        $em->flush();

        $this->addFlash('success', 'Réservation mise à jour.');
        return $this->redirectToRoute('reservation_index');
    }

    return $this->render('reservation/edit.html.twig', [
        'reservation' => $reservation,
        'form' => $form->createView(),
    ]);
}

#[Route('/{id}', name: 'reservation_delete', methods: ['POST'])]
public function delete(Request $request, Reservation $reservation, EntityManagerInterface $em): Response
{
    if ($this->isCsrfTokenValid('delete'.$reservation->getId(), $request->request->get('_token'))) {
        $em->remove($reservation);
        $em->flush();

        $this->addFlash('success', 'Réservation supprimée.');
    }

    return $this->redirectToRoute('reservation_index');
}

}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/ChatController.php -----
<?php

namespace App\Controller;


use App\Service\ChatbotService;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class ChatController extends AbstractController
{
    #[Route('/chat', name: 'chat')]
    public function chatPage(): Response
    {
        return $this->render('chat/chat.html.twig');
    }

    #[Route('/chat/message', name: 'chat_message', methods: ['POST'])]
    public function chatMessage(Request $request, ChatbotService $chatbotService): JsonResponse
    {
        $data = json_decode($request->getContent(), true);
        $userMessage = $data['message'] ?? '';

        $botReply = $chatbotService->ask($userMessage);

        return $this->json([
            'reply' => $botReply,
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Public/HomeController.php -----
<?php

namespace App\Controller\Public;

use App\Repository\EventRepository;
use App\Repository\TrottinetteRepository;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;
use Psr\Log\LoggerInterface;

class HomeController extends AbstractController
{
    private LoggerInterface $logger;

    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    #[Route('/', name: 'app_home', methods: ['GET'])]
    public function index(TrottinetteRepository $trottinetteRepository, EventRepository $eventRepository): Response
    {
        $this->logger->info('Public\HomeController::index processing started (No Map).');

        $availableScooters = [];
        $upcomingEvents = [];
        $scootersForView = [];
        $eventsForView = [];

        try {
            // Fetch available scooters
            $availableScooters = $trottinetteRepository->findBy(['etat' => 'DISPONIBLE'], ['dateAjout' => 'DESC'], 8); // Limit to 8 scooters
            $this->logger->info(sprintf('Fetched %d available scooters.', count($availableScooters)));

            // Fetch upcoming events
            if (method_exists($eventRepository, 'findUpcomingEvents')) {
                $upcomingEvents = $eventRepository->findUpcomingEvents(3); // Limit to 3 events
            } else {
                $this->logger->warning('Method findUpcomingEvents not found in EventRepository.');
                $upcomingEvents = $eventRepository->findBy([], ['dateDebut' => 'ASC'], 3);
            }
            $this->logger->info(sprintf('Fetched %d upcoming events.', count($upcomingEvents)));

            // --- Prepare Scooter Card Data ---
            foreach ($availableScooters as $scooter) {
                $scootersForView[] = [
                    'entity' => $scooter,
                    'distanceString' => "Adresse: " . ($scooter->getLocalisation() ?: 'Inconnue'), // Placeholder
                    'pricePerMinute' => "0.15 €/min", // Placeholder
                    'image_url' => null // Add logic if needed
                ];
            }

            // --- Prepare Event Card Data ---
            foreach ($upcomingEvents as $event) {
                $eventsForView[] = [
                    'entity' => $event,
                    // Use state (Gouvernorat) for location if available
                    'location' => $event->getState()?->label() ?? 'Lieu à définir'
                ];
            }

        } catch (\Exception $e) {
            $this->logger->error('Error preparing homepage data: ' . $e->getMessage(), ['exception' => $e]);
            $this->addFlash('error', 'Une erreur est survenue lors du chargement de la page.');
            $scootersForView = [];
            $eventsForView = [];
        }

        // --- Prepare Context for Rendering (NO MAP DATA) ---
        $context = [
            'controller_name' => 'HomeController',
            'scooters' => $scootersForView,
            'upcoming_events' => $eventsForView,
            // 'markersJson' => REMOVED,
            // 'mapCenterLat' => REMOVED,
            // 'mapCenterLng' => REMOVED,
            // 'mapZoom' => REMOVED,
            'heroTitle' => 'Découvrez la ville autrement',
            'heroSubtitle' => 'Louez nos trottinettes électriques facilement. Disponibles 24/7, écologiques et fun !',
        ];

        $this->logger->debug('Rendering public/home/index.html.twig (No Map) with keys: ' . implode(', ', array_keys($context)));

        // --- Render View ---
        return $this->render('public/home/index.html.twig', $context);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Public/RegistrationController.php -----
<?php

namespace App\Controller\Public;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

class RegistrationController extends AbstractController
{
    // TODO: actions
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Public/PublicTrottinetteController.php -----
<?php

namespace App\Controller\Public;

use App\Entity\Trottinette;
use App\Enum\TrottinetteStatus;
use App\Form\PublicTrottinetteFilterType;
use App\Repository\TrottinetteRepository;
use Knp\Component\Pager\PaginatorInterface; // Use KnpPaginator if installed
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route; // Or use Attribute
use Psr\Log\LoggerInterface;

#[Route('/trottinettes')] // Base route for this controller
class PublicTrottinetteController extends AbstractController
{
    private LoggerInterface $logger;
    // Define allowed limits for items per page (can be different from admin)
    private const ALLOWED_LIMITS = [8, 12, 24, 48];
    private const DEFAULT_LIMIT = 12;

    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }



    #[Route('', name: 'public_trottinette_index', methods: ['GET'])]
    public function index(
        Request $request,
        TrottinetteRepository $trottinetteRepository,
        PaginatorInterface $paginator
    ): Response {
        $this->logger->info('Public trottinette index page accessed.');

        $filterForm = $this->createForm(PublicTrottinetteFilterType::class);
        $filterForm->handleRequest($request);

        $criteria = $filterForm->isSubmitted() && $filterForm->isValid()
            ? $filterForm->getData()
            : [ // Use query params as fallback ONLY if form data isn't there
                'search' => $request->query->get('search', ''),
                'status' => $request->query->get('status'), // Changed from 'etat' to match form
                'batterie_min' => $request->query->get('batterie_min'),
                'autonomie_km' => $request->query->get('autonomie_km'), // Use new form field name
            ];

        // --- Pagination Limit Handling ---
        $limit = $request->query->getInt('limit', self::DEFAULT_LIMIT);
        if (!in_array($limit, self::ALLOWED_LIMITS)) {
            $limit = self::DEFAULT_LIMIT;
        }

        // --- Sorting ---
        // (Sorting logic remains the same)
        $allowedSorts = [ /* ... */ ];
        $sortKey = $request->query->get('sort', 'date_desc');
        $sortField = $allowedSorts[$sortKey]['field'] ?? $allowedSorts['date_desc']['field'];
        $sortDirection = $allowedSorts[$sortKey]['direction'] ?? $allowedSorts['date_desc']['direction'];
        // Override with KNP params if present...

        // --- Fetch Paginated Data (Based on DB criteria only) ---
        $pagination = $trottinetteRepository->findFilteredPaginated(
            $criteria, // Pass all criteria, but repo ignores autonomie_km
            $request->query->getInt('page', 1),
            $limit,
            $sortField,
            $sortDirection
        );

        // --- ++ PHP Filtering for Autonomy ++ ---
        $filteredItems = []; // Array to hold items passing PHP filter
        $minAutonomieFilter = isset($criteria['autonomie_km']) && is_numeric($criteria['autonomie_km'])
            ? (int)$criteria['autonomie_km']
            : null;

        if ($minAutonomieFilter !== null) {
            $this->logger->info('Applying PHP filter for minimum autonomy: ' . $minAutonomieFilter);
            foreach ($pagination->getItems() as $trottinette) {
                /** @var Trottinette $trottinette */ // Hint for IDE
                $autonomieString = $trottinette->getAutonomie(); // Get the string value
                $numericAutonomy = null;

                // Extract numeric part (simple extraction)
                if ($autonomieString && preg_match('/^(\d+)/', $autonomieString, $matches)) {
                    $numericAutonomy = (int)$matches[1];
                }

                // Apply the filter
                if ($numericAutonomy !== null && $numericAutonomy >= $minAutonomieFilter) {
                    $filteredItems[] = $trottinette; // Keep if matches
                }
            }
        } else {
            // No autonomy filter applied, use all items from the current page
            $filteredItems = $pagination->getItems();
        }
        // --- ++ END PHP Filtering ++ ---


        // --- Prepare data for scooter cards (Using the FILTERED items) ---
        $scootersForView = [];
        foreach ($filteredItems as $scooter) { // Loop through the filtered array
            $scootersForView[] = [
                'entity' => $scooter,
                'distanceString' => "📍 " . ($scooter->getLocalisation() ?: 'Inconnue'),
                'pricePerMinute' => "0.15 €/min", // Adjust currency/value
                'image_url' => null
            ];
        }

        return $this->render('public/trottinette/index.html.twig', [
            'pagination' => $pagination, // Still pass the original pagination object for controls
            'scooters_data' => $scootersForView, // Pass the PHP-FILTERED items for display
            'filterForm' => $filterForm->createView(),
            'currentLimit' => $limit,
            'allowedLimits' => self::ALLOWED_LIMITS,
            'current_sort' => $sortKey,
            // Note: Add a message in Twig explaining pagination might be inaccurate due to filtering
        ]);
    }
    // You might add a show route here later: #[Route('/{id}', name: 'public_trottinette_show')]
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Public/ResetPasswordController.php -----
<?php
// src/Controller/Public/ResetPasswordController.php
namespace App\Controller\Public;

use App\Entity\Utilisateur;
use App\Form\ChangePasswordFormType;
use App\Form\ResetPasswordRequestFormType;
use App\Repository\UtilisateurRepository;
use Doctrine\ORM\EntityManagerInterface;
use Psr\Log\LoggerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Contracts\HttpClient\HttpClientInterface; // <--- CORRECT NAMESPACE
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Mailer\MailerInterface; // Keep for type hinting if needed elsewhere, but not used for sending here
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface; // <-- Import URL Generator
use Symfony\Contracts\Translation\TranslatorInterface;
use SymfonyCasts\Bundle\ResetPassword\Controller\ResetPasswordControllerTrait;
use SymfonyCasts\Bundle\ResetPassword\Exception\ResetPasswordExceptionInterface;
use SymfonyCasts\Bundle\ResetPassword\ResetPasswordHelperInterface;

#[Route('/reset-password')]
class ResetPasswordController extends AbstractController
{
    use ResetPasswordControllerTrait;

    private ResetPasswordHelperInterface $resetPasswordHelper;
    private EntityManagerInterface $entityManager;
    private HttpClientInterface $httpClient;        // <-- Inject HttpClient
    private UrlGeneratorInterface $urlGenerator;      // <-- Inject UrlGenerator
    private LoggerInterface $logger;

    public function __construct(
        ResetPasswordHelperInterface $resetPasswordHelper,
        EntityManagerInterface $entityManager,
        HttpClientInterface $httpClient,          // <-- Add HttpClient
        UrlGeneratorInterface $urlGenerator,        // <-- Add UrlGenerator
        LoggerInterface $logger
    ) {
        $this->resetPasswordHelper = $resetPasswordHelper;
        $this->entityManager = $entityManager;
        $this->httpClient = $httpClient;          // <-- Assign HttpClient
        $this->urlGenerator = $urlGenerator;        // <-- Assign UrlGenerator
        $this->logger = $logger;
    }

    /**
     * Display & process form to request a password reset.
     */
    #[Route('', name: 'app_forgot_password_request', methods: ['GET', 'POST'])]
    public function request(Request $request, TranslatorInterface $translator): Response
    {

        if ($this->getUser()) {
            return $this->redirectToRoute('app_home');
        }

        $form = $this->createForm(ResetPasswordRequestFormType::class);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            // Call the method that handles token generation and webhook call
            return $this->processSendingPasswordResetWebhook(
                $form->get('email')->getData(),
                $translator
            );
        }

        return $this->render('reset_password/request.html.twig', [
            'requestForm' => $form->createView()
//            'recaptcha_v2_site_key' => $this->getParameter('env(RECAPTCHA_V2_SITE_KEY)'),
        ]);
    }

    /**
     * Confirmation page after a user has requested a password reset.
     */
    #[Route('/check-email', name: 'app_check_email', methods: ['GET'])]
    public function checkEmail(): Response
    {
        // Generate a fake token if the user does not exist or someone hit this page directly.
        if (null === ($resetToken = $this->getTokenObjectFromSession())) {
            $resetToken = $this->resetPasswordHelper->generateFakeResetToken();
        }

        return $this->render('reset_password/check_email.html.twig', [
            'resetToken' => $resetToken,
            'tokenLifetime' => $this->resetPasswordHelper->getTokenLifetime(),
        ]);
    }

    /**
     * Validates and process the reset URL that the user clicked in their email.
     */
    #[Route('/reset/{token}', name: 'app_reset_password', methods: ['GET', 'POST'])]
    public function reset(Request $request, UserPasswordHasherInterface $passwordHasher, TranslatorInterface $translator, string $token = null): Response
    {
        if ($this->getUser()) {
            return $this->redirectToRoute('app_home');
        }

        if ($token) {
            $this->storeTokenInSession($token);
            return $this->redirectToRoute('app_reset_password');
        }

        $token = $this->getTokenFromSession();
        if (null === $token) {
            throw $this->createNotFoundException('No reset password token found in the URL or in the session.');
        }

        try {
            /** @var Utilisateur $user */
            $user = $this->resetPasswordHelper->validateTokenAndFetchUser($token);
        } catch (ResetPasswordExceptionInterface $e) {
            $this->addFlash('reset_password_error', sprintf(
                '%s - %s',
                $translator->trans(ResetPasswordExceptionInterface::MESSAGE_PROBLEM_VALIDATE, [], 'ResetPasswordBundle'),
                $translator->trans($e->getReason(), [], 'ResetPasswordBundle')
            ));
            return $this->redirectToRoute('app_forgot_password_request');
        }

        // The token is valid; allow the user to change their password.
        $form = $this->createForm(ChangePasswordFormType::class);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->resetPasswordHelper->removeResetRequest($token);
            $encodedPassword = $passwordHasher->hashPassword($user, $form->get('plainPassword')->getData());
            $user->setPassword($encodedPassword);
            $this->entityManager->flush();
            $this->cleanSessionAfterReset();

            $this->addFlash('success', 'Votre mot de passe a été réinitialisé avec succès.');
            return $this->redirectToRoute('app_login_page');
        }

        return $this->render('reset_password/reset.html.twig', [
            'resetForm' => $form->createView(),
        ]);
    }

    /**
     * Processes the request and triggers the Maker Webhook directly.
     */
    private function processSendingPasswordResetWebhook(string $emailFormData, TranslatorInterface $translator): RedirectResponse
    {
        /** @var UtilisateurRepository $userRepository */
        $userRepository = $this->entityManager->getRepository(Utilisateur::class);
        /** @var Utilisateur|null $user */
        $user = $userRepository->findOneBy(['email' => $emailFormData]);

        // Do not reveal whether a user account was found or not.
        if (!$user) {
            $this->logger->info('Password reset requested for non-existent email: ' . $emailFormData);
            return $this->redirectToRoute('app_check_email');
        }

        // Prevent reset for inactive or unverified users
        if (!$user->isActive() || !$user->isVerified()) {
            $this->logger->warning('Password reset requested for inactive/unverified user: ' . $emailFormData);
            $this->addFlash('reset_password_error', 'Impossible de réinitialiser le mot de passe pour ce compte (inactif ou non vérifié).');
            return $this->redirectToRoute('app_check_email');
        }

        try {
            $resetToken = $this->resetPasswordHelper->generateResetToken($user);
        } catch (ResetPasswordExceptionInterface $e) {
            $this->logger->error('Error generating password reset token: ' . $e->getReason());
            $this->addFlash('reset_password_error', sprintf(
                '%s - %s',
                $translator->trans(ResetPasswordExceptionInterface::MESSAGE_PROBLEM_HANDLE, [], 'ResetPasswordBundle'),
                $translator->trans($e->getReason(), [], 'ResetPasswordBundle')
            ));
            return $this->redirectToRoute('app_check_email');
        }

        // --- Trigger Maker Webhook ---
        $makerWebhookUrl = "https://hook.eu2.make.com/5eelpvj9qe47sljh99bfollai01xg1ex"; // Get URL from .env
        if (empty($makerWebhookUrl)) {
            $this->logger->error('MAKER_WEBHOOK_URL environment variable is not set.');
            $this->addFlash('danger', 'Erreur de configuration serveur, impossible d\'envoyer l\'email de réinitialisation.');
            return $this->redirectToRoute('app_forgot_password_request'); // Go back to request page on config error
        }

        // Generate the ABSOLUTE reset URL using the injected UrlGenerator
        $resetUrl = $this->urlGenerator->generate('app_reset_password', [
            'token' => $resetToken->getToken(),
        ], UrlGeneratorInterface::ABSOLUTE_URL);

        // Prepare payload for Maker Webhook (adjust keys based on your Maker service)
        $payload = [
            'value1' => $user->getEmail(),       // e.g., Recipient email
            'value2' => $user->getPrenom() ?? $user->getEmail(), // e.g., User's name
            'value3' => $resetUrl,              // e.g., The reset link
            // You could add more values if your Maker service needs them
            // 'value4' => ceil($this->resetPasswordHelper->getTokenLifetime() / 3600) // e.g., lifetime in hours
        ];

        try {
            // Use the injected httpClient to make the request
            $response = $this->httpClient->request('POST', $makerWebhookUrl, [
                'json' => $payload, // Sending as JSON is common
                // Or use 'body' => $payload for form-encoded
            ]);

            // Check webhook response status (optional but good for debugging)
            if ($response->getStatusCode() >= 300) {
                $this->logger->error(sprintf('Maker Webhook call failed for user %s. Status: %d, Response: %s', $user->getEmail(), $response->getStatusCode(), $response->getContent(false)));
                // Decide if you want to show an error or still proceed
                // For a simple project, maybe just log it and proceed
                // $this->addFlash('danger', 'Erreur lors de la communication avec le service d\'envoi.');
                // return $this->redirectToRoute('app_forgot_password_request');
            } else {
                $this->logger->info(sprintf('Maker Webhook triggered successfully for user %s.', $user->getEmail()));
            }

        } catch (\Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface $e) {
            $this->logger->error('Maker Webhook transport error: ' . $e->getMessage());
            // Decide if you want to show an error or still proceed
            // $this->addFlash('danger', 'Erreur réseau lors de la tentative d\'envoi.');
            // return $this->redirectToRoute('app_forgot_password_request');
        } catch (\Exception $e) { // Catch other potential errors
            $this->logger->error('Error triggering Maker Webhook: ' . $e->getMessage());
            // $this->addFlash('danger', 'Une erreur inattendue est survenue.');
            // return $this->redirectToRoute('app_forgot_password_request');
        }

        // --- END Trigger Maker Webhook ---

        // Store token in session REGARDLESS of webhook success/failure for this simplified approach
        // The user needs to be able to reset password even if email sending fails sometimes
        $this->setTokenObjectInSession($resetToken);

        // Redirect to the check-email page
        return $this->redirectToRoute('app_check_email');
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Partenaire/TrottinetteController.php -----
<?php

namespace App\Controller\Partenaire;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

class TrottinetteController extends AbstractController
{
    // TODO: actions
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Partenaire/DashboardController.php -----
<?php
// src/Controller/Partenaire/DashboardController.php
namespace App\Controller\Partenaire;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Http\Attribute\IsGranted;
// You might inject repositories here later if you need stats
 use App\Repository\TrottinetteRepository;
 use App\Repository\EventRepository;

#[Route('/partenaire')]
// IMPORTANT: Apply security HERE at the controller level, not on individual links in Twig
#[IsGranted('ROLE_PARTENAIRE')]
class DashboardController extends AbstractController
{
    #[Route('/dashboard', name: 'app_partenaire_dashboard')]
    public function index(
        // Inject repositories if needed for stats later
         TrottinetteRepository $trottinetteRepository,
         EventRepository $eventRepository
    ): Response
    {
        $partenaire = $this->getUser(); // Get the logged-in partner

        // Example: Fetch stats later
         $trottinettesCount = $trottinetteRepository->count(['utilisateur' => $partenaire]);
//         $eventsCount = $eventRepository->count(['organisateur' => $partenaire]); // Assuming an 'organisateur' field

        return $this->render('partenaire/dashboard/index.html.twig', [
            'controller_name' => 'PartenaireDashboardController',
            'partenaire' => $partenaire,
            // Pass stats later:
             'trottinettes_count' => $trottinettesCount,
//             'events_count' => $eventsCount,
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Partenaire/MaintenanceController.php -----
<?php

namespace App\Controller\Partenaire;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

class MaintenanceController extends AbstractController
{
    // TODO: actions
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/PointRelaisController.php -----
<?php

namespace App\Controller;

use App\Entity\PointRelais;
use App\Form\PointRelaisType;
use App\Repository\PointRelaisRepository;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

#[Route('/admin/point-relais')]
final class PointRelaisController extends AbstractController
{
    #[Route('/', name: 'point_relais_index', methods: ['GET'])]
    public function index(PointRelaisRepository $pointRelaisRepository): Response
    {
        return $this->render('point_relais/index.html.twig', [
            'point_relais' => $pointRelaisRepository->findAll(),
        ]);
    }

    #[Route('/new', name: 'point_relais_new', methods: ['GET', 'POST'])]
    public function new(Request $request, EntityManagerInterface $em): Response
    {
        $pointRelais = new PointRelais();
        $form = $this->createForm(PointRelaisType::class, $pointRelais);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $em->persist($pointRelais);
            $em->flush();

            $this->addFlash('success', 'Point relais créé avec succès.');
            return $this->redirectToRoute('point_relais_index');
        }
        if ($form->isSubmitted() && !$form->isValid()) {
            $this->addFlash('danger', 'Le formulaire contient des erreurs. Veuillez corriger les champs.');
        }

        return $this->render('point_relais/new.html.twig', [
            'form' => $form->createView(),
        ]);
    }

    #[Route('/{id}', name: 'point_relais_show', methods: ['GET'])]
    public function show(PointRelais $pointRelais): Response
    {
        return $this->render('point_relais/show.html.twig', [
            'point_relais' => $pointRelais,
        ]);
    }

    #[Route('/{id}/edit', name: 'point_relais_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, PointRelais $pointRelais, EntityManagerInterface $em): Response
    {
        $form = $this->createForm(PointRelaisType::class, $pointRelais);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $em->flush();
            $this->addFlash('success', 'Point relais mis à jour avec succès.');

            return $this->redirectToRoute('point_relais_index');
        }
        if ($form->isSubmitted() && !$form->isValid()) {
            $this->addFlash('danger', 'Le formulaire contient des erreurs. Veuillez corriger les champs.');
        }
        
        return $this->render('point_relais/edit.html.twig', [
            'form' => $form->createView(),
            'point_relais' => $pointRelais,
        ]);
    }

    #[Route('/{id}', name: 'point_relais_delete', methods: ['POST'])]
    public function delete(Request $request, PointRelais $pointRelais, EntityManagerInterface $em): Response
    {
        if ($this->isCsrfTokenValid('delete' . $pointRelais->getId(), $request->request->get('_token'))) {
            $em->remove($pointRelais);
            $em->flush();
            $this->addFlash('success', 'Point relais supprimé.');
        }

        return $this->redirectToRoute('point_relais_index');
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/ReclamationController.php -----
<?php

namespace App\Controller;

use App\Entity\Reclamation;
use App\Entity\Reponse;
use App\Form\AdminReclamationType;
use App\Form\ReclamationSearchType;

use App\Form\ReclamationType;
use App\Form\ReponseType;
use App\Repository\ReclamationRepository;
use App\Repository\ReponseRepository;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Mailer\MailerInterface;
use Symfony\Component\Mime\Email;
use App\Dto\ReclamationSearchCriteria;
use App\Service\SmsService;


class ReclamationController extends AbstractController
{
    private EntityManagerInterface $entityManager;

    public function __construct(EntityManagerInterface $entityManager)
    {
        $this->entityManager = $entityManager;
    }

    // ========== FRONT OFFICE ==========
    
    #[Route('/', name: 'app_home')]
    public function index(): Response
    {
        return $this->render('index.html.twig');
    }

    #[Route('/reclamations/create', name: 'create_reclamation')]
    public function createReclamation(Request $request, MailerInterface $mailer, SmsService $smsService): Response
    {
        $reclamation = new Reclamation();
        $form = $this->createForm(ReclamationType::class, $reclamation);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->persist($reclamation);
            $this->entityManager->flush();

            // Send confirmation email
            $email = (new Email())
                ->from('aymen.labidi@esprit.tn')
                ->to($reclamation->getUserEmail())
                ->subject('Confirmation de votre réclamation')
                ->html("
                    <p>Nous avons bien reçu votre réclamation concernant : <strong>{$reclamation->getTitre()}</strong>.</p>
                    <p>Nous allons la traiter dans les plus brefs délais.</p>
                    <p>Merci de faire confiance à TrottiCare !</p>
                ");

            try {
                $mailer->send($email);
            } catch (\Exception $e) {
                $this->addFlash('error', 'Erreur lors de l\'envoi de l\'email: ' . $e->getMessage());
            }

            // Send SMS notification
            $smsMessage = "TrottiCare: Votre réclamation '{$reclamation->getTitre()}' a été reçue. Nous la traiterons bientôt.";
            $smsSent = $smsService->sendSms(+21652344512, $smsMessage);

            if (!$smsSent) {
                $this->addFlash('error', 'Erreur lors de l\'envoi du SMS de confirmation.');
            }

            $this->addFlash('success', 'Réclamation créée avec succès.');
            return $this->redirectToRoute('reclamation_list');
        }

        return $this->render('reclamation/create_reclamation.html.twig', [
            'form' => $form->createView(),
        ]);
    }

    #[Route('/reclamations', name: 'reclamation_list')]
    public function listReclamations(Request $request,ReclamationRepository $repository): Response
    {
        $criteria = new ReclamationSearchCriteria();
        $form = $this->createForm(ReclamationSearchType::class, $criteria);
        $form->handleRequest($request);

        $reclamations = $repository->findByCriteriaQuery($criteria)->getResult();

        return $this->render('reclamation/list_reclamations.html.twig', [
            'reclamations' => $reclamations,
            'searchForm' => $form->createView(),
        ]);
    }

    #[Route('/reclamations/{id<\d+>}', name: 'show_reclamation')]
    public function showReclamation(int $id, ReclamationRepository $reclamationRepository): Response
    {
        $reclamation = $reclamationRepository->find($id);

        if (!$reclamation) {
            $this->addFlash('error', 'Réclamation introuvable.');
            return $this->redirectToRoute('reclamation_list');
        }

        return $this->render('reclamation/show_reclamation.html.twig', [
            'reclamation' => $reclamation,
            'reponses' => $reclamation->getReponses(),
        ]);
    }


    #[Route('/reclamation/{id}/edit', name: 'edit_reclamation_front')]
    public function editReclamationFront(int $id, ReclamationRepository $reclamationRepository, Request $request): Response
    {
        $reclamation = $reclamationRepository->find($id);

        if (!$reclamation) {
            $this->addFlash('error', 'Réclamation introuvable.');
            return $this->redirectToRoute('reclamation_list');
        }

        $form = $this->createForm(ReclamationType::class, $reclamation);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->flush();
            $this->addFlash('success', 'Réclamation modifiée avec succès.');
            return $this->redirectToRoute('reclamation_list');
        }

        return $this->render('edit_reclamation.html.twig', [
            'form' => $form->createView(),
            'reclamation' => $reclamation,
        ]);
    }

    #[Route('/reclamation/{id}/delete', name: 'delete_reclamation_front')]
    public function deleteReclamationFront(int $id, ReclamationRepository $reclamationRepository): Response
    {
        $reclamation = $reclamationRepository->find($id);

        if (!$reclamation) {
            $this->addFlash('error', 'Réclamation introuvable.');
            return $this->redirectToRoute('reclamation_list');
        }

        $this->entityManager->remove($reclamation);
        $this->entityManager->flush();

        $this->addFlash('success', 'Réclamation supprimée avec succès.');
        return $this->redirectToRoute('reclamation_list');
    }

    // ========== ADMIN OFFICE ==========



    #[Route('/admin/reclamations', name: 'admin_reclamations')]
    public function manageReclamations(ReclamationRepository $reclamationRepository): Response
    {
        $reclamations = $reclamationRepository->findAll();
        return $this->render('reclamation/manage_reclamations.html.twig', [
            'reclamations' => $reclamations
        ]);
    }

    #[Route('/admin/reclamation/{id}/edit', name: 'edit_reclamation')]
    public function editReclamationAdmin(int $id, ReclamationRepository $reclamationRepository, Request $request): Response
    {
        $reclamation = $reclamationRepository->find($id);

        if (!$reclamation) {
            $this->addFlash('error', 'Réclamation non trouvée.');
            return $this->redirectToRoute('admin_reclamations');
        }

        $form = $this->createForm(AdminReclamationType::class, $reclamation);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->flush();
            $this->addFlash('success', 'Réclamation modifiée avec succès.');
            return $this->redirectToRoute('admin_reclamations');
        }

        return $this->render('edit_reclamation.html.twig', [
            'form' => $form->createView(),
            'reclamation' => $reclamation,
        ]);
    }

    #[Route('/admin/reclamation/{id}/delete', name: 'delete_reclamation')]
    public function deleteReclamationAdmin(int $id, ReclamationRepository $reclamationRepository): Response
    {
        $reclamation = $reclamationRepository->find($id);

        if (!$reclamation) {
            $this->addFlash('error', 'Réclamation non trouvée.');
            return $this->redirectToRoute('admin_reclamations');
        }

        $this->entityManager->remove($reclamation);
        $this->entityManager->flush();

        $this->addFlash('success', 'Réclamation supprimée avec succès.');
        return $this->redirectToRoute('admin_reclamations');
    }

    #[Route('/admin/reclamation/{id}/add_response', name: 'add_response')]
    public function addResponse(int $id, Request $request, ReclamationRepository $reclamationRepository, SmsService $smsService): Response
    {
        $reclamation = $reclamationRepository->find($id);

        if (!$reclamation) {
            $this->addFlash('error', 'Réclamation non trouvée.');
            return $this->redirectToRoute('admin_reclamations');
        }

        $response = new Reponse();
        $form = $this->createForm(ReponseType::class, $response);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $response->setReclamation($reclamation);
            $response->setDateReponse(new \DateTime());

            $this->entityManager->persist($response);
            $this->entityManager->flush();

            $this->addFlash('success', 'Réponse ajoutée avec succès.');

                 // Send SMS notification
                 $smsMessage = "TrottiCare: Votre réclamation '{$reclamation->getTitre()}' a été trtaite.";
                 $smsSent = $smsService->sendSms(+21652344512, $smsMessage);
     
                 if (!$smsSent) {
                     $this->addFlash('error', 'Erreur lors de l\'envoi du SMS de confirmation.');
                 }
     
                 $this->addFlash('success', 'Réclamation créée avec succès.');
            return $this->redirectToRoute('admin_reclamations');
        }

        return $this->render('reclamation/add_response.html.twig', [
            'form' => $form->createView(),
            'reclamation' => $reclamation
        ]);
    }

    #[Route('/admin/reclamation/{id}/responses', name: 'view_responses')]
    public function viewResponses(int $id, ReclamationRepository $reclamationRepository, ReponseRepository $reponseRepository): Response
    {
        $reclamation = $reclamationRepository->find($id);

        if (!$reclamation) {
            $this->addFlash('error', 'Réclamation non trouvée.');
            return $this->redirectToRoute('admin_reclamations');
        }

        $responses = $reponseRepository->findBy(['reclamation' => $reclamation]);

        return $this->render('reclamation/view_responses.html.twig', [
            'reclamation' => $reclamation,
            'responses' => $responses
        ]);
    }

    #[Route('/admin/response/{id}/edit', name: 'edit_response')]
    public function editResponse(int $id, Request $request, ReponseRepository $reponseRepository): Response
    {
        $response = $reponseRepository->find($id);

        if (!$response) {
            $this->addFlash('error', 'Réponse non trouvée.');
            return $this->redirectToRoute('admin_reclamations');
        }

        $form = $this->createForm(ReponseType::class, $response);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->flush();
            $this->addFlash('success', 'Réponse modifiée avec succès.');

            return $this->redirectToRoute('view_responses', [
                'id' => $response->getReclamation()->getId()
            ]);
        }

        return $this->render('reclamation/edit_response.html.twig', [
            'form' => $form->createView(),
            'response' => $response
        ]);
    }

    #[Route('/admin/response/{id}/delete', name: 'delete_response')]
    public function deleteResponse(int $id, ReponseRepository $reponseRepository): Response
    {
        $response = $reponseRepository->find($id);

        if (!$response) {
            $this->addFlash('error', 'Réponse non trouvée.');
            return $this->redirectToRoute('admin_reclamations');
        }

        $reclamationId = $response->getReclamation()->getId();

        $this->entityManager->remove($response);
        $this->entityManager->flush();

        $this->addFlash('success', 'Réponse supprimée avec succès.');
        return $this->redirectToRoute('view_responses', [
            'id' => $reclamationId
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/PublicEventController.php -----
<?php
// src/Controller/PublicEventController.php
namespace App\Controller; // Adjust namespace if needed (e.g., App\Controller\Public)

use App\Entity\Event;
use App\Entity\Utilisateur;
use App\Enum\ParticipationStatus;
use App\Repository\EventRepository;
use App\Repository\ParticipationRepository; // Optional: If checking participation status
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route; // Or use Attribute if PHP 8+
use Psr\Log\LoggerInterface;
use Symfony\Component\Security\Http\Attribute\IsGranted; // For security attribute
use Knp\Snappy\Pdf; // Import Snappy's PDF service
use Endroid\QrCodeBundle\Response\QrCodeResponse; // Or use the generator interface
use Endroid\QrCode\Builder\BuilderInterface; // Use the Builder for more control
use Endroid\QrCode\Encoding\Encoding;
use Endroid\QrCode\ErrorCorrectionLevel;
use Endroid\QrCode\Writer\PngWriter;

#[Route('/events')] // Base route for event actions
class PublicEventController extends AbstractController
{
    private LoggerInterface $logger;
    private EventRepository $eventRepository;
    private ParticipationRepository $participationRepository; // Optional
    // Inject BuilderInterface for QR codes and Pdf for Snappy
    private BuilderInterface $qrCodeBuilder;
    private Pdf $snappyPdf;

    public function __construct(
        LoggerInterface $logger,
        EventRepository $eventRepository,
        ParticipationRepository $participationRepository,
        BuilderInterface $qrCodeBuilder, // Inject QR Code Builder
        Pdf $snappyPdf // Inject Snappy PDF Service
    ) {
        $this->logger = $logger;
        $this->eventRepository = $eventRepository;
        $this->participationRepository = $participationRepository;
        $this->qrCodeBuilder = $qrCodeBuilder;
        $this->snappyPdf = $snappyPdf;
    }

    #[Route('', name: 'public_event_index', methods: ['GET'])]
    public function index(Request $request): Response
    {
        $this->logger->info('Public event index page accessed.');

        // --- Filtering Logic (Example) ---
        $filter = $request->query->get('filter', 'all'); // 'all', 'upcoming', 'past'
        $search = $request->query->get('search', '');

        // ... (QueryBuilder logic remains the same) ...
        $queryBuilder = $this->eventRepository->createQueryBuilder('e')
            ->orderBy('e.dateDebut', 'DESC');

        if ($filter === 'upcoming') {
            $queryBuilder->andWhere('e.dateDebut >= :now')->setParameter('now', new \DateTimeImmutable());
        } elseif ($filter === 'past') {
            $queryBuilder->andWhere('e.dateDebut < :now')->setParameter('now', new \DateTimeImmutable());
        }

        if (!empty($search)) {
            $queryBuilder->andWhere(
                $queryBuilder->expr()->orX(
                    $queryBuilder->expr()->like('LOWER(e.titre)', ':search'),
                    $queryBuilder->expr()->like('LOWER(e.description)', ':search'),
                    // Assuming state holds GouvernoratEnum which stringifies to its value
                    $queryBuilder->expr()->like('LOWER(e.state)', ':search')
                )
            )->setParameter('search', '%' . mb_strtolower($search) . '%');
        }
        $events = $queryBuilder->getQuery()->getResult();
        // ...

        // --- Optional: Check participation status ---
        $userParticipations = [];
        // ... (participation check logic remains the same) ...

        // Prepare data for view
        $eventsForView = [];
        foreach($events as $event) {
            // ... (duration calculation and array creation remains the same) ...
            $duration = null;
            if ($event->getDateDebut() && $event->getDateFin()) {
                $diff = $event->getDateFin()->diff($event->getDateDebut());
                $duration = sprintf('%dh %02dmin', $diff->h + ($diff->days * 24), $diff->i);
            }
            $eventsForView[] = [
                'entity' => $event,
                'duration' => $duration,
                'user_participation_status' => $userParticipations[$event->getId()] ?? null
            ];
        }

        // --- **THE FIX IS HERE** ---
        // Ensure 'current_filter' is included in the context array passed to render
        return $this->render('public/event/index.html.twig', [
            'events_data' => $eventsForView,
            'current_filter' => $filter, // <-- PASS THE VARIABLE HERE
            'search_term' => $search,
        ]);
    }


    #[Route('/{id}', name: 'public_event_show', requirements: ['id' => '\d+'], methods: ['GET'])]
    public function show(int $id): Response
    {
        $event = $this->eventRepository->find($id);
        if (!$event) {
            $this->logger->warning(sprintf('Event with ID %d not found.', $id));
            throw $this->createNotFoundException('L\'événement demandé n\'existe pas.');
        }
        $this->logger->info(sprintf('Showing details for event ID %d: "%s".', $id, $event->getTitre()));

        $duration = null;
        if ($event->getDateDebut() && $event->getDateFin()) {
            try {
                $diff = $event->getDateFin()->diff($event->getDateDebut());
                $duration = sprintf('%dh %02dmin', $diff->h + ($diff->days * 24), $diff->i);
            } catch (\Exception $e) {
                $this->logger->error(sprintf('Error calculating duration for event ID %d: %s', $id, $e->getMessage()));
            }
        }

        $userParticipationStatus = null;
        $participation = null; // Keep track of the participation entity if found
        $user = $this->getUser();
        if ($user instanceof Utilisateur) { // Use your specific User entity class
            $participation = $this->participationRepository->findOneByUserAndEvent($user,$event);
            $userParticipationStatus = $participation?->getStatut(); // Get the Enum object or null
            $this->logger->debug(sprintf('User %d participation status for event %d: %s', $user->getId(), $id, $userParticipationStatus?->value ?? 'null'));
        }

        return $this->render('public/event/show.html.twig', [
            'event' => $event,
            'duration' => $duration,
            'user_participation_status' => $userParticipationStatus, // Pass the Enum object or null
            'participation' => $participation // Pass the participation entity itself (needed for ticket ID)
        ]);
    }

    // --- NEW ACTION FOR DOWNLOADING TICKET ---
    #[Route('/{id}/ticket', name: 'public_event_download_ticket', methods: ['GET'])]
    #[IsGranted('ROLE_USER')] // Ensure user is logged in
    public function downloadTicket(Event $event): Response // Use ParamConverter for Event
    {
        $user = $this->getUser();
        if (!$user instanceof Utilisateur) {
            // Should not happen due to IsGranted, but good practice
            $this->logger->warning('Attempted ticket download without valid user.');
            throw $this->createAccessDeniedException('Vous devez être connecté pour télécharger un billet.');
        }

        // Find the specific *active* participation record
        $participation = $this->participationRepository->findOneBy([
            'event' => $event,
            'utilisateur' => $user,
            'statut' => ParticipationStatus::INSCRIT // Only allow download for INSCRIT status
        ]);

        if (!$participation) {
            $this->logger->warning(sprintf('User %d tried to download ticket for event %d without active participation.', $user->getId(), $event->getId()));
            throw $this->createNotFoundException('Participation non trouvée ou inactive pour cet événement.'); // Or AccessDenied
        }

        // --- Generate QR Code ---
        // Define the data for the QR code (make it unique and verifiable)
        $qrData = json_encode([
            'type' => 'event_ticket',
            'participation_id' => $participation->getId(),
            'event_id' => $event->getId(),
            'user_id' => $user->getId(),
            'timestamp' => time(), // Optional: add timestamp
        ]);

        try {

            $qrCodeResult = $this->qrCodeBuilder->build(
                writer: new PngWriter(),
                data: $qrData,
                encoding: new Encoding('UTF-8'),
                errorCorrectionLevel: ErrorCorrectionLevel::High,
                size: 150,
                // only needed if you want to override the writer configured
                // in your endroid_qr_code.yaml:
                margin: 10
            );

            // Build the result object



            // Get QR code as a base64 encoded data URI string to embed in HTML/Twig
            $qrCodeBase64 = $qrCodeResult->getDataUri();

        } catch (\Exception $e) {
            dd($e->getMessage());
            $this->logger->error('QR Code generation failed: ' . $e->getMessage());
            // Handle error appropriately - maybe show an error page or default PDF
            throw new \RuntimeException('Impossible de générer le code QR pour le billet.');
        }

        // --- Render HTML for PDF ---
        $html = $this->renderView('public/event/ticket_pdf.html.twig', [
            'event' => $event,
            'user' => $user,
            'participation' => $participation,
            'qrCodeBase64' => $qrCodeBase64, // Pass the base64 string
        ]);

        // --- Generate PDF using Snappy ---
        $filename = sprintf('billet-event-%d-user-%d.pdf', $event->getId(), $user->getId());

        try {
            return new Response(
                $this->snappyPdf->getOutputFromHtml($html),
                Response::HTTP_OK, // 200 status code
                [
                    'Content-Type'        => 'application/pdf',
                    // 'inline' displays in browser, 'attachment' forces download
                    'Content-Disposition' => sprintf('inline; filename="%s"', $filename),
                ]
            );
        } catch (\Exception $e) {
            dd($e);
            $this->logger->error('PDF generation failed: ' . $e->getMessage(), ['exception' => $e]);
            // Provide a user-friendly error response
            return new Response('Impossible de générer le billet PDF. Veuillez réessayer plus tard.', Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }
    // --- Add Participation/Cancel Logic (Requires login, CSRF protection recommended) ---
    // #[Route('/{id}/participate', name: 'public_event_participate', methods: ['POST'])]
    // #[IsGranted('ROLE_USER')]
    // public function participate(...) { ... }

    // #[Route('/{id}/cancel-participation', name: 'public_event_cancel_participation', methods: ['POST'])]
    // #[IsGranted('ROLE_USER')]
    // public function cancelParticipation(...) { ... }
    // --- Add Participation/Cancel Logic (Requires login) ---
    // #[Route('/{id}/participate', name: 'public_event_participate', methods: ['POST'])]
    // #[IsGranted('ROLE_USER')] // Make sure users are logged in
    // public function participate(Request $request, Event $event, EntityManagerInterface $em): Response { ... }

    // #[Route('/{id}/cancel-participation', name: 'public_event_cancel_participation', methods: ['POST'])]
    // #[IsGranted('ROLE_USER')]
    // public function cancelParticipation(Request $request, Event $event, EntityManagerInterface $em): Response { ... }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Client/EventController.php -----
<?php

namespace App\Controller\Client;

use App\Entity\Event;
use App\Entity\Participation;
use App\Entity\Utilisateur;
use App\Enum\ParticipationStatus;
use App\Form\EventType;
use App\Repository\EventRepository;
use App\Repository\ParticipationRepository; // Make sure this is injected
use App\Repository\UtilisateurRepository;
use Doctrine\ORM\EntityManagerInterface;
use Knp\Component\Pager\PaginatorInterface;
use Psr\Log\LoggerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Mailer\Exception\TransportExceptionInterface;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\HttpFoundation\RedirectResponse; // Added for redirects
use Symfony\Component\Mailer\MailerInterface;        // ← import this
use Symfony\Component\Mime\Email;                    // ← and this
use Symfony\Contracts\HttpClient\HttpClientInterface;
use Endroid\QrCode\Builder\BuilderInterface; // QR Code Builder
use Endroid\QrCode\Encoding\Encoding;
use Endroid\QrCode\ErrorCorrectionLevel;
use Endroid\QrCode\Writer\PngWriter;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface; // URL Generator

#[Route('/client/event')]
class EventController extends AbstractController
{
    // Inject ParticipationRepository in the constructor if it's used in multiple methods often
    private ParticipationRepository $participationRepository;
    private EntityManagerInterface $entityManager;
    private HttpClientInterface $client;
    private EventRepository $eventRepository; // Add repository property if used elsewhere
    private BuilderInterface $qrCodeBuilder; // Inject QR Code Builder
    private UrlGeneratorInterface $urlGenerator; // Inject URL Generator
    // Define allowed limits for pagination selector
    // Define allowed limits for pagination selector
    private const ALLOWED_LIMITS = [6, 12, 24];
    private const DEFAULT_LIMIT = 12;

    // Define allowed sort fields mapping user-friendly key to DQL path
    // Make this public or accessible to the repository if needed there too
    public const ALLOWED_SORT_FIELDS = [
        'dateDebut' => 'e.dateDebut',
        'dateFin' => 'e.dateFin',
        'autonomie' => 'e.trottinetteMinAutonomie',
        'titre' => 'e.titre',
        // 'participants' => 'participantCount' // Uncomment if sorting by count needed
    ];
    private const DEFAULT_SORT_FIELD = 'dateDebut'; // Default field KEY

    private const ALLOWED_DIRECTIONS = ['asc', 'desc'];
    private const DEFAULT_DIRECTION = 'desc';


    public function __construct(
        ParticipationRepository $participationRepository,
        EntityManagerInterface $entityManager,
        HttpClientInterface $client,
        EventRepository $eventRepository,
        BuilderInterface $qrCodeBuilder,
        UrlGeneratorInterface $urlGenerator,
        LoggerInterface $logger
    ) {
        $this->participationRepository = $participationRepository;
        $this->entityManager = $entityManager;
        $this->client = $client;
        $this->eventRepository = $eventRepository;
        $this->qrCodeBuilder = $qrCodeBuilder;
        $this->urlGenerator = $urlGenerator;
        $this->logger = $logger;
    }

    #[Route('/', name: 'client_event_index', methods: ['GET'])]
    public function index(
        Request $request,
        PaginatorInterface $paginator
    ): Response {
        // Inject LoggerInterface $logger in constructor if not already done

        $this->logger->info('Client event index accessed.');

//        dd($request->query->get('search', 1));
        /* ---------- Filters & Limit -------------------- */
        $search = trim((string)$request->query->get('search', ''));
        $filter = $request->query->get('filter', 'all');
        $page = max(1, (int)$request->query->get('page', 1));
        $limit = max(1, (int)$request->query->getInt('limit', self::DEFAULT_LIMIT));
        if (!in_array($limit, self::ALLOWED_LIMITS)) {
            $limit = self::DEFAULT_LIMIT;
        }

        /* ---------- Sorting Logic ------------------------------- */
        // ... (Sorting logic remains the same - assuming it works now) ...
        $defaultDqlSortField = self::ALLOWED_SORT_FIELDS[self::DEFAULT_SORT_FIELD];
        $requestedDqlSort = $request->query->get('sort');
        $allowedDqlPaths = array_values(self::ALLOWED_SORT_FIELDS);
        if ($requestedDqlSort !== null && in_array($requestedDqlSort, $allowedDqlPaths, true)) {
            $dqlSortField = $requestedDqlSort;
        } else {
            if ($requestedDqlSort !== null) { $this->logger->warning("Invalid sort field requested: {$requestedDqlSort}. Falling back to default."); }
            $dqlSortField = $defaultDqlSortField;
        }
        $sortDirection = strtolower($request->query->get('direction', self::DEFAULT_DIRECTION));
        if (!in_array($sortDirection, self::ALLOWED_DIRECTIONS)) {
            $this->logger->warning("Invalid sort direction requested: {$sortDirection}. Falling back to default.");
            $sortDirection = self::DEFAULT_DIRECTION;
        }
        /* ---------- End Sorting Logic ----------------------------------- */


        /* ---------- Query Builder Setup ---------- */
        $qb = $this->eventRepository->createQueryBuilder('e')
            ->leftJoin('e.participations', 'p')
            ->addSelect('p');

        // Apply Search filter
        if ($search !== '') {
            // +++ LOGGING +++
            $this->logger->info("Applying search filter with term: '{$search}'");
            $searchTerm = '%' . mb_strtolower($search) . '%';
            $qb->andWhere(
                $qb->expr()->orX(
                    'LOWER(e.titre)       LIKE :q',
                    'LOWER(e.description) LIKE :q',
                // --- Temporarily Commented Out State Search ---
                 'LOWER(e.state)       LIKE :q'
                // --- If search works now, the state field is the issue ---
                )
            )->setParameter('q', $searchTerm);
        } else {
            $this->logger->info("No search term provided.");
        }


        // Apply Date Filter
        $now = new \DateTimeImmutable();
        switch ($filter) {
            case 'upcoming': $qb->andWhere('e.dateDebut >= :now')->setParameter('now', $now); break;
            case 'past':     $qb->andWhere('e.dateDebut < :now')->setParameter('now', $now); break;
        }

        // +++ DEBUGGING: Log DQL before pagination +++
        $this->logger->debug("DQL before pagination: " . $qb->getQuery()->getDQL());
        $this->logger->debug("Parameters: ", $qb->getParameters()->toArray());


        // KNP Paginate
        $pagination = $paginator->paginate(
            $qb->getQuery(), // Pass the Query object itself
            $page,
            $limit,
            [
                'pageParameterName' => 'page',
                'sortFieldParameterName' => 'sort',
                'sortDirectionParameterName' => 'direction',
                'defaultSortFieldName' => $dqlSortField,
                'defaultSortDirection' => $sortDirection,
                'distinct' => true,
                'allowEmptyFields' => true,
                'sortFieldWhitelist' => array_values(self::ALLOWED_SORT_FIELDS)
            ]
        );

        /* ---------- Get Participation Status ---------- */
        // ... (remains the same) ...
        $userParticipationMap = [];
        $user = $this->getUser();
        if ($user instanceof Utilisateur) {
            $eventIdsOnPage = [];
            foreach ($pagination->getItems() as $event) { if ($event instanceof Event) { $eventIdsOnPage[] = $event->getId(); } }
            if (!empty($eventIdsOnPage)) {
                $participations = $this->participationRepository->findBy(['utilisateur' => $user, 'event' => $eventIdsOnPage]);
                foreach ($participations as $p) { $userParticipationMap[$p->getEvent()->getId()] = $p->getStatut(); }
            }
        }

        /* ---------- Prepare Event Data ---------- */
        // ... (remains the same) ...
        $eventsForView = [];
        foreach ($pagination->getItems() as $event) {
            $duration = null;
            if ($event->getDateDebut() && $event->getDateFin()) {
                try {
                    $diff = $event->getDateFin()->diff($event->getDateDebut());
                    $durationParts = [];
                    if ($diff->days > 0) $durationParts[] = $diff->days . 'j';
                    if ($diff->h > 0) $durationParts[] = $diff->h . 'h';
                    if ($diff->i > 0 && $diff->days == 0) $durationParts[] = $diff->i . 'min';
                    $duration = !empty($durationParts) ? implode(' ', $durationParts) : ($diff->s > 0 ? '< 1min' : '0min');
                } catch (\Exception $e) { $this->logger->error("Duration calculation error: ".$e->getMessage());}
            }
            $eventsForView[] = [ 'entity' => $event, 'duration' => $duration, 'location' => $event->getState()?->label() ?? '-', 'user_participation_status' => $userParticipationMap[$event->getId()] ?? null, ];
        }

        /* ---------- Render View ---------- */
        return $this->render('client/event/index.html.twig', [
            'pagination' => $pagination,
            'events_data' => $eventsForView,
            'userParticipationMap' => $userParticipationMap,
            'current_filter' => $filter,
            'search_term' => $search,
            'currentLimit' => $limit,
            'allowedLimits' => self::ALLOWED_LIMITS,
            'current_sort_field' => $dqlSortField,
            'current_direction' => $sortDirection,
            'allowed_sorts_map' => self::ALLOWED_SORT_FIELDS,
        ]);
    }
    #[Route('/new', name: 'client_event_new', methods: ['GET', 'POST'])]
    public function new(Request $request): Response // EntityManager injected via constructor
    {
        $event = new Event();
        // $event->setStatut('active'); // This 'active' status seems incorrect based on the entity enum/choices ('A_VENIR', etc.)
        $event->setStatut('A_VENIR'); // Set a valid default status

        $form = $this->createForm(EventType::class, $event);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->persist($event);
            $this->entityManager->flush();
            $this->addFlash('success', 'Événement créé avec succès.');
            return $this->redirectToRoute('client_event_index');
        }

        return $this->render('client/event/new.html.twig', [
            'event' => $event,
            'form' => $form->createView(), // Pass form view
        ]);
    }

    #[Route('/{id}/participate', name: 'client_event_participate', methods: ['POST'])]
    public function participate(Request $request, Event $event, UtilisateurRepository $utilisateurRepository,

                                MailerInterface $mailer        // ← inject it here

    ): Response // EntityManager injected via constructor
    {
//        $this->client->request('POST', "https://hook.eu1.make.com/ndgogmlq27hd1j6toex8eusathvnag8q", [
//            'json' => [
//                'title' => $event->getTitre(),
//                'description' => $event->getDescription(),
//                'start_time' => $event->getDateDebut()->format('c'), // ISO 8601 format
//                'end_time' => $event->getDateFin()->format('c'),
//                'location' => $event->getState()->value ?? null, // Assuming GouvernoratEnum has value "Ariana" etc.
//                'status' => $event->getStatut(),
//            ],
//        ]);
        // WARNING: No security check! Relies on getUser() or fallback.
        $user = $this->getUser();
        if (!$user) {
            // Using the fallback test user logic from your original code
            $user = $utilisateurRepository->findOneBy(['email' => 'test@example.com']);
            if (!$user) {
                // Create a default test user for participation testing
                $user = new Utilisateur();
                $user->setEmail('test@example.com');
                $user->setNom('Test');
                $user->setPrenom('User');
                // Note: Password hashing should ideally use the PasswordHasher service
                $user->setPassword(password_hash('test1234', PASSWORD_DEFAULT)); // Use default hash
                $user->setRoleInterne('client'); // Use setRoleInterne
                $user->setTelephone('0123456789'); // Required field in database
                $user->setIsVerified(true); // Assume verified for test
                $this->entityManager->persist($user);
                $this->entityManager->flush();
            }
        }
         $email = (new Email())
            ->from('aymen.labidi@esprit.tn')
            ->to('aymenlabidi21@gmail.com')
            ->subject('Hello via SMTP!')
            ->text('This email was sent over SMTP using Symfony Mailer.')
            ->html('<p>This email was sent over <strong>SMTP</strong> using Symfony Mailer.</p>');
        $dateDebut = $event->getDateDebut()->format('d/m/Y \à H\hi'); // e.g. "27/04/2025 à 14h30"
        $dateFin   = $event->getDateFin()  ->format('d/m/Y \à H\hi'); // e.g. "27/04/2025 à 16h00"

        $url = 'https://hook.eu1.make.com/36nvslbc06ues77g2f69w5nloy1ra98j';

                            $body = <<<EOT
                    Bonjour,</br>
                    
                    Félicitations ! Vous êtes inscrit(e) à l'événement "{$event->getTitre()}". ✅</br>
                    
                    📅 Date : {$dateDebut} - {$dateFin}</br>
                    📍 Lieu : {$event->getLieuValue()} ({$event->getState()->label()})</br>
                    ⚡ Autonomie minimale requise pour les trottinettes : {$event->getTrottinetteMinAutonomie()} km</br>
                    
                    🎫 Présentez ce mail comme preuve de votre inscription.</br>
                    
                    À très bientôt ! 🚀
                    EOT;
        $payload = [
            'calendar_title' => $event->getTitre(),
                'description' => $event->getDescription(),
                'start_time' => $event->getDateDebut()->format('c'), // ISO 8601 format
                'end_time' => $event->getDateFin()->format('c'),
                'location' => $event->getState()->value ?? null, // Assuming GouvernoratEnum has value "Ariana" etc.
                'status' => $event->getStatut(),
            'email' => $user->getEmail(),
            'body'  => $body,
            'title' => "Confirmation de participation à 'événement",
        ];
        $headers = [
            'Content-Type' => 'application/json',
            'Cookie'       => '__cf_bm=hfXrt7n0TJKswki1VkcZXgyCGyrUOG7LcPSmsuwLAUQ-1745745305-1.0.1.1-N9CHYn3bbnDqxifvbWFL9WPEDH1DMGIol16jHCmyIGxdm1RMOXrxAOUN4k6iNJtOlX35E0QzCR8t.BZudJltHyTg0nWihxkmMK5TL2.ia28',
        ];

        $response = $this->client->request('POST', $url, [
            'headers' => $headers,
            'json'    => $payload,
        ]);

        // get status and body if you want
        $status  = $response->getStatusCode();
        $content = $response->getContent(false);


        try {

            $mailer->send($email);
            $this->addFlash('success', 'Email envoyé !');



        } catch (TransportExceptionInterface $e) {
            // SMTP refused it, DNS failure, auth error, etc.
            $this->addFlash('error', 'L’email n’a pas pu être envoyé : '.$e->getMessage());

            // In dev, you might re-throw to see the full trace
            if ($this->getParameter('kernel.debug')) {
                throw $e;
            }
        }


        // Check if user already actively registered
        $activeParticipation = $this->participationRepository->findOneBy([
            'event' => $event,
            'utilisateur' => $user,
            'statut' => ParticipationStatus::INSCRIT
        ]);

        if ($activeParticipation) {
            $this->addFlash('warning', 'Vous êtes déjà inscrit à cet événement.');
            return $this->redirectToRoute('client_event_show', ['id' => $event->getId()]);
        }

        // Check if user has a cancelled registration for this event
        $cancelledParticipation = $this->participationRepository->findOneBy([
            'event' => $event,
            'utilisateur' => $user,
            'statut' => ParticipationStatus::ANNULE
        ]);
        $participationToConfirm = null; // Variable to hold the participation object

        if ($cancelledParticipation) {
            // Reactivate the cancelled participation
            $cancelledParticipation->setStatut(ParticipationStatus::INSCRIT);
            $cancelledParticipation->setDateInscription(new \DateTime()); // Update inscription date
            $this->entityManager->persist($cancelledParticipation);
            $this->addFlash('success', 'Votre inscription a été réactivée !');
            $participationToConfirm = $cancelledParticipation; // Use this participation object

        } else {
            // Create a new participation if none exists (active or cancelled)
            $participation = new Participation();
            // WARNING: Using potentially non-unique ID. Database composite key (eventId, userId) is preferred.
            $participation->setEvent($event);
            $participation->setUtilisateur($user);
            $participation->setDateInscription(new \DateTime());
            $participation->setStatut(ParticipationStatus::INSCRIT);
            $this->entityManager->persist($participation);
            $this->addFlash('success', 'Vous êtes maintenant inscrit à cet événement !');
            $participationToConfirm = $participation; // Use the new participation object

        }

        $this->entityManager->flush();

        // --- Redirect to the NEW Confirmation Page ---
        if ($participationToConfirm && $participationToConfirm->getId()) {
            return $this->redirectToRoute('client_participation_confirmation', ['id' => $participationToConfirm->getId()]);
        } else {
            // Fallback if something went wrong getting the ID
            $this->addFlash('error', 'Erreur lors de la récupération de l\'ID de participation.');
            return $this->redirectToRoute('client_event_show', ['id' => $event->getId()]);
        }    }

    // --- Added Action to Cancel Participation ---
    #[Route('/{id}/cancel-participation', name: 'client_event_cancel_participation', methods: ['POST'])]
    public function cancelParticipation(Request $request, Event $event, UtilisateurRepository $utilisateurRepository): Response // EntityManager injected via constructor
    {
        // WARNING: No security check!
        $user = $this->getUser();
        if (!$user) {
            // Using the fallback test user logic from your original code (less ideal for cancel)
            $user = $utilisateurRepository->findOneBy(['email' => 'test@example.com']);
            if (!$user) {
                $this->addFlash('warning', 'Utilisateur non trouvé pour annuler la participation.');
                return $this->redirectToRoute('client_event_show', ['id' => $event->getId()]);
            }
        }

        // Find the ACTIVE participation to cancel
        $participation = $this->participationRepository->findOneBy([
            'event' => $event,
            'utilisateur' => $user,
            'statut' => ParticipationStatus::INSCRIT // Only cancel if currently 'INSCRIT'
        ]);

        if (!$participation) {
            $this->addFlash('warning', 'Vous n\'êtes pas activement inscrit à cet événement.');
            return $this->redirectToRoute('client_event_show', ['id' => $event->getId()]);
        }

        // Change status to Cancelled
        $participation->setStatut(ParticipationStatus::ANNULE);
        $this->entityManager->persist($participation); // Persist the change
        $this->entityManager->flush();

        $this->addFlash('success', 'Votre participation à l\'événement a été annulée.');
        return $this->redirectToRoute('client_event_show', ['id' => $event->getId()]);
    }
    // --- End Added Action ---


    #[Route('/{id}', name: 'client_event_show', methods: ['GET'])]
    public function show(Event $event): Response // ParticipationRepository injected via constructor
    {
        $user = $this->getUser();
        $user_participation = null;
        if ($user instanceof Utilisateur) {
            // Find specific participation (active or cancelled) for this user/event
            $user_participation = $this->participationRepository->findOneBy(['event' => $event, 'utilisateur' => $user]);
        }

        $user_participation_status = $user_participation?->getStatut();

        return $this->render('client/event/show.html.twig', [
            'event' => $event,
            // Pass the specific participation object (or null) to the template
            'user_participation' => $user_participation,           // Participation object or null
            'user_participation_status' => $user_participation_status   // Status Enum or null
        ]);
    }

    #[Route('/{id}/edit', name: 'client_event_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Event $event): Response // EntityManager injected via constructor
    {
        $form = $this->createForm(EventType::class, $event);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->flush();
            $this->addFlash('success', 'Événement mis à jour.');
            // Redirect back to the show page or index
            return $this->redirectToRoute('client_event_show', ['id' => $event->getId()]);
        }

        return $this->render('client/event/edit.html.twig', [
            'event' => $event,
            'form' => $form->createView(), // Pass form view
        ]);
    }

    #[Route('/{id}', name: 'client_event_delete', methods: ['POST'])]
    public function delete(Request $request, Event $event): Response // EntityManager injected via constructor
    {
        // WARNING: Original code has Csrf check but redirects to admin dashboard.
        // Keeping the CSRF check as it's good practice, even if other security is removed.
        // Redirecting to event index instead of admin dashboard.
        // Also, need to handle deletion of related participations.
        if (true) {

            // Manually remove participations before removing event (if cascade={"remove"} isn't set or doesn't work)
            $participations = $this->participationRepository->findBy(['event' => $event]);
            foreach ($participations as $participation) {
                $this->entityManager->remove($participation);
            }
            // Flush removals if necessary, though often can be done in one flush
            // $this->entityManager->flush();

            $this->entityManager->remove($event);
            $this->entityManager->flush();
            $this->addFlash('success', 'Événement supprimé.');
        } else {
            $this->addFlash('danger', 'Action invalide (CSRF token mismatch).');
            return $this->redirectToRoute('client_event_show', ['id' => $event->getId()]); // Redirect back if token fails
        }

        return $this->redirectToRoute('client_event_index'); // Redirect to event list
    }

    #[Route('/{id}/participants', name: 'client_event_participants', methods: ['GET'])]
    public function participants(Event $event): Response // ParticipationRepository injected via constructor
    {
        // This action remains the same, just lists participants.
        $participants = $this->participationRepository->findByEvent($event);

        // Render the view for showing participants (assuming this view exists and is correct)
        return $this->render('client/event/participants.html.twig', [
            'event' => $event,
            'participants' => $participants,
        ]);
    }
    #[Route('/participation/{id}/confirmation', name: 'client_participation_confirmation', requirements: ['id' => '\d+'], methods: ['GET'])]
    public function participationConfirmation(Participation $participation): Response
    {
        // --- Security Check: Ensure the logged-in user owns this participation ---
        $currentUser = $this->getUser();
        if (!$currentUser instanceof Utilisateur || $participation->getUtilisateur() !== $currentUser) {
            $this->addFlash('danger', 'Accès non autorisé à cette confirmation.');
            // Redirect to a safe page, maybe their dashboard or event index
            return $this->redirectToRoute('client_event_index');
        }
        // --- End Security Check ---

        $event = $participation->getEvent();
        if (!$event) {
            throw $this->createNotFoundException('Événement associé non trouvé.');
        }

        $qrCodeDataUri = null;
        try {
            // 1. Generate the URL for the details page

            // 2. Generate the QR Code Result object
                            $dateDebut = $event->getDateDebut()->format('d/m/Y H:i');
                            $dateFin   = $event->getDateFin()  ->format('d/m/Y H:i');
                            $lieu      = $event->getState()?->label() ?? 'Non défini';
                            $desc      = trim(strip_tags($event->getDescription()));

                            $noteText = <<<EOT
                Événement : {$event->getTitre()}
                📅 Date : {$dateDebut} – {$dateFin}
                📍 Lieu  : {$lieu}
                
                ℹ️ Description :
                {$desc}
                EOT;

            $qrCodeResult = $this->qrCodeBuilder->build(
                data:                 $noteText,
                encoding:             new Encoding('UTF-8'),
                errorCorrectionLevel: ErrorCorrectionLevel::Low,
                size:                 200,
                margin:               10
            );

            // 3. Get the Data URI (base64 string)
            $qrCodeDataUri = $qrCodeResult->getDataUri();

        } catch (\Exception $e) {
            $this->addFlash('error', 'Impossible de générer le code QR : ' . $e->getMessage());
            // Log the error ($this->logger->error(...))
        }

        return $this->render('client/event/participation_confirmation.html.twig', [
            'participation' => $participation,
            'event' => $event,
            'qrCodeDataUri' => $qrCodeDataUri, // Pass the base64 URI to Twig
        ]);
    }


}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Client/DashboardController.php -----
<?php
// src/Controller/Client/DashboardController.php
namespace App\Controller\Client;

use App\Repository\TrottinetteRepository;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Http\Attribute\IsGranted;
use App\Repository\EventRepository;
use App\Repository\ParticipationRepository;
use App\Repository\PointRelaisRepository;
use App\Repository\ReservationRepository;

use App\Entity\Utilisateur; // Import User entity
use App\Enum\ReservationStatus; // Import ReservationStatus Enum
use App\Enum\ParticipationStatus; // Import ParticipationStatus Enum
use Psr\Log\LoggerInterface;


#[Route('/client')]
#[IsGranted('ROLE_USER')]
class DashboardController extends AbstractController
{
    private LoggerInterface $logger;
    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    #[Route('/dashboard', name: 'client_dashboard')]
    public function dashboard(
        EventRepository $eventRepository,
        ParticipationRepository $participationRepository,
        ReservationRepository $reservationRepository,
        // TrottinetteRepository $trottinetteRepository, // Keep if needed for stats
        // PointRelaisRepository $pointRelaisRepository // Keep if needed for stats
    ): Response {
        /** @var Utilisateur $user */
        $user = $this->getUser(); // Get the currently logged-in user

        if (!$user) {
            // Should not happen due to IsGranted, but good practice
            $this->logger->warning('Client dashboard accessed without authenticated user.');
            return $this->redirectToRoute('app_login');
        }

        $this->logger->info(sprintf('Client dashboard accessed by user ID %d.', $user->getId()));

        // --- Fetch User-Specific Data ---
        $upcomingEvents = [];
        $userActiveReservations = [];
        $participatingEventIds = [];

        try {
            // 1. Fetch upcoming events (can show all or only those participated in)
            // Option A: Show all upcoming events
            $upcomingEvents = $eventRepository->findUpcomingEvents(5); // Limit for dashboard view

            // Option B: Show only events user is participating in (uncomment if preferred)
            // $participations = $participationRepository->findBy(['utilisateur' => $user, 'statut' => ParticipationStatus::INSCRIT]);
            // foreach ($participations as $p) {
            //    $event = $p->getEvent();
            //    // Check if the event is actually upcoming
            //    if ($event && $event->getDateDebut() >= new \DateTimeImmutable()) {
            //        $upcomingEvents[] = $event;
            //    }
            // }
            // // Sort them if needed
            // usort($upcomingEvents, fn($a, $b) => $a->getDateDebut() <=> $b->getDateDebut());
            // $upcomingEvents = array_slice($upcomingEvents, 0, 5); // Limit


            // 2. Fetch user's active/current reservations
            // Adjust status based on your application's logic for "rented"
            $userActiveReservations = $reservationRepository->findBy(
                ['utilisateur' => $user, 'status' => ReservationStatus::CONFIRMED], // Assuming CONFIRMED means active
                ['dateFin' => 'ASC'], // Show ending soonest first
                5 // Limit for dashboard view
            );

            // 3. Get IDs of events user is actively participating in (for button state)
            $activeParticipations = $participationRepository->findBy(['utilisateur' => $user, 'statut' => ParticipationStatus::INSCRIT]);
            foreach ($activeParticipations as $participation) {
                $participatingEventIds[] = $participation->getEvent()->getId();
            }

            $this->logger->info(sprintf('User %d has %d active reservations and participates in %d upcoming events shown.', $user->getId(), count($userActiveReservations), count($upcomingEvents)));

        } catch (\Exception $e) {
            $this->logger->error('Error fetching client dashboard data for user ID ' . $user->getId() . ': ' . $e->getMessage(), ['exception' => $e]);
            $this->addFlash('error', 'Erreur lors du chargement de vos informations.');
        }


        // --- Prepare Data for View ---
        // Prepare events data (calculate duration, add participation status if needed)
        $eventsForView = [];
        foreach($upcomingEvents as $event) {
            $duration = null;
            if ($event->getDateDebut() && $event->getDateFin()) {
                $diff = $event->getDateFin()->diff($event->getDateDebut());
                $duration = sprintf('%dh %02dmin', $diff->h + ($diff->days * 24), $diff->i);
            }
            $eventsForView[] = [
                'entity' => $event,
                'duration' => $duration,
                // Status is checked directly using participatingEventIds in Twig now
            ];
        }

        // No extra prep needed for reservations, pass them directly

        return $this->render('client/dashboard/index.html.twig', [
            'utilisateur' => $user,
            'upcoming_events' => $eventsForView, // Use the prepared array
            'user_reservations' => $userActiveReservations, // User's active reservations
            'participatingEventIds' => $participatingEventIds, // IDs for button state
            // Remove data not directly used in this specific template
            // 'trottinettes' => $trottinettes,
            // 'pointRelais' => $pointRelais,
            // 'reservations' => $reservations, // Use user_reservations instead
            // 'registerTrottIds' => $registerTrottIds,
        ]);
    }
    #[Route('/dashboard/qr-scan', name: 'client_qr_scan', methods: ['GET'])]
    public function qrScan(): Response
    {
        return $this->render('client/dashboard/qr_scan.html.twig');
    }

    #[Route('/dashboard/map', name: 'client_map_display', methods: ['GET'])]
    public function mapDisplay(TrottinetteRepository $trottiRepo): Response
    {
        $trottinettes = $trottiRepo->findAvailable();
        return $this->render('client/dashboard/map.html.twig', [
            'trottinettes' => $trottinettes,
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Client/ReservationController.php -----
<?php

namespace App\Controller\Client;

use App\Entity\Reservation;
use App\Entity\Trottinette;
use App\Repository\ReservationRepository;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Core\Security;

class ReservationController extends AbstractController
{
    private EntityManagerInterface $entityManager;
    private ReservationRepository $reservationRepository;
    private Security $security;

    public function __construct(EntityManagerInterface $entityManager, ReservationRepository $reservationRepository, Security $security)
    {
        $this->entityManager = $entityManager;
        $this->reservationRepository = $reservationRepository;
        $this->security = $security;
    }

    #[Route('/reservation/create/{trottinette_id}', name: 'reservation_create', methods: ['POST'])]
    public function create(Request $request, int $trottinette_id): Response
    {
        // Retrieve the trottinette
        $trottinette = $this->entityManager->getRepository(Trottinette::class)->find($trottinette_id);

        // Check if the trottinette exists
        if (!$trottinette) {
            $this->addFlash('danger', 'Cette trottinette n\'existe pas.');
            return $this->redirectToRoute('trottinette_list'); // Change this to your trottinette list route
        }

        // Check if the trottinette is already reserved
        $existingReservation = $this->reservationRepository->findOneBy(['trottinette' => $trottinette]);
        if ($existingReservation) {
            $this->addFlash('danger', 'Cette trottinette est déjà réservée.');
            return $this->redirectToRoute('trottinette_list'); // Redirect to the list or another appropriate page
        }

        // Create new reservation
        $reservation = new Reservation();
        $reservation->setTrottinette($trottinette);
        $reservation->setUtilisateur($this->security->getUser());
        $reservation->setDateDebut(new \DateTime()); // Set current time or based on user input
        $reservation->setDateFin(new \DateTime('+1 hour')); // Example, set 1 hour duration
        $reservation->setMontant('10.00'); // Set a default amount or calculate dynamically
        $reservation->setStatus(ReservationStatus::PENDING); // Default status
        $reservation->setPaiement(Paiement::CASH); // Example payment method

        // Persist and flush the reservation
        $this->entityManager->persist($reservation);
        $this->entityManager->flush();

        // Add a success flash message
        $this->addFlash('success', 'Réservation effectuée avec succès.');

        // Redirect to the reservation list or another page
        return $this->redirectToRoute('reservation_index');
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Client/ProfileController.php -----
<?php
// src/Controller/Client/ProfileController.php
namespace App\Controller\Client;

use App\Entity\Utilisateur;
use App\Form\ProfileType;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Http\Attribute\IsGranted;
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use App\Service\FacialRecognitionService; // Import the service

#[Route('/mon-profil')]
#[IsGranted('ROLE_USER')]
class ProfileController extends AbstractController
{
    private FacialRecognitionService $faceRecService;
    private EntityManagerInterface $entityManager;

    public function __construct(FacialRecognitionService $faceRecService, EntityManagerInterface $entityManager)
    {
        $this->faceRecService = $faceRecService;
        $this->entityManager = $entityManager;
    }

    #[Route('', name: 'app_client_profile_view', methods: ['GET'])]
    public function view(): Response
    {
        /** @var Utilisateur|null $user */
        $user = $this->getUser();

        if (!$user instanceof Utilisateur) {
            $this->addFlash('warning', 'Utilisateur non trouvé.');
            return $this->redirectToRoute('app_login_page');
        }

        return $this->render('client/profile/view.html.twig', [
            'utilisateur' => $user,
            // Pass flag indicating if face embedding exists
            'has_face_setup' => !empty($user->getFaceEmbedding())
        ]);
    }

    #[Route('/edit', name: 'app_client_profile_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, UserPasswordHasherInterface $passwordHasher): Response
    {
        $user = $this->getUser();
        if (!$user instanceof \App\Entity\Utilisateur) {
            return $this->redirectToRoute('app_login_page');
        }

        $form = $this->createForm(ProfileType::class, $user);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            // Handle optional password change if implemented in ProfileType
            // ... (logic for hashing new password if provided) ...

            $this->entityManager->flush();
            $this->addFlash('success', 'Profil mis à jour avec succès.');
            return $this->redirectToRoute('app_client_profile_view');
        }

        return $this->render('client/profile/edit.html.twig', [
            'utilisateur' => $user,
            'profileForm' => $form->createView(),
        ]);
    }

    // --- NEW: Action for Facial Recognition Setup/Update ---
    #[Route('/setup-face', name: 'app_client_profile_setup_face', methods: ['POST'])]
    public function setupFacialRecognition(Request $request): JsonResponse
    {
        /** @var Utilisateur|null $user */
        $user = $this->getUser();
        if (!$user instanceof Utilisateur) {
            return new JsonResponse(['success' => false, 'message' => 'Authentification requise.'], Response::HTTP_UNAUTHORIZED);
        }

        // Expecting comma-separated descriptor string from frontend JS
        $embeddingData = $request->request->get('face_embedding_data'); // Match the key used in JS fetch body

        if (empty($embeddingData) || !is_string($embeddingData)) {
            return new JsonResponse(['success' => false, 'message' => 'Données faciales manquantes ou invalides.'], Response::HTTP_BAD_REQUEST);
        }

        // Basic format validation (comma-separated numbers)
        if (!preg_match('/^[-0-9.,]+$/', $embeddingData)) {
            return new JsonResponse(['success' => false, 'message' => 'Format de données faciales invalide.'], Response::HTTP_BAD_REQUEST);
        }
        // Optional: More robust check (count commas, etc.)
        if (substr_count($embeddingData, ',') !== 127) { // 128 values have 127 commas
            return new JsonResponse(['success' => false, 'message' => 'Nombre incorrect de valeurs faciales.'], Response::HTTP_BAD_REQUEST);
        }

        try {
            // Directly save the embedding string provided by the JS (which came from face-api)
            $user->setFaceEmbedding($embeddingData);
            $this->entityManager->flush(); // Save changes

            // Flash message will be shown on next page load (after JS potentially reloads)
            $this->addFlash('success', 'Reconnaissance faciale configurée avec succès!');

            return new JsonResponse(['success' => true, 'message' => 'Configuration faciale enregistrée.']);

        } catch (\Exception $e) {
            // Log the error server-side
            error_log('Facial recognition setup DB error for user ' . $user->getId() . ': ' . $e->getMessage());
            return new JsonResponse(['success' => false, 'message' => 'Erreur interne lors de l\'enregistrement. Veuillez réessayer.'], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }
    // --- END NEW ACTION ---
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Client/ReclamationController.php -----
<?php

namespace App\Controller\Client;

use App\Entity\Reponse; // Importer l'entité Reponse
use App\Form\ReponseType; // Importer le formulaire Reponse
use App\Entity\Reclamation;
use App\Form\ReclamationType;
use App\Repository\ReclamationRepository;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

#[Route('/reclamation')]
class ReclamationController extends AbstractController
{
    // Route pour afficher toutes les réclamations
    #[Route('', name: 'reclamation_index', methods: ['GET'])]
    public function index(ReclamationRepository $reclamationRepository): Response
    {
        return $this->render('reclamation/index.html.twig', [
            'reclamations' => $reclamationRepository->findAll(),
        ]);
    }

    // Route pour la création d'une nouvelle réclamation
    #[Route('/new', name: 'reclamation_new', methods: ['GET', 'POST'])]
    public function new(Request $request, EntityManagerInterface $em): Response
    {
        $reclamation = new Reclamation();

        // Associer l'utilisateur connecté à la réclamation
        if ($this->getUser()) {
            $reclamation->setUtilisateur($this->getUser());
        } else {
            // Si pas connecté, rediriger vers la page de connexion
            $this->addFlash('error', 'Vous devez être connecté pour créer une réclamation.');
            return $this->redirectToRoute('app_login');
        }

        $form = $this->createForm(ReclamationType::class, $reclamation);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            if ($reclamation->getDateCreation() === null) {
                $reclamation->setDateCreation(new \DateTime());
            }

            $em->persist($reclamation);
            $em->flush();

            $this->addFlash('success', 'Réclamation créée avec succès.');
            return $this->redirectToRoute('reclamation_index');
        }

        return $this->render('reclamation/new.html.twig', [
            'form' => $form->createView(),
        ]);
    }
    // Route pour afficher une réclamation spécifique
    #[Route('/{id}', name: 'reclamation_show', methods: ['GET'])]
    public function show(Reclamation $reclamation): Response
    {
        return $this->render('reclamation/show.html.twig', [
            'reclamation' => $reclamation,
        ]);
    }

    // Route pour modifier une réclamation existante
    #[Route('/{id}/edit', name: 'reclamation_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Reclamation $reclamation, EntityManagerInterface $em): Response
    {
        $form = $this->createForm(ReclamationType::class, $reclamation);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $em->flush();

            $this->addFlash('success', 'Réclamation mise à jour.');
            return $this->redirectToRoute('reclamation_index');
        }

        return $this->render('reclamation/edit.html.twig', [
            'reclamation' => $reclamation,
            'form' => $form->createView(),
        ]);
    }

    // Route pour supprimer une réclamation
    #[Route('/{id}', name: 'reclamation_delete', methods: ['POST'])]
    public function delete(Request $request, Reclamation $reclamation, EntityManagerInterface $em): Response
    {
        if ($this->isCsrfTokenValid('delete'.$reclamation->getId(), $request->request->get('_token'))) {
            $em->remove($reclamation);
            $em->flush();

            $this->addFlash('success', 'Réclamation supprimée.');
        }

        return $this->redirectToRoute('reclamation_index');
    }

    // Route pour répondre à une réclamation spécifique
    #[Route('/reclamation/{id}/repondre', name: 'reclamation_repondre', methods: ['GET', 'POST'])]
    public function repondre(Request $request, Reclamation $reclamation, EntityManagerInterface $em): Response
    {
        // Crée une nouvelle réponse
        $reponse = new Reponse();
        $reponse->setReclamation($reclamation);
        $reponse->setAuteur($this->getUser()); // Assigner l'auteur de la réponse (l'utilisateur connecté)

        // Créer et gérer le formulaire
        $form = $this->createForm(ReponseType::class, $reponse);
        $form->handleRequest($request);

        // Si le formulaire est soumis et valide
        if ($form->isSubmitted() && $form->isValid()) {
            $em->persist($reponse);
            $em->flush();  // Sauvegarde la réponse dans la base de données

            $this->addFlash('success', 'Votre réponse a été ajoutée avec succès.');

            return $this->redirectToRoute('reclamation_show', ['id' => $reclamation->getId()]);
        }

        // Rendu du formulaire de réponse
        return $this->render('reclamation/repondre.html.twig', [
            'form' => $form->createView(),
            'reclamation' => $reclamation,
        ]);
    }

}


----- /Users/mac/Downloads/my_project_troti-vf/src/Service/Texter.php -----
<?php

namespace App\Service;

use Twilio\Rest\Client; // <--- CORRECT CLIENT
use Symfony\Component\Notifier\Message\SmsMessage;

class Texter
{
    private $twilioClient;
    private $twilioPhoneNumber;

    public function __construct(string $accountSid, string $authToken, string $phoneNumber)
    {
        $this->twilioClient = new Client($accountSid, $authToken);
        $this->twilioPhoneNumber = $phoneNumber;
    }

    public function send(SmsMessage $sms)
    {
        // Use the Twilio client to send the SMS
        $this->twilioClient->messages->create(
            "+21620692262", // recipient phone number
            [
                'from' => $this->twilioPhoneNumber, // Twilio phone number
                'body' => $sms->getSubject(),      // SMS message content
            ]
        );
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Service/ChatbotService.php -----
<?php

namespace App\Service;

use Symfony\Contracts\HttpClient\HttpClientInterface;
use Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface;
use Symfony\Contracts\HttpClient\Exception\ClientExceptionInterface;
use Symfony\Contracts\HttpClient\Exception\ServerExceptionInterface;
use Symfony\Contracts\HttpClient\Exception\RedirectionExceptionInterface;
use Symfony\Contracts\HttpClient\Exception\JsonException;

class ChatbotService
{
    private HttpClientInterface $client;
    private string $apiKey;

    public function __construct(HttpClientInterface $client)
    {
        $this->client = $client;
        $this->apiKey = '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'; // your real token
    }

    public function ask(string $message): string
{
    try {
        $response = $this->client->request('POST', 'https://api-inference.huggingface.co/models/facebook/blenderbot-400M-distill', [
            'headers' => [
                'Authorization' => 'Bearer ' . $this->apiKey,
                'Content-Type' => 'application/json',
            ],
            'json' => [
                'inputs' => $message,
            ],
        ]);

        $data = $response->toArray(false);

        // Save response into var/ directory for debugging
        file_put_contents(__DIR__ . '/../../var/huggingface_response.json', json_encode($data, JSON_PRETTY_PRINT));

        if (isset($data['error'])) {
            return 'Bot Error: ' . $data['error'];
        }

        if (isset($data[0]['generated_text'])) {
            return $data[0]['generated_text'];
        }

        return 'Bot could not generate a valid response.';
    } catch (\Exception $e) {
        return 'Bot Error: ' . $e->getMessage();
    }
}

}



----- /Users/mac/Downloads/my_project_troti-vf/src/Service/FacialRecognitionService.php -----
<?php
// src/Service/FacialRecognitionService.php
namespace App\Service;

use Symfony\Component\HttpClient\HttpClient; // Example if calling an external API
use Symfony\Contracts\HttpClient\HttpClientInterface; // Interface for HttpClient

class FacialRecognitionService
{
    private const EUCLIDEAN_THRESHOLD = 0.43; // Adjust as needed
    private HttpClientInterface $httpClient;
    private string $faceApiEndpoint; // URL of your Python API/service

    // Inject HttpClient and potentially the API endpoint URL
    public function __construct(HttpClientInterface $httpClient, string $faceApiEndpoint = 'http://127.0.0.1:5001/extract') // Example endpoint
    {
        $this->httpClient = $httpClient;
        $this->faceApiEndpoint = $faceApiEndpoint;
    }

    /**
     * Extracts embedding by calling an external service (e.g., Python Flask API).
     *
     * @param string $base64ImageData Base64 encoded image string (with prefix like data:image/jpeg;base64,)
     * @return string|null Comma-separated float string representing the embedding, or null on failure.
     */
    public function extractEmbedding(string $base64ImageData): ?string
    {
        // Remove the base64 prefix (e.g., "data:image/jpeg;base64,")
        $base64CleanData = preg_replace('#^data:image/\w+;base64,#i', '', $base64ImageData);
        if (empty($base64CleanData)) {
            error_log("Face Embedding Extraction Error: Invalid base64 prefix or empty data.");
            return null;
        }

        try {
            $response = $this->httpClient->request('POST', $this->faceApiEndpoint, [
                'json' => ['image_base64' => $base64CleanData]
                // Or use 'body' => json_encode(...) depending on API expectation
                // Add headers if needed: 'headers' => ['Content-Type' => 'application/json']
            ]);

            $statusCode = $response->getStatusCode();
            $content = $response->toArray(false); // false to not throw on non-2xx codes

            if ($statusCode === 200 && isset($content['embedding']) && is_array($content['embedding'])) {
                // API should return an array of floats/numbers
                // Ensure they are floats and join them into a string
                $embeddingArray = array_map('floatval', $content['embedding']);
                if (count($embeddingArray) === 128) { // Check expected dimension
                    return implode(',', $embeddingArray);
                } else {
                    error_log("Face Embedding Extraction Error: API returned embedding with incorrect dimension: " . count($embeddingArray));
                    return null;
                }
            } else {
                // Log the error from the API if available
                $errorMessage = $content['error'] ?? ('API Error: Status ' . $statusCode);
                error_log("Face Embedding Extraction Error: " . $errorMessage);
                return null;
            }

        } catch (\Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface $e) {
            error_log("Face Embedding API Transport Error: " . $e->getMessage());
            return null; // Network or connection error
        } catch (\Symfony\Contracts\HttpClient\Exception\ExceptionInterface $e) {
            error_log("Face Embedding API Client/Server Error: " . $e->getMessage());
            return null; // Other client/server errors
        } catch (\JsonException $e) {
            error_log("Face Embedding API Response JSON Error: " . $e->getMessage());
            return null; // Could not decode JSON response
        } catch (\Exception $e) {
            error_log("Face Embedding Unknown Error: " . $e->getMessage());
            return null; // General error
        }
    }


    /**
     * Compares a submitted face descriptor string with a stored descriptor string.
     * Uses Euclidean distance.
     *
     * @param string $submittedDescriptorString Comma-separated descriptor floats.
     * @param string $storedDescriptorString Comma-separated descriptor floats.
     * @return bool True if faces match within threshold, false otherwise.
     */
    public function compareFaces(string $submittedDescriptorString, string $storedDescriptorString): bool
    {
        if (empty($submittedDescriptorString) || empty($storedDescriptorString)) {
            error_log("Comparison failed: Missing submitted or stored descriptor string.");
            return false;
        }

        try {
            $submittedEmbedding = array_map('floatval', explode(',', $submittedDescriptorString));
            $storedEmbedding = array_map('floatval', explode(',', $storedDescriptorString));

            if (count($submittedEmbedding) !== 128 || count($storedEmbedding) !== 128) {
                error_log("Comparison failed: Invalid descriptor length. Submitted: " . count($submittedEmbedding) . ", Stored: " . count($storedEmbedding));
                return false;
            }

            $distance = $this->euclideanDistance($submittedEmbedding, $storedEmbedding);
            error_log("Face comparison Euclidean distance: " . $distance);

            return $distance <= self::EUCLIDEAN_THRESHOLD;

        } catch (\Exception $e) {
            error_log("Facial recognition comparison error: " . $e->getMessage());
            return false;
        }
    }

    private function euclideanDistance(array $vecA, array $vecB): float
    {
        $sumOfSquares = 0.0;
        $count = count($vecA);

        for ($i = 0; $i < $count; $i++) {
            $diff = ($vecA[$i] ?? 0.0) - ($vecB[$i] ?? 0.0); // Handle potential missing keys just in case
            $sumOfSquares += $diff * $diff;
        }

        return sqrt($sumOfSquares);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Service/DataFixturesService.php -----
<?php

namespace App\Service;

use App\Entity\PointRelais;
use App\Entity\Utilisateur;
use Doctrine\ORM\EntityManagerInterface;

class DataFixturesService
{
    private EntityManagerInterface $entityManager;
    
    public function __construct(EntityManagerInterface $entityManager)
    {
        $this->entityManager = $entityManager;
    }
    
    public function getOrCreateDefaultPointRelais(): PointRelais
    {
        // Try to find an existing default point relais
        $pointRelais = $this->entityManager->getRepository(PointRelais::class)->find(1);
        
        // If none exists, create one
        if (!$pointRelais) {
            $pointRelais = new PointRelais();
            $pointRelais->setNom('Point Relais par défaut');
            $pointRelais->setAddresse('123 Rue Test');
            
            // Set a valid DateTime value for HoraireOuverture
            // Here, we set the current date and time as the default value
            $pointRelais->setHoraireOuverture(new \DateTime());  // This will use the current date and time
    
            $this->entityManager->persist($pointRelais);
            $this->entityManager->flush();
        }
        
        return $pointRelais;
    }
    
    public function getOrCreateDefaultUser(): ?Utilisateur
    {
        // Try to find an existing default user
        $user = $this->entityManager->getRepository(Utilisateur::class)->find(1);
        
        // If none exists, create one
        if (!$user) {
            $user = new Utilisateur();
            $user->setEmail('test@example.com');
            $user->setNom('User');
            $user->setPrenom('Test');
            $user->setTelephone('0123456789');
            $user->setPassword('password');  // In a real app, you'd hash this
            $user->setRole('client');
            
            $this->entityManager->persist($user);
            $this->entityManager->flush();
        }
        
        return $user;
    }
    
    public function getDefaultPointRelaisId(): int
    {
        return $this->getOrCreateDefaultPointRelais()->getId();
    }
    
    public function getDefaultUserId(): ?int
    {
        $user = $this->getOrCreateDefaultUser();
        return $user ? $user->getId() : null;
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Service/SmsService.php -----
<?php

namespace App\Service;

use Twilio\Rest\Client;
use Psr\Log\LoggerInterface;

class SmsService
{
    private $twilioClient;
    private $fromNumber;
    private $logger;

    public function __construct(string $twilioSid, string $twilioAuthToken, string $twilioFromNumber, LoggerInterface $logger)
    {
        $this->twilioClient = new Client($twilioSid, $twilioAuthToken);
        $this->fromNumber = $twilioFromNumber;
        $this->logger = $logger;
    }

    public function sendSms(string $to, string $message): bool
    {
        // Ensure the phone number starts with a "+"
        if (!str_starts_with($to, '+')) {
            $to = '+' . $to;
        }

        try {
            $this->twilioClient->messages->create($to, [
                'from' => $this->fromNumber,
                'body' => $message,
            ]);
            return true;
        } catch (\Exception $e) {
            $this->logger->error('Failed to send SMS: ' . $e->getMessage());
            return false;
        }
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Service/TwilioNotifierService.php -----
<?php
namespace App\Service;


class TwilioNotifierService
{
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Twig/AppExtension.php -----
<?php

namespace App\Twig;

use App\Enum\GouvernoratEnum;
use Twig\Extension\AbstractExtension;
use Twig\TwigFilter;

class AppExtension extends AbstractExtension
{
    public function getFilters()
    {
        return [
            new TwigFilter('enum_value', [$this, 'getEnumValue']),
        ];
    }

    public function getEnumValue($enum)
    {
        if ($enum instanceof GouvernoratEnum) {
            return $enum->value;
        }
        
        if (is_object($enum) && property_exists($enum, 'value')) {
            return $enum->value;
        }
        
        return (string) $enum;
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Kernel.php -----
<?php

namespace App;

use Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait;
use Symfony\Component\HttpKernel\Kernel as BaseKernel;

class Kernel extends BaseKernel
{
    use MicroKernelTrait;
}


