
----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/ReclamationRepository.php -----
<?php

namespace App\Repository;

use App\Entity\Reclamation;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

class ReclamationRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Reclamation::class);
    }

    /**
     * Trouver toutes les réclamations, triées par date de création (plus récentes d'abord)
     */
    public function findAllOrderedByDate()
    {
        return $this->createQueryBuilder('r')
            ->orderBy('r.date_creation', 'DESC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Trouver une réclamation par son ID
     */
    public function findById($id)
    {
        return $this->createQueryBuilder('r')
            ->andWhere('r.id = :id')
            ->setParameter('id', $id)
            ->getQuery()
            ->getOneOrNullResult();
    }

    /**
     * Trouver les réclamations par email de l'utilisateur
     */
    public function findByUserEmail($email)
    {
        return $this->createQueryBuilder('r')
            ->andWhere('r.user_email = :email')
            ->setParameter('email', $email)
            ->getQuery()
            ->getResult();
    }

    /**
     * Trouver toutes les réclamations d'un type spécifique
     */
    public function findByType($type)
    {
        return $this->createQueryBuilder('r')
            ->andWhere('r.type_reclamation = :type')
            ->setParameter('type', $type)
            ->getQuery()
            ->getResult();
    }

    /**
     * Trouver les réclamations en fonction de l'utilisateur (relation utilisateur)
     */
    public function findByUtilisateur($utilisateurId)
    {
        return $this->createQueryBuilder('r')
            ->andWhere('r.utilisateur = :utilisateur')
            ->setParameter('utilisateur', $utilisateurId)
            ->getQuery()
            ->getResult();
    }

    /**
     * Trouver les réclamations liées à une trottinette (relation trottinette)
     */
    public function findByTrottinette($trottinetteId)
    {
        return $this->createQueryBuilder('r')
            ->andWhere('r.trottinette = :trottinette')
            ->setParameter('trottinette', $trottinetteId)
            ->getQuery()
            ->getResult();
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/PointRelaisRepository.php -----
<?php

namespace App\Repository;

use App\Entity\PointRelais;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

/**
 * @extends ServiceEntityRepository<PointRelais>
 */
class PointRelaisRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, PointRelais::class);
    }

    //    /**
    //     * @return PointRelais[] Returns an array of PointRelais objects
    //     */
    //    public function findByExampleField($value): array
    //    {
    //        return $this->createQueryBuilder('p')
    //            ->andWhere('p.exampleField = :val')
    //            ->setParameter('val', $value)
    //            ->orderBy('p.id', 'ASC')
    //            ->setMaxResults(10)
    //            ->getQuery()
    //            ->getResult()
    //        ;
    //    }

    //    public function findOneBySomeField($value): ?PointRelais
    //    {
    //        return $this->createQueryBuilder('p')
    //            ->andWhere('p.exampleField = :val')
    //            ->setParameter('val', $value)
    //            ->getQuery()
    //            ->getOneOrNullResult()
    //        ;
    //    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/UtilisateurRepository.php -----
<?php
// src/Repository/UtilisateurRepository.php
namespace App\Repository;

use App\Entity\Utilisateur;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;
use Symfony\Component\Security\Core\Exception\UnsupportedUserException;
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
use Symfony\Component\Security\Core\User\PasswordUpgraderInterface;
use Doctrine\ORM\Tools\Pagination\Paginator;

/**
 * @extends ServiceEntityRepository<Utilisateur>
 * @implements PasswordUpgraderInterface<Utilisateur>
 */
class UtilisateurRepository extends ServiceEntityRepository implements PasswordUpgraderInterface
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Utilisateur::class);
    }

    /**
     * Used to upgrade (rehash) the user's password automatically over time.
     */
    public function upgradePassword(PasswordAuthenticatedUserInterface $user, string $newHashedPassword): void
    {
        if (!$user instanceof Utilisateur) {
            throw new UnsupportedUserException(sprintf('Instances of "%s" are not supported.', $user::class));
        }

        $user->setPassword($newHashedPassword);
        $this->getEntityManager()->persist($user);
        $this->getEntityManager()->flush();
    }

    public function save(Utilisateur $entity, bool $flush = false): void
    {
        $this->getEntityManager()->persist($entity);
        if ($flush) {
            $this->getEntityManager()->flush();
        }
    }

    public function remove(Utilisateur $entity, bool $flush = false): void
    {
        $this->getEntityManager()->remove($entity);
        if ($flush) {
            $this->getEntityManager()->flush();
        }
    }

    /**
     * Find users based on search criteria (name, email, role) for Admin.
     * @param array $criteria ['search' => string, 'role' => string]
     * @param int $page
     * @param int $limit
     * @return Paginator
     */
    public function findByCriteria(array $criteria = [], int $page = 1, int $limit = 10): Paginator
    {
        $qb = $this->createQueryBuilder('u')
            ->orderBy('u.nom', 'ASC')
            ->addOrderBy('u.prenom', 'ASC');

        if (!empty($criteria['search'])) {
            $searchTerm = '%' . $criteria['search'] . '%';
            $qb->andWhere($qb->expr()->orX(
                $qb->expr()->like('u.nom', ':search'),
                $qb->expr()->like('u.prenom', ':search'),
                $qb->expr()->like('u.email', ':search')
            ))
                ->setParameter('search', $searchTerm);
        }

        if (!empty($criteria['role'])) {
            $qb->andWhere('u.roleInterne = :role')
                ->setParameter('role', $criteria['role']);
        }

        // Exclude deleted users if you add a soft delete flag later
        // $qb->andWhere('u.deletedAt IS NULL');

        $query = $qb->getQuery()
            ->setFirstResult(($page - 1) * $limit)
            ->setMaxResults($limit);

        return new Paginator($query, true); // true to fetch join collection
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/MaintenanceRepository.php -----
<?php

namespace App\Repository;

use App\Entity\Maintenance;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

/**
 * @extends ServiceEntityRepository<Maintenance>
 *
 * @method Maintenance|null find($id, $lockMode = null, $lockVersion = null)
 * @method Maintenance|null findOneBy(array $criteria, array $orderBy = null)
 * @method Maintenance[]    findAll()
 * @method Maintenance[]    findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null)
 */
class MaintenanceRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Maintenance::class);
    }

    public function save(Maintenance $entity, bool $flush = false): void
    {
        $this->getEntityManager()->persist($entity);

        if ($flush) {
            $this->getEntityManager()->flush();
        }
    }

    public function remove(Maintenance $entity, bool $flush = false): void
    {
        $this->getEntityManager()->remove($entity);

        if ($flush) {
            $this->getEntityManager()->flush();
        }
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/ReservationRepository.php -----
<?php

namespace App\Repository;

use App\Entity\Reservation;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

/**
 * @extends ServiceEntityRepository<Reservation>
 */
class ReservationRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Reservation::class);
    }

    //    /**
    //     * @return Reservation[] Returns an array of Reservation objects
    //     */
    //    public function findByExampleField($value): array
    //    {
    //        return $this->createQueryBuilder('r')
    //            ->andWhere('r.exampleField = :val')
    //            ->setParameter('val', $value)
    //            ->orderBy('r.id', 'ASC')
    //            ->setMaxResults(10)
    //            ->getQuery()
    //            ->getResult()
    //        ;
    //    }

    //    public function findOneBySomeField($value): ?Reservation
    //    {
    //        return $this->createQueryBuilder('r')
    //            ->andWhere('r.exampleField = :val')
    //            ->setParameter('val', $value)
    //            ->getQuery()
    //            ->getOneOrNullResult()
    //        ;
    //    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/ResetPasswordRequestRepository.php -----
<?php
// src/Repository/ResetPasswordRequestRepository.php
namespace App\Repository;

use App\Entity\ResetPasswordRequest;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;
use SymfonyCasts\Bundle\ResetPassword\Model\ResetPasswordRequestInterface;
use SymfonyCasts\Bundle\ResetPassword\Persistence\Repository\ResetPasswordRequestRepositoryTrait;
use SymfonyCasts\Bundle\ResetPassword\Persistence\ResetPasswordRequestRepositoryInterface;

/**
 * @extends ServiceEntityRepository<ResetPasswordRequest>
 *
 * @method ResetPasswordRequest|null find($id, $lockMode = null, $lockVersion = null)
 * @method ResetPasswordRequest|null findOneBy(array $criteria, array $orderBy = null)
 * @method ResetPasswordRequest[]    findAll()
 * @method ResetPasswordRequest[]    findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null)
 */
class ResetPasswordRequestRepository extends ServiceEntityRepository implements ResetPasswordRequestRepositoryInterface
{
    use ResetPasswordRequestRepositoryTrait; // Add the trait

    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, ResetPasswordRequest::class);
    }

    public function createResetPasswordRequest(object $user, \DateTimeInterface $expiresAt, string $selector, string $hashedToken): ResetPasswordRequestInterface
    {
        // Ensure the user is a UserInterface before creating the request object
        if (!$user instanceof \Symfony\Component\Security\Core\User\UserInterface) {
            throw new \InvalidArgumentException(sprintf('The first argument of %s() must be an instance of %s, "%s" given.', __METHOD__, \Symfony\Component\Security\Core\User\UserInterface::class, get_debug_type($user)));
        }

        return new ResetPasswordRequest(
            $user,
            $expiresAt,
            $selector,
            $hashedToken
        );
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/ReponseRepository.php -----
<?php
// src/Repository/ReponseRepository.php

namespace App\Repository;

use App\Entity\Reponse;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

class ReponseRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Reponse::class);
    }

    /**
     * Find all responses for a specific reclamation ordered by date of response (earliest first)
     */
    public function findByReclamationOrderedByDate($reclamation)
    {
        return $this->createQueryBuilder('r')
            ->andWhere('r.reclamation = :reclamation')
            ->setParameter('reclamation', $reclamation)
            ->orderBy('r.date_reponse', 'ASC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Find a specific response by its ID
     */
    public function findById($id)
    {
        return $this->createQueryBuilder('r')
            ->andWhere('r.id = :id')
            ->setParameter('id', $id)
            ->getQuery()
            ->getOneOrNullResult();
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/TrottinetteRepository.php -----
<?php
// src/Repository/TrottinetteRepository.php
namespace App\Repository;

use App\Entity\Trottinette;
use App\Entity\PointRelais;
use App\Enum\TrottinetteStatus;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;
use Doctrine\ORM\Tools\Pagination\Paginator;

/**
 * @extends ServiceEntityRepository<Trottinette>
 */
class TrottinetteRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {

        parent::__construct($registry, Trottinette::class);
    }

    public function save(Trottinette $entity, bool $flush = false): void
    {
        $this->getEntityManager()->persist($entity);
        if ($flush) { $this->getEntityManager()->flush(); }
    }

    public function remove(Trottinette $entity, bool $flush = false): void
    {
        $this->getEntityManager()->remove($entity);
        if ($flush) { $this->getEntityManager()->flush(); }
    }

    public function findAvailable(): array
    {
        return $this->createQueryBuilder('t')
            ->where('t.etat = :etat')
            ->andWhere('t.pointRelais IS NOT NULL')
            ->setParameter('etat', 'DISPONIBLE')  // Bind the string 'DISPONIBLE' to the query parameter
            ->getQuery()
            ->getResult();
    }

    /**
     * Find trottinettes based on criteria for listing/searching.
     * @param array $criteria ['search' => string, 'etat' => TrottinetteStatus , 'batterie' => int]
     * @param int $page
     * @param int $limit
     * @return Paginator
     */
    public function findByCriteria(array $criteria = [], int $page = 1, int $limit = 15): Paginator
    {
        $qb = $this->createQueryBuilder('t')
            ->leftJoin('t.pointRelais', 'pr')  // Use 't.pointRelais' instead of 't.pointRelaisId'
            ->orderBy('t.dateAjout', 'DESC');
    
        if (!empty($criteria['search'])) {
            $searchTerm = '%' . $criteria['search'] . '%';
            $qb->andWhere($qb->expr()->orX(
                $qb->expr()->like('t.modele', ':search'),
                $qb->expr()->like('t.numeroSerie', ':search'),
                $qb->expr()->like('t.localisation', ':search'),
                $qb->expr()->like('pr.nom', ':search')  // Search in point relais name
            ))
            ->setParameter('search', $searchTerm);
        }
    
        // Additional criteria filtering...
    
        $query = $qb->getQuery()
            ->setFirstResult(($page - 1) * $limit)
            ->setMaxResults($limit);
    
        return new Paginator($query, true);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/EventRepository.php -----
<?php

namespace App\Repository;

use App\Entity\Event;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;
use Doctrine\ORM\QueryBuilder;

/**
 * @extends ServiceEntityRepository<Event>
 *
 * @method Event|null find($id, $lockMode = null, $lockVersion = null)
 * @method Event|null findOneBy(array $criteria, array $orderBy = null)
 * @method Event[]    findAll()
 * @method Event[]    findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null)
 */
class EventRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {

        parent::__construct($registry, Event::class);
    }

    /**
     * Find upcoming events
     */
    public function findUpcomingEvents(): array
    {
        return $this->createQueryBuilder('e')
            ->andWhere('e.dateDebut > :now')
            ->setParameter('now', new \DateTime())
            ->orderBy('e.dateDebut', 'ASC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Find events by location
     */
    public function findByLocation(string $location): array
    {
        return $this->createQueryBuilder('e')
            ->andWhere('e.lieu LIKE :location')
            ->setParameter('location', '%' . $location . '%')
            ->orderBy('e.dateDebut', 'ASC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Find events by date range
     */
    public function findByDateRange(\DateTime $start, \DateTime $end): array
    {
        return $this->createQueryBuilder('e')
            ->andWhere('e.dateDebut >= :start')
            ->andWhere('e.dateFin <= :end')
            ->setParameter('start', $start)
            ->setParameter('end', $end)
            ->orderBy('e.dateDebut', 'ASC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Find events by minimum scooter autonomy
     */
    public function findByMinScooterAutonomy(int $minAutonomy): array
    {
        return $this->createQueryBuilder('e')
            ->andWhere('e.trottinetteMinAutonomie <= :minAutonomy')
            ->setParameter('minAutonomy', $minAutonomy)
            ->orderBy('e.dateDebut', 'ASC')
            ->getQuery()
            ->getResult();
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Repository/ParticipationRepository.php -----
<?php

namespace App\Repository;

use App\Entity\Participation;
use App\Entity\Event;
use App\Entity\Utilisateur;
use App\Enum\ParticipationStatus;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

/**
 * @extends ServiceEntityRepository<Participation>
 *
 * @method Participation|null find($id, $lockMode = null, $lockVersion = null)
 * @method Participation|null findOneBy(array $criteria, array $orderBy = null)
 * @method Participation[]    findAll()
 * @method Participation[]    findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null)
 */
class ParticipationRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Participation::class);
    }

    /**
     * Finds all participations for a given user, ordered by inscription date descending.
     *
     * @param Utilisateur $user The user entity.
     * @return Participation[] Returns an array of Participation objects.
     */
    public function findByUser(Utilisateur $user): array
    {
        return $this->createQueryBuilder('p')
            ->andWhere('p.utilisateur = :user')
            ->setParameter('user', $user)
            ->orderBy('p.dateInscription', 'DESC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Finds all participations for a given event, ordered by inscription date ascending.
     *
     * @param Event $event The event entity.
     * @return Participation[] Returns an array of Participation objects.
     */
    public function findByEvent(Event $event): array
    {
        return $this->createQueryBuilder('p')
            // Optionally join user if you often need user details with this query
            // ->leftJoin('p.utilisateur', 'u')
            // ->addSelect('u')
            ->andWhere('p.event = :event')
            ->setParameter('event', $event)
            ->orderBy('p.dateInscription', 'ASC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Finds all participations for a given event and status, ordered by inscription date ascending.
     *
     * @param Event $event The event entity.
     * @param ParticipationStatus $status The desired status.
     * @return Participation[] Returns an array of Participation objects.
     */
    public function findByEventAndStatus(Event $event, ParticipationStatus $status): array
    {
        return $this->createQueryBuilder('p')
            ->andWhere('p.event = :event')
            ->andWhere('p.statut = :status')
            ->setParameter('event', $event)
            ->setParameter('status', $status)
            ->orderBy('p.dateInscription', 'ASC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Finds a single participation record for a specific user and event, if it exists.
     * Useful for checking if a user is already registered (active or cancelled).
     *
     * @param Utilisateur $user The user entity.
     * @param Event $event The event entity.
     * @return Participation|null Returns the Participation object or null if not found.
     */
    public function findOneByUserAndEvent(Utilisateur $user, Event $event): ?Participation
    {
        return $this->createQueryBuilder('p')
            ->andWhere('p.utilisateur = :user')
            ->andWhere('p.event = :event')
            ->setParameter('user', $user)
            ->setParameter('event', $event)
            ->setMaxResults(1) // We only need one result
            ->getQuery()
            ->getOneOrNullResult();
    }

    /**
     * Counts the total number of participations for a given event.
     *
     * @param Event $event The event entity.
     * @return int The total count of participations.
     */
    public function countByEvent(Event $event): int
    {
        // Use try-catch for potential NoResultException if needed, though count usually returns 0
        try {
            return (int) $this->createQueryBuilder('p')
                ->select('count(p.id)') // Count primary keys for efficiency
                ->andWhere('p.event = :event')
                ->setParameter('event', $event)
                ->getQuery()
                ->getSingleScalarResult(); // Efficiently gets a single value
        } catch (\Doctrine\ORM\NoResultException | \Doctrine\ORM\NonUniqueResultException $e) {
            // Handle exception or just return 0
            return 0;
        }
    }

    /**
     * Counts the number of participations for a given event with a specific status.
     *
     * @param Event $event The event entity.
     * @param ParticipationStatus $status The status to count.
     * @return int The count of participations with the given status.
     */
    public function countByEventAndStatus(Event $event, ParticipationStatus $status): int
    {
        try {
            return (int) $this->createQueryBuilder('p')
                ->select('count(p.id)')
                ->andWhere('p.event = :event')
                ->andWhere('p.statut = :status') // Add the status condition
                ->setParameter('event', $event)
                ->setParameter('status', $status)
                ->getQuery()
                ->getSingleScalarResult();
        } catch (\Doctrine\ORM\NoResultException | \Doctrine\ORM\NonUniqueResultException $e) {
            return 0;
        }
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/ReponseType.php -----
<?php
// src/Form/ReponseType.php
namespace App\Form;

use App\Entity\Reponse;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\TextareaType;
use Symfony\Component\Form\Extension\Core\Type\SubmitType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class ReponseType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('message', TextareaType::class, [
                'label' => 'Votre Réponse',
                'attr' => ['placeholder' => 'Écrivez votre réponse ici...'],
            ])
            ->add('submit', SubmitType::class, [
                'label' => 'Envoyer la Réponse',
                'attr' => ['class' => 'btn btn-primary'],
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Reponse::class,
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Form/PointRelaisType.php -----
<?php

namespace App\Form;

use App\Entity\PointRelais;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\Extension\Core\Type\DateType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class PointRelaisType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('nom', TextType::class, [
                'required' => true,
                'attr' => [
                    'class' => 'form-control'
                ]
            ])
            ->add('addresse', TextType::class, [
                'required' => true,
                'attr' => [
                    'class' => 'form-control'
                ]
            ])
            ->add('HoraireOuverture', DateType::class, [
                'required' => true,
                'widget' => 'single_text',
                'property_path' => 'HoraireOuverture',
                'attr' => [
                    'class' => 'form-control'
                ]
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => PointRelais::class,
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Form/AdminUserType.php -----
<?php
// src/Form/AdminUserType.php
namespace App\Form;

use App\Entity\Utilisateur;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\CheckboxType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
use Symfony\Component\Form\Extension\Core\Type\EmailType;
use Symfony\Component\Form\Extension\Core\Type\PasswordType;
use Symfony\Component\Form\Extension\Core\Type\RepeatedType;
use Symfony\Component\Form\Extension\Core\Type\TelType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Validator\Constraints\Length;

class AdminUserType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('nom', TextType::class, ['label' => 'Nom'])
            ->add('prenom', TextType::class, ['label' => 'Prénom'])
            ->add('email', EmailType::class, ['label' => 'Email'])
            ->add('telephone', TelType::class, ['label' => 'Téléphone', 'required' => false])
            ->add('roleInterne', ChoiceType::class, [
                'label' => 'Rôle',
                'choices' => [
                    'Client' => 'client',
                    'Partenaire' => 'partenaire',
                    'Administrateur' => 'admin',
                ],
                'attr' => ['class' => 'form-select'],
                'placeholder' => 'Choisir un rôle',
            ])
            ->add('isVerified', CheckboxType::class, [
                'label' => 'Compte Vérifié ?',
                'required' => false,
            ])

            ->add('isActive', CheckboxType::class, [
                'label'    => 'Compte Actif ?',
                'required' => false,
                'row_attr' => ['class' => 'form-check form-switch mb-3'],
                'attr'     => ['class' => 'form-check-input'],
                'label_attr' => ['class' => 'form-check-label'],
                'help'     => 'Décochez pour désactiver l’utilisateur.',
            ])

            ->add('plainPassword', RepeatedType::class, [
                'type' => PasswordType::class,
                'mapped' => false,
                'required' => false,
                'options' => ['attr' => ['autocomplete' => 'new-password']],
                'first_options' => [
                    'label' => 'Nouveau Mot de passe',
                    'help' => 'Laisser vide pour ne pas changer le mot de passe.',
                    'attr' => ['placeholder' => 'Nouveau mot de passe'],
                ],
                'second_options' => [
                    'label' => 'Confirmer le Nouveau Mot de passe',
                    'attr' => ['placeholder' => 'Retapez le mot de passe'],
                ],
                'invalid_message' => 'Les mots de passe doivent correspondre.',
                'constraints' => [
                    new Length([
                        'min' => 6,
                        'minMessage' => 'Le mot de passe doit contenir au moins {{ limit }} caractères.',
                        'max' => 4096,
                    ]),
                ],
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Utilisateur::class,
            'attr' => ['novalidate' => 'novalidate'],
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/ChangePasswordFormType.php -----
<?php
// src/Form/ChangePasswordFormType.php
namespace App\Form;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\PasswordType;
use Symfony\Component\Form\Extension\Core\Type\RepeatedType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Validator\Constraints\Length;
use Symfony\Component\Validator\Constraints\NotBlank;

class ChangePasswordFormType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('plainPassword', RepeatedType::class, [
                'type' => PasswordType::class,
                'options' => [
                    'attr' => [ 'autocomplete' => 'new-password', ],
                ],
                'first_options' => [
                    'constraints' => [
                        new NotBlank([ 'message' => 'Veuillez entrer un mot de passe', ]),
                        new Length([
                            'min' => 6,
                            'minMessage' => 'Votre mot de passe doit contenir au moins {{ limit }} caractères',
                            'max' => 4096,
                        ]),
                    ],
                    'label' => 'Nouveau mot de passe',
                    'attr' => ['placeholder' => 'Entrez le nouveau mot de passe'],
                ],
                'second_options' => [
                    'label' => 'Confirmer le mot de passe',
                    'attr' => ['placeholder' => 'Retapez le nouveau mot de passe'],
                ],
                'invalid_message' => 'Les mots de passe doivent correspondre.',
                'mapped' => false, // Don't map to User entity directly
            ])
        ;
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/ResetPasswordRequestFormType.php -----
<?php
// src/Form/ResetPasswordRequestFormType.php
namespace App\Form;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\EmailType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Validator\Constraints\NotBlank;

class ResetPasswordRequestFormType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('email', EmailType::class, [
                'label' => 'Votre adresse e-mail',
                'attr' => ['autocomplete' => 'email', 'placeholder' => 'adresse@example.com'],
                'constraints' => [
                    new NotBlank([ 'message' => 'Veuillez entrer votre adresse e-mail', ]),
                ],
                'help' => 'Entrez l\'adresse e-mail associée à votre compte.',
            ])
        ;
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/TrottinetteType.php -----
<?php

namespace App\Form;

use App\Entity\Trottinette;
use App\Enum\TrottinetteStatus;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\EnumType;
use Symfony\Component\Form\Extension\Core\Type\IntegerType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Bridge\Doctrine\Form\Type\EntityType;
use App\Entity\PointRelais;

class TrottinetteType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('modele', TextType::class, [
                'label' => 'Modèle',
                'required' => true,
                'attr' => [
                    'class' => 'form-control',
                    'placeholder' => 'Ex: Xiaomi Pro 2',
                ],
                'error_bubbling' => true,
            ])
            ->add('numeroSerie', TextType::class, [
                'label' => 'Numéro de Série',
                'required' => true,
                'attr' => [
                    'class' => 'form-control',
                    'placeholder' => 'Ex: TROT-1234-XYZ',
                ],
                'error_bubbling' => true,
            ])
            ->add('etat', EnumType::class, [
                'class' => TrottinetteStatus::class,
                'label' => 'État',
                'required' => true,
                'choice_label' => function (TrottinetteStatus $choice) {
                    return match($choice) {
                        TrottinetteStatus::DISPONIBLE => 'Disponible',
                        TrottinetteStatus::EN_LOCATION => 'En Location',
                        TrottinetteStatus::EN_MAINTENANCE => 'En Maintenance',
                    };
                },
                'attr' => ['class' => 'form-select'],
                'error_bubbling' => true,
                'placeholder' => 'Sélectionnez un état',
            ])
            ->add('batterie', IntegerType::class, [
                'label' => 'Batterie (%)',
                'required' => false,
                'attr' => [
                    'class' => 'form-control',
                    'placeholder' => 'Ex: 85',
                    'min' => 0,
                    'max' => 100,
                ],
                'error_bubbling' => true,
            ])
            ->add('localisation', TextType::class, [
                'label' => 'Localisation',
                'required' => false,
                'attr' => [
                    'class' => 'form-control',
                    'placeholder' => 'Ex: Tunis Centre',
                ],
                'error_bubbling' => true,
            ])
            ->add('autonomie', TextType::class, [
                'label' => 'Autonomie',
                'required' => false,
                'attr' => [
                    'class' => 'form-control',
                    'placeholder' => 'Ex: 25 km ou 2 heures',
                ],
                'error_bubbling' => true,
            ])
            ->add('pointRelais', EntityType::class, [
                'class' => PointRelais::class,
                'label' => 'Point Relais',
                'choice_label' => 'nom',
                'required' => false,
                'placeholder' => 'Sélectionnez un point relais',
                'attr' => ['class' => 'form-select'],
                'error_bubbling' => true,
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Trottinette::class,
            'html5_validation' => false,
            'attr' => ['novalidate' => 'novalidate'],
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Form/RegistrationFormType.php -----
<?php
// src/Form/RegistrationFormType.php
namespace App\Form;

use App\Entity\Utilisateur;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\CheckboxType; // Add this
use Symfony\Component\Form\Extension\Core\Type\EmailType;
use Symfony\Component\Form\Extension\Core\Type\PasswordType;
use Symfony\Component\Form\Extension\Core\Type\RepeatedType;
use Symfony\Component\Form\Extension\Core\Type\TelType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
// REMOVE HiddenType if it was previously imported for face data
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Validator\Constraints\IsTrue; // Add this
use Symfony\Component\Validator\Constraints\Length;
use Symfony\Component\Validator\Constraints\NotBlank;

class RegistrationFormType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('nom', TextType::class, [
                'label' => 'Nom',
                'attr' => ['placeholder' => 'Votre nom de famille']
            ])
            ->add('prenom', TextType::class, [
                'label' => 'Prénom',
                'attr' => ['placeholder' => 'Votre prénom']
            ])
            ->add('email', EmailType::class, [
                'label' => 'Adresse Email',
                'attr' => ['placeholder' => 'adresse@example.com']
            ])
            ->add('telephone', TelType::class, [
                'label' => 'Numéro de téléphone',
                'attr' => ['placeholder' => 'Ex: +216 XX XXX XXX'],
                'required' => true // Make it required if necessary
            ])
            ->add('plainPassword', RepeatedType::class, [
                'type' => PasswordType::class,
                'options' => ['attr' => ['autocomplete' => 'new-password']],
                'first_options' => [
                    'label' => 'Mot de passe',
                    'attr' => ['placeholder' => 'Minimum 6 caractères'],
                    'constraints' => [
                        new NotBlank(['message' => 'Veuillez entrer un mot de passe.']),
                        new Length([
                            'min' => 6,
                            'minMessage' => 'Votre mot de passe doit contenir au moins {{ limit }} caractères.',
                            'max' => 4096, // Max length supported by Symfony's password hasher
                        ]),
                    ],
                ],
                'second_options' => [
                    'label' => 'Confirmer le mot de passe',
                    'attr' => ['placeholder' => 'Retapez votre mot de passe'],
                ],
                'invalid_message' => 'Les mots de passe doivent correspondre.',
                // Instead of being set onto the object directly,
                // this is read and encoded in the controller
                'mapped' => false, // IMPORTANT: Don't map directly to User entity password
            ])
            ->add('agreeTerms', CheckboxType::class, [ // Add Terms agreement
                'label' => 'J\'accepte les conditions d\'utilisation',
                'mapped' => false, // Not mapped to the User entity directly
                'constraints' => [
                    new IsTrue([
                        'message' => 'Vous devez accepter nos conditions.',
                    ]),
                ],
                'row_attr' => ['class' => 'form-check mb-3'], // Styling for checkbox
                'label_attr' => ['class' => 'form-check-label'],
                'attr' => ['class' => 'form-check-input'],
            ]);

        // --- REMOVE THE face_embedding_data FIELD ---
        // ->add('face_embedding_data', HiddenType::class, [
        //     'mapped' => false, // We handle this manually in the controller
        //     'required' => true, // Make it required
        //     'constraints' => [
        //         new NotBlank([
        //             'message' => 'La capture faciale est requise pour l\'inscription.',
        //         ]),
        //         // Optional: Add a custom constraint to validate the format if needed
        //     ],
        //     'label' => false,
        //     'attr' => ['readonly' => true] // For display, actual value set by JS
        // ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Utilisateur::class,
            'attr' => ['novalidate' => 'novalidate'], // Disable browser validation if using Symfony's
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/ReclamationType.php -----
<?php

// src/Form/ReclamationType.php
namespace App\Form;

use App\Entity\Reclamation;
use App\Entity\Trottinette;
use Symfony\Bridge\Doctrine\Form\Type\EntityType;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
use Symfony\Component\Form\Extension\Core\Type\EmailType;
use Symfony\Component\Form\Extension\Core\Type\TextareaType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class ReclamationType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('type_reclamation', ChoiceType::class, [
                'label' => 'Type de Réclamation',
                'choices' => [
                    'Problème Technique' => 'TECHNIQUE',
                    'Service Client' => 'SERVICE',
                    'Facturation' => 'FACTURATION',
                    'Événement' => 'EVENEMENT',
                    'Autre' => 'AUTRE',
                ],
                'placeholder' => 'Choisissez le type',
                'attr' => ['class' => 'form-select'],
                'required' => true,
            ])
            ->add('user_email', EmailType::class, [
                'label' => 'Email',
                'attr' => ['class' => 'form-control'],
                'required' => true,
            ])
            ->add('trottinette', EntityType::class, [
                'class' => Trottinette::class,
                'choice_label' => 'id', // Affiche uniquement l'ID
                'label' => 'Trottinette (ID)',
                'required' => false,
                'placeholder' => 'Aucune / Non applicable',
                'attr' => ['class' => 'form-select'],
                'query_builder' => function ($er) {
                    return $er->createQueryBuilder('t')->orderBy('t.id', 'ASC');
                },
            ])
            ->add('titre', TextType::class, [
                'label' => 'Sujet / Titre',
                'attr' => ['placeholder' => 'Ex: Problème de frein sur la trottinette #123'],
            ])
            ->add('description', TextareaType::class, [
                'label' => 'Description Détaillée',
                'attr' => ['rows' => 5, 'placeholder' => 'Veuillez décrire le problème ou votre demande...'],
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Reclamation::class,
            'attr' => ['novalidate' => 'novalidate'],
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Form/ProfileType.php -----
<?php
// src/Form/ProfileType.php
namespace App\Form;

use App\Entity\Utilisateur;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\EmailType;
use Symfony\Component\Form\Extension\Core\Type\TelType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
// Add PasswordType/RepeatedType if allowing password change here
// use Symfony\Component\Form\Extension\Core\Type\PasswordType;
// use Symfony\Component\Form\Extension\Core\Type\RepeatedType;
// use Symfony\Component\Validator\Constraints\Length;
// use Symfony\Component\Validator\Constraints\NotBlank;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class ProfileType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('nom', TextType::class, [
                'label' => 'Nom',
                'required' => true,
            ])
            ->add('prenom', TextType::class, [
                'label' => 'Prénom',
                'required' => true,
            ])
            ->add('email', EmailType::class, [
                'label' => 'Adresse Email',
                'required' => true,
                // 'disabled' => true, // Optionally disable email editing
            ])
            ->add('telephone', TelType::class, [
                'label' => 'Téléphone',
                'required' => false, // Make optional if desired
            ]);

        // Optional: Add password change fields
        /*
        ->add('plainPassword', RepeatedType::class, [
            'type' => PasswordType::class,
            'mapped' => false, // Don't map directly to entity password field
            'required' => false, // Password change is optional
            'options' => ['attr' => ['autocomplete' => 'new-password']],
            'first_options' => [
                'label' => 'Nouveau Mot de passe (laisser vide pour ne pas changer)',
                'constraints' => [
                    new Length(['min' => 6, 'max' => 4096]),
                ],
            ],
            'second_options' => [
                'label' => 'Confirmer le nouveau mot de passe',
            ],
            'invalid_message' => 'Les mots de passe doivent correspondre.',
        ])
        */
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Utilisateur::class,
            'attr' => ['novalidate' => 'novalidate'], // Disable browser validation if using Symfony validation
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/MaintenanceType.php -----
<?php

namespace App\Form;

use App\Entity\Maintenance;
use App\Entity\Trottinette;
use Symfony\Bridge\Doctrine\Form\Type\EntityType;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
use Symfony\Component\Form\Extension\Core\Type\DateTimeType;
use Symfony\Component\Form\Extension\Core\Type\TextareaType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class MaintenanceType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('trottinette', EntityType::class, [
                'class' => Trottinette::class,
                'choice_label' => function(Trottinette $trottinette) {
                    return sprintf('%s - %s', $trottinette->getModele(), $trottinette->getNumeroSerie());
                },
                'label' => 'Trottinette',
                'required' => false,
                'attr' => ['class' => 'form-control']
            ])
            ->add('dateDebut', DateTimeType::class, [
                'label' => 'Date de début',
                'required' => false,
                'widget' => 'single_text',
                'attr' => ['class' => 'form-control']
            ])
            ->add('dateFin', DateTimeType::class, [
                'label' => 'Date de fin',
                'required' => false,
                'widget' => 'single_text',
                'attr' => ['class' => 'form-control']
            ])
            ->add('description', TextareaType::class, [
                'label' => 'Description',
                'required' => false,
                'attr' => ['class' => 'form-control', 'rows' => 4]
            ])
            ->add('statut', ChoiceType::class, [
                'label' => 'Statut',
                'required' => false,
                'choices' => [
                    'En cours' => 'EN_COURS',
                    'Terminée' => 'TERMINEE', // ✔ valeur correcte attendue par l'entité
                    'Annulée' => 'ANNULE'
                ],
                'attr' => ['class' => 'form-control']
            ])
            ->add('type', ChoiceType::class, [
                'label' => 'Type de maintenance',
                'choices' => [
                    'Réparation' => 'REPARATION',
                    'Entretien' => 'ENTRETIEN',
                    'Inspection' => 'VERIFICATION',
                ],
                'required' => false,
                'attr' => ['class' => 'form-control']
            ]);
            
            // Add trottinette field at the beginning of the form
            $builder->get('trottinette')->setRequired(true);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Maintenance::class,
            'html5_validation' => false,
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/UserFilterType.php -----
<?php
// src/Form/UserFilterType.php
namespace App\Form;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
use Symfony\Component\Form\Extension\Core\Type\SearchType; // Use SearchType
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class UserFilterType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('search', SearchType::class, [ // Use SearchType for semantics
                'label' => false, // Hide label, use placeholder
                'required' => false,
                'attr' => [
                    'placeholder' => 'Rechercher (Nom, Prénom, Email)...',
                    'class' => 'form-control-sm' // Optional smaller input
                ]
            ])
            ->add('role', ChoiceType::class, [
                'label' => false, // Hide label
                'required' => false,
                'placeholder' => 'Tous les rôles',
                'choices' => [
                    'Client' => 'client',
                    'Partenaire' => 'partenaire',
                    'Administrateur' => 'admin',
                ],
                'attr' => ['class' => 'form-select form-select-sm'] // Optional smaller select
            ]);
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'method' => 'GET', // Use GET for filters
            'csrf_protection' => false, // No CSRF needed for GET filters
            'attr' => ['class' => 'row gx-2 gy-2 align-items-center filter-form'], // Add class for styling form row
        ]);
    }

    // Return empty block prefix to avoid prefixing field names in query string
    public function getBlockPrefix(): string
    {
        return '';
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/ReservationType.php -----
<?php
// src/Form/ReservationType.php
namespace App\Form;

use App\Entity\Reservation;
use App\Entity\Trottinette;
use App\Enum\Paiement;
use App\Enum\ReservationStatus;
use App\Repository\TrottinetteRepository;
use Symfony\Bridge\Doctrine\Form\Type\EntityType;
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\DateTimeType;
use Symfony\Component\Form\Extension\Core\Type\EnumType;
use Symfony\Component\Form\Extension\Core\Type\MoneyType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Security\Core\Security;

class ReservationType extends AbstractType
{
    private Security $security;
    private TrottinetteRepository $trottinetteRepository;

    public function __construct(Security $security, TrottinetteRepository $trottinetteRepository)
    {
        $this->security = $security;
        $this->trottinetteRepository = $trottinetteRepository;
    }

    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('trottinette', EntityType::class, [
                'class' => Trottinette::class,
                'choice_label' => fn(Trottinette $t) => sprintf(
                    '%s (%s - %s%%)',
                    $t->getModele(),
                    $t->getNumeroSerie(),
                    $t->getBatterie() ?? 'N/A'
                ),
                'label' => 'Trottinette à Réserver',
                'placeholder' => 'Sélectionnez une trottinette disponible',
                'attr' => ['class' => 'form-select'],
                'query_builder' => function (TrottinetteRepository $tr) {
                    return $tr->createQueryBuilder('t')
                        ->where('t.etat = :status')
                        ->setParameter('status', \App\Enum\TrottinetteStatus::DISPONIBLE)
                        ->orderBy('t.modele', 'ASC');
                },
                'group_by' => function(Trottinette $choice, $key, $value) {
                    return $choice->getPointRelais()?->getNom() ?? 'Sans Point Relais';
                },
            ])
            ->add('dateDebut', DateTimeType::class, [
                'widget' => 'single_text',
                'label' => 'Début de la Réservation',
                'html5' => true,
                'attr' => ['min' => (new \DateTime('+5 minutes'))->format('Y-m-d\TH:i')],
            ])
            ->add('dateFin', DateTimeType::class, [
                'widget' => 'single_text',
                'label' => 'Fin de la Réservation',
                'html5' => true,
                'attr' => ['min' => (new \DateTime('+10 minutes'))->format('Y-m-d\TH:i')],
            ])
            ->add('montant', MoneyType::class, [
                'label' => 'Montant Estimé',
                'currency' => 'EUR', // Change to TND if needed
                'divisor' => 100,
                'required' => false,
                'attr' => [ 'placeholder' => '0.00' ],
                'help' => 'Le montant sera calculé précisément plus tard.',
            ])
            ->add('paiement', EnumType::class, [
                'class' => Paiement::class,
                'choice_label' => fn (Paiement $choice): string => $choice->label(),
                'label' => 'Méthode de Paiement',
                'placeholder' => 'Sélectionnez un paiement',
                'attr' => ['class' => 'form-select'],
            ])
            ->add('status', EnumType::class, [
                'class' => ReservationStatus::class, // Ensure it's pointing to your enum class
                'choice_label' => fn (ReservationStatus $status): string => $status->label(), // assuming label() method is defined in enum
                'label' => 'Statut Réservation',
                'placeholder' => 'Sélectionnez un statut',
                'attr' => ['class' => 'form-select'],
            ]);
    

        if ($options['is_admin_edit'] ?? false) {
            $builder->add('status', EnumType::class, [
                'class' => ReservationStatus::class,
                'choice_label' => fn (ReservationStatus $choice): string => $choice->label(),
                'label' => 'Statut Réservation',
                'attr' => ['class' => 'form-select'],
                'placeholder' => 'Sélectionnez un statut',
            ]);
        }
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Reservation::class,
            'is_admin_edit' => false,
            'attr' => ['novalidate' => 'novalidate'],
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Form/EventType.php -----
<?php
// src/Form/EventType.php
namespace App\Form;

use App\Entity\Event;
use App\Enum\GouvernoratEnum; // Import Enum
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType; // Keep for status if is_admin_edit
use Symfony\Component\Form\Extension\Core\Type\DateTimeType;
use Symfony\Component\Form\Extension\Core\Type\EnumType; // Use EnumType
use Symfony\Component\Form\Extension\Core\Type\IntegerType; // Use IntegerType
use Symfony\Component\Form\Extension\Core\Type\TextareaType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolver;

class EventType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('titre', TextType::class, [
                'label' => 'Titre de l\'Événement',
                'attr' => ['placeholder' => 'Ex: Balade collective au Parc'],
                'required' => true, // Ensure title is required
            ])
            ->add('description', TextareaType::class, [
                'label' => 'Description',
                'required' => false,
                'attr' => ['rows' => 4, 'placeholder' => 'Décrivez l\'événement...'],
            ])
            ->add('state', EnumType::class, [ // Use EnumType
                'class' => GouvernoratEnum::class,
                'label' => 'Gouvernorat / Lieu',
                'choice_label' => fn (GouvernoratEnum $choice): string => $choice->label(), // Use the label method
                'placeholder' => 'Sélectionnez le lieu',
                'attr' => ['class' => 'form-select'],
                'required' => true, // Ensure lieu is required
            ])
            ->add('dateDebut', DateTimeType::class, [
                'widget' => 'single_text',
                'label' => 'Date et Heure de Début',
                'html5' => true,
                'attr' => ['min' => (new \DateTime())->format('Y-m-d\TH:i')],
                'required' => true, // Ensure date is required
            ])
            ->add('dateFin', DateTimeType::class, [
                'widget' => 'single_text',
                'label' => 'Date et Heure de Fin',
                'html5' => true,
                'attr' => ['min' => (new \DateTime())->format('Y-m-d\TH:i')], // Basic check, validation should enforce dateFin > dateDebut
                'required' => true, // Ensure date is required
            ])
            ->add('trottinetteMinAutonomie', IntegerType::class, [ // Use IntegerType
                'label' => 'Autonomie Minimale Requise (km)',
                'required' => false,
                'attr' => ['placeholder' => 'Ex: 15', 'min' => 0],
                'help' => 'Laissez vide si non applicable.',
            ]);

        // Status field only for Admin edit form
            $builder->add('statut', ChoiceType::class, [
                'label' => 'Statut Événement',
                'choices' => [ // Translate labels
                    'À Venir' => 'A_VENIR',
                    'placeholder' => false,             // no “-- choose --” blank

                    'En Cours' => 'EN_COURS',
                    'Terminé' => 'TERMINE',
                    'Annulé' => 'ANNULE',
                ],
                'attr' => ['class' => 'form-select'],
                'placeholder' => 'Choisir un statut',
            ]);
        }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => Event::class,
            'is_admin_edit' => false, // Custom option
            'attr' => ['novalidate' => 'novalidate'],
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Security/PasswordOnlyAuthenticator.php -----
<?php
// src/Security/PasswordOnlyAuthenticator.php
namespace App\Security;

use App\Entity\Utilisateur;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\Exception\CustomUserMessageAuthenticationException;
use Symfony\Component\Security\Http\Authenticator\AbstractLoginFormAuthenticator;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\RememberMeBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Credentials\PasswordCredentials;
use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
use Symfony\Component\Security\Http\SecurityRequestAttributes;
use Symfony\Component\Security\Http\Util\TargetPathTrait;

class PasswordOnlyAuthenticator extends AbstractLoginFormAuthenticator
{
    use TargetPathTrait;

    // Route specifically for password submission
    public const LOGIN_ROUTE = 'app_login_authenticate_password';

    private UrlGeneratorInterface $urlGenerator;

    public function __construct(UrlGeneratorInterface $urlGenerator)
    {
        $this->urlGenerator = $urlGenerator;
    }

    public function supports(Request $request): bool
    {
        // Only supports the specific password submission route and POST method
        return self::LOGIN_ROUTE === $request->attributes->get('_route')
            && $request->isMethod('POST');
    }

    public function authenticate(Request $request): Passport
    {
        $email = $request->request->get('email', ''); // Expect 'email' from the form
        $password = $request->request->get('password', ''); // Expect 'password'

        if (empty($email) || empty($password)) {
            throw new CustomUserMessageAuthenticationException('Email et mot de passe requis.');
        }

        $request->getSession()->set(SecurityRequestAttributes::LAST_USERNAME, $email);

        return new Passport(
            new UserBadge($email),
            new PasswordCredentials($password),
            [
                // NO CsrfTokenBadge here as per request
                new RememberMeBadge(),
            ]
        );
    }

    public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
    {
        $user = $token->getUser();

        if (!$user instanceof Utilisateur) {
            return new RedirectResponse($this->urlGenerator->generate('app_home'));
        }

        // --- CRITICAL CHECKS ---
        if (!$user->isActive()) {
            // Logout immediately and show message
            // Note: Since we bypassed UserChecker, we need to handle this here.
            $request->getSession()->remove('_security_main'); // Clear potential session token
            throw new CustomUserMessageAccountStatusException('Votre compte a été désactivé.');
        }
        if (!$user->isVerified()) {
            // Logout immediately and show message
            $request->getSession()->remove('_security_main');
            throw new CustomUserMessageAccountStatusException('Votre compte n\'est pas vérifié. Veuillez consulter votre e-mail.');
        }
        // --- END CRITICAL CHECKS ---


        // Redirect logic
        if ($targetPath = $this->getTargetPath($request->getSession(), $firewallName)) {
            return new RedirectResponse($targetPath);
        }

        $roles = $user->getRoles();
        if (in_array('ROLE_ADMIN', $roles, true)) {
            return new RedirectResponse($this->urlGenerator->generate('admin_dashboard'));
        } elseif (in_array('ROLE_PARTENAIRE', $roles, true)) {
            return new RedirectResponse($this->urlGenerator->generate('app_partenaire_dashboard'));
        } else {
            return new RedirectResponse($this->urlGenerator->generate('client_dashboard'));
        }
    }

    protected function getLoginUrl(Request $request): string
    {
        // URL of the page *displaying* the login form
        return $this->urlGenerator->generate('app_login_page');
    }

    // onAuthenticationFailure can remain similar, redirecting back to login page
    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): Response
    {
        if ($request->hasSession()) {
            $request->getSession()->set(SecurityRequestAttributes::AUTHENTICATION_ERROR, $exception);
        }

        $url = $this->getLoginUrl($request);

        return new RedirectResponse($url);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Security/EmailVerifier.php -----
<?php
// src/Security/EmailVerifier.php
namespace App\Security;

use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bridge\Twig\Mime\TemplatedEmail;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Mailer\Exception\TransportExceptionInterface; // Import exception
use Symfony\Component\Mailer\MailerInterface;
use Symfony\Component\Security\Core\User\UserInterface;
use SymfonyCasts\Bundle\VerifyEmail\Exception\VerifyEmailExceptionInterface;
use SymfonyCasts\Bundle\VerifyEmail\VerifyEmailHelperInterface;
use App\Entity\Utilisateur; // Your User class

class EmailVerifier
{
    public function __construct(
        private VerifyEmailHelperInterface $verifyEmailHelper,
        private MailerInterface $mailer,
        private EntityManagerInterface $entityManager
    ) {
    }

    /**
     * @throws TransportExceptionInterface
     */
    public function sendEmailConfirmation(string $verifyEmailRouteName, Utilisateur $user, TemplatedEmail $email): void
    {
        // Ensure the user object is the correct type
        if (!$user instanceof Utilisateur) {
            throw new \LogicException('User must be an instance of ' . Utilisateur::class);
        }
        if (!$user->getId()) {
            throw new \LogicException('User must have an ID to generate verification signature.');
        }
        if (!$user->getEmail()) {
            throw new \LogicException('User must have an email address.');
        }

        $signatureComponents = $this->verifyEmailHelper->generateSignature(
            $verifyEmailRouteName,
            (string) $user->getId(), // Cast ID to string
            $user->getEmail(),
            ['id' => (string) $user->getId()] // Ensure parameters match route requirements
        );

        $context = $email->getContext();
        $context['signedUrl'] = $signatureComponents->getSignedUrl();
        $context['expiresAtMessageKey'] = $signatureComponents->getExpirationMessageKey();
        $context['expiresAtMessageData'] = $signatureComponents->getExpirationMessageData();

        $email->context($context);

        $this->mailer->send($email);
    }

    /**
     * @throws VerifyEmailExceptionInterface
     */
    public function handleEmailConfirmation(Request $request, Utilisateur $user): void
    {
        // Ensure the user object is the correct type
        if (!$user instanceof Utilisateur) {
            throw new \LogicException('User must be an instance of ' . Utilisateur::class);
        }
        if (!$user->getId()) {
            throw new \LogicException('User must have an ID to validate email confirmation.');
        }
        if (!$user->getEmail()) {
            throw new \LogicException('User must have an email address.');
        }

        // The verifyEmailHelper->validateEmailConfirmation() method throws the exception if validation fails
        $this->verifyEmailHelper->validateEmailConfirmation($request->getUri(), (string) $user->getId(), $user->getEmail());

        $user->setIsVerified(true);

        // No need to persist, just flush the change
        $this->entityManager->flush();
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Security/FacialAuthenticator.php -----
<?php
// src/Security/FacialAuthenticator.php
namespace App\Security;

use App\Entity\Utilisateur; // Use your User entity
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse; // For AJAX responses
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\Exception\CustomUserMessageAuthenticationException;
use Symfony\Component\Security\Http\Authenticator\AbstractLoginFormAuthenticator;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\CsrfTokenBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\RememberMeBadge; // Optional
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Credentials\PasswordCredentials;
use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
use Symfony\Component\Security\Http\SecurityRequestAttributes;
use Symfony\Component\Security\Http\Util\TargetPathTrait;

class FacialAuthenticator extends AbstractLoginFormAuthenticator
{
    use TargetPathTrait;

    public const LOGIN_ROUTE = 'app_login_authenticate'; // Define a specific route for the *final* password submission

    private UrlGeneratorInterface $urlGenerator;

    public function __construct(UrlGeneratorInterface $urlGenerator)
    {
        $this->urlGenerator = $urlGenerator;
    }

    /**
     * Does the authenticator support the given Request?
     *
     * Check that the path and method match.
     */
    public function supports(Request $request): bool
    {
        return self::LOGIN_ROUTE === $request->attributes->get('_route')
            && $request->isMethod('POST');
    }

    /**
     * Create a passport for the current request.
     *
     * The passport contains the user, credentials and badges that are used to
     * authenticate the user. (e.g. Passport::END_SIGNAL tells skip credentials verification)
     *
     * @throws AuthenticationException
     */
    public function authenticate(Request $request): Passport
    {
        // This method is only called for the *final* password submission step
        // The email and face verification happen via AJAX calls handled by LoginController
        $email = $request->request->get('email', '');
        $password = $request->request->get('password', '');
        $csrfToken = $request->request->get('_csrf_token', '');
        // The face token is *not* directly handled here, it's checked by FacialUserChecker

        if (empty($email) || empty($password) || empty($csrfToken)) {
            throw new CustomUserMessageAuthenticationException('Email, mot de passe et jeton CSRF requis.');
        }

        $request->getSession()->set(SecurityRequestAttributes::LAST_USERNAME, $email);

        return new Passport(
            new UserBadge($email), // Finds user by email
            new PasswordCredentials($password), // Checks password
            [
                new CsrfTokenBadge('authenticate', $csrfToken), // Checks CSRF
                new RememberMeBadge(), // Optional: Enable "remember me" functionality
                // No custom badge for face token here, UserChecker intercepts earlier
            ]
        );
    }

    /**
     * Called on successfull authentication.
     *
     * @param Request $request
     * @param TokenInterface $token
     * @param string $firewallName The name of the firewall secureing the authenticator
     *
     * @return Response|null Null means continue
     */
    public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
    {
        // Redirect logic based on user roles, similar to your original manual controller
        $user = $token->getUser();

        // Clear the temporary face token from session after successful login
        $request->getSession()->remove('face_recognition_token');


        if (!$user instanceof Utilisateur) {
            // Should not happen if UserBadge works correctly
            return new RedirectResponse($this->urlGenerator->generate('app_home'));
        }

        // Ensure user is active and verified *before* redirecting
        if (!$user->isActive()) {
            // Log user out immediately and show message
            $this->logoutUser($request);
            throw new CustomUserMessageAuthenticationException('Votre compte a été désactivé.');
        }
        if (!$user->isVerified()) {
            // Log user out immediately and show message
            $this->logoutUser($request);
            throw new CustomUserMessageAuthenticationException('Votre compte n\'est pas vérifié. Veuillez consulter votre e-mail.');
        }

        // Redirect based on target path or roles
        if ($targetPath = $this->getTargetPath($request->getSession(), $firewallName)) {
            return new RedirectResponse($targetPath);
        }

        $roles = $user->getRoles();
        if (in_array('ROLE_ADMIN', $roles, true)) {
            return new RedirectResponse($this->urlGenerator->generate('admin_dashboard'));
        } elseif (in_array('ROLE_PARTENAIRE', $roles, true)) {
            return new RedirectResponse($this->urlGenerator->generate('app_partenaire_dashboard'));
        } else {
            return new RedirectResponse($this->urlGenerator->generate('client_dashboard'));
        }
    }

    /**
     * Called on failure. Used for AJAX login to return JSON.
     * For traditional forms, it's usually handled by getLoginUrl().
     *
     * @return Response
     */
    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): Response
    {
        // Store error in session to display on the login page
        // Use a specific key for facial login errors
        $request->getSession()->set(SecurityRequestAttributes::AUTHENTICATION_ERROR, $exception);

        // Ensure the temporary face token is cleared on failure too
        $request->getSession()->remove('face_recognition_token');

        // Return JSON response indicating failure for the AJAX call
        return new JsonResponse([
            'success' => false,
            // Use a generic message for security, details are in the exception if needed
            'message' => strtr($exception->getMessageKey(), $exception->getMessageData())
            // 'message' => 'Identifiants invalides ou erreur d\'authentification.'
        ], Response::HTTP_UNAUTHORIZED); // Use 401 status code
    }

    /**
     * Return the URL to the login page.
     */
    protected function getLoginUrl(Request $request): string
    {
        // URL of the page displaying the login form (not the processing route)
        return $this->urlGenerator->generate('app_login_page');
    }

    /**
     * Helper to logout user if needed during success check (e.g., inactive/unverified)
     */
    private function logoutUser(Request $request): void
    {
        // Invalidating the session and removing the token manually
        // This requires TokenStorageInterface, SessionInterface - inject if needed
        // Or rely on security system logout handlers if configured
        // For simplicity here, just clear the session attribute if set
        $request->getSession()->remove('_security_main'); // Adjust 'main' if firewall name differs
        $request->getSession()->remove('face_recognition_token');
        // Potentially call tokenStorage->setToken(null) if available
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Security/FacialUserChecker.php -----
<?php
// src/Security/FacialUserChecker.php
namespace App\Security;

use App\Entity\Utilisateur; // Your User entity
use Symfony\Component\HttpFoundation\RequestStack;
use Symfony\Component\Security\Core\Exception\CustomUserMessageAccountStatusException;
use Symfony\Component\Security\Core\User\UserCheckerInterface;
use Symfony\Component\Security\Core\User\UserInterface;

class FacialUserChecker implements UserCheckerInterface
{
    private RequestStack $requestStack;

    public function __construct(RequestStack $requestStack)
    {
        $this->requestStack = $requestStack;
    }

    /**
     * Checks the user account before authentication.
     * Verifies the temporary face recognition token.
     */
    public function checkPreAuth(UserInterface $user): void
    {
        if (!$user instanceof Utilisateur) {
            return; // Only check for your specific user type
        }

        $request = $this->requestStack->getCurrentRequest();
        if (!$request) {
            // Should not happen in a web context, but good practice
            throw new CustomUserMessageAccountStatusException("Contexte de requête introuvable.");
        }

        // Get the token submitted with the password form
        $submittedToken = $request->request->get('face_token'); // Name this field in your login JS final POST

        // Get the token stored in the session during face verification step
        $session = $this->requestStack->getSession();
        $expectedToken = $session->get('face_recognition_token');

        // Basic check: Is a token expected for this login attempt?
        // If $expectedToken is null, maybe allow standard password login?
        // For strict facial+password, we require $expectedToken.
        if ($expectedToken === null) {
            throw new CustomUserMessageAccountStatusException("Session de reconnaissance faciale invalide ou expirée. Veuillez recommencer.");
        }

        // Compare the tokens
        if (empty($submittedToken) || !hash_equals((string)$expectedToken, (string)$submittedToken)) {
            // Clear the session token on mismatch to force restart
            $session->remove('face_recognition_token');
            // Throw exception to block login
            throw new CustomUserMessageAccountStatusException("Jeton de reconnaissance faciale invalide ou manquant. Connexion bloquée.");
        }

        // Token is valid! It will be cleared in onAuthenticationSuccess of the authenticator.
        // Don't clear it here yet, as password check might still fail.
    }

    /**
     * Checks the user account after authentication.
     * (Can check for inactive, banned status here if not done elsewhere)
     */
    public function checkPostAuth(UserInterface $user): void
    {
        if (!$user instanceof Utilisateur) {
            return;
        }

        // Example: Check if account is active (can also be done in onAuthenticationSuccess)
        // if (!$user->isActive()) {
        //     throw new CustomUserMessageAccountStatusException('Votre compte est désactivé.');
        // }
        // Example: Check if email is verified (can also be done in onAuthenticationSuccess)
        // if (!$user->isVerified()) {
        //     throw new CustomUserMessageAccountStatusException('Votre compte n\'est pas vérifié.');
        // }
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Security/LoginFormAuthenticator.php -----
<?php
// src/Security/LoginFormAuthenticator.php
namespace App\Security;

use App\Entity\Utilisateur;
use Doctrine\ORM\EntityManagerInterface; // Needed if checking isVerified status before login attempt potentially
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\CustomUserMessageAuthenticationException;
use Symfony\Component\Security\Core\Security; // Deprecated, use SecurityRequestAttributes
use Symfony\Component\Security\Http\Authenticator\AbstractLoginFormAuthenticator;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\CsrfTokenBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\RememberMeBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Credentials\PasswordCredentials;
use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
use Symfony\Component\Security\Http\Util\TargetPathTrait;
use Symfony\Component\Security\Http\SecurityRequestAttributes; // Use this


class LoginFormAuthenticator extends AbstractLoginFormAuthenticator
{
    use TargetPathTrait;

    public const LOGIN_ROUTE = 'app_login';

    private UrlGeneratorInterface $urlGenerator;
    // private EntityManagerInterface $entityManager; // Inject if needed

    public function __construct(UrlGeneratorInterface $urlGenerator /*, EntityManagerInterface $entityManager*/)
    {
        $this->urlGenerator = $urlGenerator;
        // $this->entityManager = $entityManager;
    }

    public function authenticate(Request $request): Passport
    {
        $email = $request->request->get('email', '');

        $request->getSession()->set(SecurityRequestAttributes::LAST_USERNAME, $email);

        return new Passport(
            new UserBadge($email),
            new PasswordCredentials($request->request->get('password', '')),
            [
                new CsrfTokenBadge('authenticate', $request->request->get('_csrf_token')),
                new RememberMeBadge(),
            ]
        );
    }

    public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
    {
        // Check if the user's email is verified BEFORE allowing login success
        $user = $token->getUser();
        if ($user instanceof Utilisateur && !$user->isActive()) {
            throw new CustomUserMessageAuthenticationException('Votre compte a été désactivé.');
        }
        if ($user instanceof Utilisateur && !$user->isVerified()) {
            // Optionally flash a message
            $this->addFlash($request, 'warning', 'Votre compte n\'est pas encore vérifié. Veuillez consulter votre email.');

            // Throw an exception to prevent login - this will redirect to login page with the flash message
            // You might want a custom exception if you want different handling
            throw new CustomUserMessageAuthenticationException('Compte non vérifié.');

            // Alternative: Redirect explicitly, but user remains technically authenticated for this request
            // return new RedirectResponse($this->urlGenerator->generate('app_login'));
        }


        if ($targetPath = $this->getTargetPath($request->getSession(), $firewallName)) {
            return new RedirectResponse($targetPath);
        }

        // Redirect based on role
        if ($user instanceof Utilisateur) { // Check if user object is available
            if (in_array('ROLE_ADMIN', $user->getRoles(), true)) {
                return new RedirectResponse($this->urlGenerator->generate('app_admin_dashboard'));
            }
            if (in_array('ROLE_PARTENAIRE', $user->getRoles(), true)) {
                return new RedirectResponse($this->urlGenerator->generate('app_partenaire_dashboard'));
            }
            // Default for ROLE_USER or others
            return new RedirectResponse($this->urlGenerator->generate('client_dashboard')); // Default to client dashboard
        }

        // Fallback redirect
        return new RedirectResponse($this->urlGenerator->generate('app_home'));
    }

    protected function getLoginUrl(Request $request): string
    {
        return $this->urlGenerator->generate(self::LOGIN_ROUTE);
    }

    // Helper function to add flash messages
    private function addFlash(Request $request, string $type, string $message): void
    {
        // Check if the session factory is available
        if ($request->hasSession()) {
            $request->getSession()->getFlashBag()->add($type, $message);
        }
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Maintenance.php -----
<?php

namespace App\Entity;

use App\Repository\MaintenanceRepository;
use Doctrine\ORM\Mapping as ORM;
use DateTime;
use Symfony\Component\Validator\Constraints as Assert;

#[ORM\Entity(repositoryClass: MaintenanceRepository::class)]
#[ORM\Table(name: 'maintenance')]
class Maintenance
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\Column(name: "trottinetteId", type: "integer")]
    private ?int $trottinetteId = null;

    #[ORM\ManyToOne(targetEntity: Trottinette::class)]
    #[ORM\JoinColumn(name: 'trottinetteId', referencedColumnName: 'id', nullable: false)]
    #[Assert\NotNull(message: 'Une trottinette doit être associée à la maintenance.')]
    private ?Trottinette $trottinette = null;

    #[ORM\Column(type: 'text')]
    #[Assert\NotBlank(message: 'La description ne peut pas être vide.')]
    #[Assert\Length(
        min: 10,
        minMessage: 'La description doit comporter au moins {{ limit }} caractères.'
    )]
    private string $description;

    #[ORM\Column(name: 'dateDebut', type: 'datetime')]
    #[Assert\NotNull(message: 'La date de début est requise.')]
    #[Assert\Type("\DateTime", message: 'La valeur {{ value }} n\'est pas une date valide.')]
    private DateTime $dateDebut;

    #[ORM\Column(name: 'dateFin', type: 'datetime', nullable: true)]
    #[Assert\Type("\DateTime", message: 'La valeur {{ value }} n\'est pas une date valide.')]
    #[Assert\GreaterThan(
        propertyPath: "dateDebut",
        message: "La date de fin doit être postérieure à la date de début."
    )]
    private ?DateTime $dateFin = null;

    #[ORM\Column(name: "statut", type: "string", columnDefinition: "ENUM('EN_COURS','TERMINEE','ANNULEE')")]
    #[Assert\NotBlank(message: 'Le statut ne peut pas être vide.')]
    #[Assert\Choice(
        choices: ['EN_COURS', 'TERMINEE', 'ANNULEE'],
        message: 'Le statut choisi n\'est pas valide. Statuts autorisés: EN_COURS, TERMINEE, ANNULEE.'
    )]
    private ?string $statut = null;

    /**
     * Virtual property for type that is not mapped to database
     * Use this for forms and display but don't persist it
     */
    #[Assert\Choice(
        choices: ['REPARATION', 'ENTRETIEN', 'VERIFICATION'],
        message: 'Le type choisi n\'est pas valide. Types autorisés: REPARATION, ENTRETIEN, VERIFICATION.'
    )]
    private ?string $type = null;

    public function __construct()
    {
        $this->dateDebut = new DateTime();
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getTrottinetteId(): ?int
    {
        return $this->trottinetteId;
    }

    public function setTrottinetteId(?int $trottinetteId): self
    {
        $this->trottinetteId = $trottinetteId;
        return $this;
    }

    public function getTrottinette(): ?Trottinette
    {
        return $this->trottinette;
    }

    public function setTrottinette(?Trottinette $trottinette): self
    {
        $this->trottinette = $trottinette;
        return $this;
    }

    public function getDateDebut(): DateTime
    {
        return $this->dateDebut;
    }

    public function setDateDebut(DateTime $dateDebut): self
    {
        $this->dateDebut = $dateDebut;
        return $this;
    }

    public function getDateFin(): ?DateTime
    {
        return $this->dateFin;
    }

    public function setDateFin(?DateTime $dateFin): self
    {
        $this->dateFin = $dateFin;
        return $this;
    }

    public function getDescription(): string
    {
        return $this->description;
    }

    public function setDescription(string $description): self
    {
        $this->description = $description;
        return $this;
    }

    public function getStatut(): ?string
    {
        return $this->statut;
    }

    public function setStatut(string $statut): self
    {
        $this->statut = $statut;
        return $this;
    }

    public function getType(): ?string
    {
        return $this->type;
    }

    public function setType(?string $type): self
    {
        $this->type = $type;
        return $this;
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Event.php -----
<?php
// src/Entity/Event.php
namespace App\Entity;

use App\Enum\GouvernoratEnum; // Import Enum
use App\Repository\EventRepository;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Doctrine\DBAL\Types\Types;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Validator\Constraints as Assert;
use DateTimeInterface; // Use DateTimeInterface

#[ORM\Entity(repositoryClass: EventRepository::class)]
#[ORM\Table(name: 'event')]
class Event
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\Column(length: 255)] // Removed nullable=true, added constraints
    #[Assert\NotBlank(message: "Le titre de l'événement est obligatoire.")]
    #[Assert\Length(min: 5, max: 255, minMessage: "Le titre doit faire entre 5 et 255 caractères.")]
    private ?string $titre = null;

    #[ORM\Column(type: Types::TEXT, nullable: true)]
    private ?string $description = null;

    #[ORM\Column(name: "dateDebut", type: Types::DATETIME_MUTABLE)] // Removed name, nullable=true, added constraints
    #[Assert\NotNull(message: "La date de début est obligatoire.")]
    #[Assert\Type("\DateTimeInterface")]
    #[Assert\GreaterThanOrEqual("today", message: "La date de début ne peut être dans le passé.")]
    private ?DateTimeInterface $dateDebut = null;

    #[ORM\Column(name: "dateFin", type: Types::DATETIME_MUTABLE)] // Removed name, nullable=true, added constraints
    #[Assert\NotNull(message: "La date de fin est obligatoire.")]
    #[Assert\Type("\DateTimeInterface")]
    #[Assert\GreaterThan(propertyPath: "dateDebut", message: "La date de fin doit être après la date de début.")]
    private ?DateTimeInterface $dateFin = null;

    #[ORM\Column(length: 50, enumType: GouvernoratEnum::class)] // Use EnumType, set length, removed nullable
    #[Assert\NotNull(message: "Le lieu (gouvernorat) est obligatoire.")]
    private ?GouvernoratEnum $state = null;

    #[ORM\Column(type: 'string', length: 50, options: ["default" => "A_VENIR"])] // Define length, use string type
    #[Assert\Choice(choices: ["A_VENIR", "EN_COURS", "TERMINE", "ANNULE"], message: "Statut d'événement invalide.")]
    private string $statut = 'A_VENIR';

    #[ORM\Column(name: "trottinetteMinAutonomie",type: 'integer', nullable: true)] // Removed name, changed type
    #[Assert\PositiveOrZero(message: "L'autonomie minimale doit être un nombre positif ou zéro.")]
    private ?int $trottinetteMinAutonomie = 0; // In km, assume default 0

    #[ORM\OneToMany(mappedBy: 'event', targetEntity: Participation::class, cascade: ['persist', 'remove'], orphanRemoval: true)]
    private Collection $participations;

    // Removed $state and $gouvernorat properties

    public function __construct()
    {
        $this->participations = new ArrayCollection();
    }

    // Getters and Setters (Standard - ensure type hints match)
    public function getId(): ?int { return $this->id; }
    public function getTitre(): ?string { return $this->titre; }
    public function setTitre(?string $titre): static { $this->titre = $titre; return $this; }
    public function getDescription(): ?string { return $this->description; }
    public function setDescription(?string $description): static { $this->description = $description; return $this; }
    public function getDateDebut(): ?DateTimeInterface { return $this->dateDebut; }
    public function setDateDebut(?DateTimeInterface $dateDebut): static { $this->dateDebut = $dateDebut; return $this; }
    public function getDateFin(): ?DateTimeInterface { return $this->dateFin; }
    public function setDateFin(?DateTimeInterface $dateFin): static { $this->dateFin = $dateFin; return $this; }
    public function getState(): ?GouvernoratEnum { return $this->state; } // Return Enum
    public function setState(?GouvernoratEnum $state): static { $this->state = $state; return $this; } // Accept Enum
    public function getStatut(): string { return $this->statut; }
    public function setStatut(string $statut): static { $this->statut = $statut; return $this; }
    public function getTrottinetteMinAutonomie(): ?int { return $this->trottinetteMinAutonomie; }
    public function setTrottinetteMinAutonomie(?int $trottinetteMinAutonomie): static { $this->trottinetteMinAutonomie = $trottinetteMinAutonomie; return $this; }

    /** @return Collection<int, Participation> */
    public function getParticipations(): Collection { return $this->participations; }
    public function addParticipation(Participation $participation): static { if (!$this->participations->contains($participation)) { $this->participations->add($participation); $participation->setEvent($this); } return $this; }
    public function removeParticipation(Participation $participation): static { if ($this->participations->removeElement($participation)) { if ($participation->getEvent() === $this) { $participation->setEvent(null); } } return $this; }

    // Helper for display
    public function getLieuValue(): ?string { return $this->state?->value; }

    public function __toString(): string
    {
        return $this->titre ?? 'Événement Inconnu';
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Reponse.php -----
<?php
// src/Entity/Reponse.php
namespace App\Entity;

use App\Repository\ReponseRepository;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Validator\Constraints as Assert;
use DateTimeInterface;

#[ORM\Entity(repositoryClass: ReponseRepository::class)]
#[ORM\Table(name: 'reponse_reclamation')] // Nom spécifique de la table
class Reponse
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private ?int $id = null;

    #[ORM\ManyToOne(targetEntity: Reclamation::class, inversedBy: 'reponses')]
    #[ORM\JoinColumn(nullable: false)]
    private ?Reclamation $reclamation = null;

    #[ORM\ManyToOne(targetEntity: Utilisateur::class)]
    #[ORM\JoinColumn(name: 'auteur_id', referencedColumnName: 'id', nullable: false)]
    #[Assert\NotNull(message: "L'auteur de la réponse est requis.")]
    private ?Utilisateur $auteur = null;

    #[ORM\Column(type: 'text')]
    #[Assert\NotBlank(message: 'Le message ne peut pas être vide.')]
    #[Assert\Length(min: 5, minMessage: 'La réponse doit faire au moins {{ limit }} caractères.')]
    private ?string $message = null;

    #[ORM\Column(type: 'datetime')]
    private ?DateTimeInterface $dateReponse = null;

    public function __construct()
    {
        $this->dateReponse = new \DateTime(); // Date de création par défaut
    }

    // Getters and Setters
    public function getId(): ?int { return $this->id; }
    public function getReclamation(): ?Reclamation { return $this->reclamation; }
    public function setReclamation(?Reclamation $reclamation): self { $this->reclamation = $reclamation; return $this; }

    public function getAuteur(): ?Utilisateur { return $this->auteur; }
    public function setAuteur(?Utilisateur $auteur): self { $this->auteur = $auteur; return $this; }

    public function getMessage(): ?string { return $this->message; }
    public function setMessage(string $message): self { $this->message = $message; return $this; }

    public function getDateReponse(): ?DateTimeInterface { return $this->dateReponse; }
    public function setDateReponse(DateTimeInterface $dateReponse): self { $this->dateReponse = $dateReponse; return $this; }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Utilisateur.php -----
<?php
// src/Entity/Utilisateur.php
namespace App\Entity;

use App\Repository\UtilisateurRepository;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
use Symfony\Component\Security\Core\User\UserInterface;
use Symfony\Component\Validator\Constraints as Assert;
use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;

#[ORM\Entity(repositoryClass: UtilisateurRepository::class)]
#[ORM\Table(name: 'utilisateurs')]
#[UniqueEntity(fields: ['email'], message: 'Cette adresse email est déjà utilisée.')]
class Utilisateur implements UserInterface, PasswordAuthenticatedUserInterface
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\Column(length: 180, unique: true)]
    #[Assert\NotBlank(message: 'L\'email ne peut pas être vide.')]
    #[Assert\Email(message: 'L\'adresse email {{ value }} n\'est pas valide.')]
    #[Assert\Length(max: 180, maxMessage: 'L\'email ne peut pas dépasser {{ limit }} caractères.')]
    private ?string $email = null;

    /**
     * Internal role representation (simple string) - Corrected column name
     */
    #[ORM\Column(name: "role_interne", length: 50)]
    #[Assert\NotBlank(message: 'Le rôle ne peut pas être vide.')]
    #[Assert\Choice(
        choices: ['admin', 'client', 'partenaire'],
        message: 'Le rôle choisi n\'est pas valide. Rôles autorisés: admin, client, partenaire.'
    )]
    private string $roleInterne = 'client'; // Default role

    /**
     * @var string The hashed password - Corrected column name mapping
     */
    #[ORM\Column(name: "password")] // Map to 'password' column if changed from mot_de_passe_hash
    private ?string $password = null;

    #[ORM\Column(length: 255, name: "nom")]
    #[Assert\NotBlank(message: 'Le nom ne peut pas être vide.')]
    #[Assert\Length(min: 2, max: 255, minMessage: 'Le nom doit comporter au moins {{ limit }} caractères.', maxMessage: 'Le nom ne peut pas dépasser {{ limit }} caractères.')]
    private ?string $nom = null;

    #[ORM\Column(length: 255, name: "prenom")]
    #[Assert\NotBlank(message: 'Le prénom ne peut pas être vide.')]
    #[Assert\Length(min: 2, max: 255, minMessage: 'Le prénom doit comporter au moins {{ limit }} caractères.', maxMessage: 'Le prénom ne peut pas dépasser {{ limit }} caractères.')]
    private ?string $prenom = null;

    #[ORM\Column(length: 50, name: "telephone")]
    #[Assert\NotBlank(message: 'Le numéro de téléphone ne peut pas être vide.')]
    #[Assert\Regex(pattern: '/^[0-9+\s\-().]{8,15}$/', message: 'Le numéro de téléphone n\'est pas valide.')]
    private ?string $telephone = null;

    #[ORM\Column(type: 'boolean')]
    private bool $isVerified = false;

    #[ORM\Column(type: 'boolean', options: ['default' => true])]
    private bool $isActive = true;

    // --- NEW: Facial Recognition Embedding ---
    #[ORM\Column(type: 'text', nullable: true)]
    private ?string $faceEmbedding = null;
    // --- END NEW ---

    #[ORM\OneToMany(mappedBy: 'utilisateur', targetEntity: Reservation::class, cascade: ['persist', 'remove'], orphanRemoval: true)]
    private Collection $reservations;

    #[ORM\OneToMany(mappedBy: 'utilisateur', targetEntity: Reclamation::class, cascade: ['persist', 'remove'], orphanRemoval: true)]
    private Collection $reclamations;

    #[ORM\OneToMany(mappedBy: 'utilisateur', targetEntity: Participation::class, cascade: ['persist', 'remove'], orphanRemoval: true)]
    private Collection $participations;

    // Removed Trottinettes collection unless explicit partner relation needed

    public function __construct()
    {
        $this->reservations = new ArrayCollection();
        $this->reclamations = new ArrayCollection();
        $this->participations = new ArrayCollection();
    }

    // --- GETTERS AND SETTERS ---

    public function getId(): ?int { return $this->id; }
    public function getEmail(): ?string { return $this->email; }
    public function setEmail(string $email): static { $this->email = $email; return $this; }

    /** @see UserInterface */
    public function getUserIdentifier(): string { return (string) $this->email; }

    public function isActive(): bool { return $this->isActive; }
    public function setIsActive(bool $isActive): static { $this->isActive = $isActive; return $this; }

    /** @see UserInterface */
    public function getRoles(): array
    {
        $roleMap = [
            'admin' => ['ROLE_ADMIN', 'ROLE_PARTENAIRE', 'ROLE_USER'],
            'partenaire' => ['ROLE_PARTENAIRE', 'ROLE_USER'],
            'client' => ['ROLE_USER']
        ];
        $roles = $roleMap[$this->roleInterne] ?? ['ROLE_USER'];
        $roles[] = 'ROLE_USER'; // Guarantee ROLE_USER
        return array_unique($roles);
    }

    public function getRoleInterne(): string { return $this->roleInterne; }
    public function setRoleInterne(string $roleInterne): static {
        if (!in_array($roleInterne, ['admin', 'client', 'partenaire'])) {
            throw new \InvalidArgumentException("Invalid role");
        }
        $this->roleInterne = $roleInterne;
        return $this;
    }

    /** @see PasswordAuthenticatedUserInterface */
    public function getPassword(): ?string { return $this->password; } // Return nullable
    public function setPassword(string $password): static { $this->password = $password; return $this; }

    /** @see UserInterface */
    public function getSalt(): ?string { return null; } // Not needed

    /** @see UserInterface */
    public function eraseCredentials(): void { /* $this->plainPassword = null; */ }

    public function getNom(): ?string { return $this->nom; }
    public function setNom(string $nom): static { $this->nom = $nom; return $this; }
    public function getPrenom(): ?string { return $this->prenom; }
    public function setPrenom(string $prenom): static { $this->prenom = $prenom; return $this; }
    public function getTelephone(): ?string { return $this->telephone; }
    public function setTelephone(?string $telephone): static { $this->telephone = $telephone; return $this; }
    public function isVerified(): bool { return $this->isVerified; }
    public function setIsVerified(bool $isVerified): static { $this->isVerified = $isVerified; return $this; }
    public function getFullName(): string { return $this->prenom . ' ' . $this->nom; }

    // --- NEW: Getters and Setters for Face Embedding ---
    public function getFaceEmbedding(): ?string
    {
        return $this->faceEmbedding;
    }

    public function setFaceEmbedding(?string $faceEmbedding): static
    {
        $this->faceEmbedding = $faceEmbedding;
        return $this;
    }
    // --- END NEW ---


    // --- Collection Methods ---
    /** @return Collection<int, Reservation> */
    public function getReservations(): Collection { return $this->reservations; }
    public function addReservation(Reservation $reservation): static { if (!$this->reservations->contains($reservation)) { $this->reservations->add($reservation); $reservation->setUtilisateur($this); } return $this; }
    public function removeReservation(Reservation $reservation): static { if ($this->reservations->removeElement($reservation)) { if ($reservation->getUtilisateur() === $this) { $reservation->setUtilisateur(null); } } return $this; }
    /** @return Collection<int, Reclamation> */
    public function getReclamations(): Collection { return $this->reclamations; }
    public function addReclamation(Reclamation $reclamation): static { if (!$this->reclamations->contains($reclamation)) { $this->reclamations->add($reclamation); $reclamation->setUtilisateur($this); } return $this; }
    public function removeReclamation(Reclamation $reclamation): static { if ($this->reclamations->removeElement($reclamation)) { if ($reclamation->getUtilisateur() === $this) { $reclamation->setUtilisateur(null); } } return $this; }
    /** @return Collection<int, Participation> */
    public function getParticipations(): Collection { return $this->participations; }
    public function addParticipation(Participation $participation): static { if (!$this->participations->contains($participation)) { $this->participations->add($participation); $participation->setUtilisateur($this); } return $this; }
    public function removeParticipation(Participation $participation): static { if ($this->participations->removeElement($participation)) { if ($participation->getUtilisateur() === $this) { $participation->setUtilisateur(null); } } return $this; }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/PointRelais.php -----
<?php

namespace App\Entity;

use App\Repository\PointRelaisRepository;
use Doctrine\DBAL\Types\Types;
use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity(repositoryClass: PointRelaisRepository::class)]
class PointRelais
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\Column(length: 255)]
    #[Assert\NotBlank(message: 'Le nom est obligatoire.')]
    #[Assert\Length(
        max: 255,
        maxMessage: 'Le nom ne peut pas dépasser {{ limit }} caractères.'
    )]
    private ?string $nom = null;

    #[ORM\Column(length: 255)]
    #[Assert\NotBlank(message: 'L\'adresse est obligatoire.')]
    #[Assert\Length(
        max: 255,
        maxMessage: 'L\'adresse ne peut pas dépasser {{ limit }} caractères.'
    )]
    private ?string $addresse = null;

    #[ORM\Column(type: Types::DATE_MUTABLE)]
    #[Assert\NotBlank(message: 'La date d\'ouverture est obligatoire.')]
    #[Assert\Type(
        type: \DateTimeInterface::class,
        message: 'La valeur {{ value }} n\'est pas une date valide.'
    )]
    private ?\DateTimeInterface $HoraireOuverture = null;

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getNom(): ?string
    {
        return $this->nom;
    }

    public function setNom(?string $nom): static
    {
        $this->nom = $nom;

        return $this;
    }

    public function getAddresse(): ?string
    {
        return $this->addresse;
    }

    public function setAddresse(?string $addresse): static
    {
        $this->addresse = $addresse;

        return $this;
    }

    public function getHoraireOuverture(): ?\DateTimeInterface
    {
        return $this->HoraireOuverture;
    }

    public function setHoraireOuverture(?\DateTimeInterface $HoraireOuverture): static
    {
        $this->HoraireOuverture = $HoraireOuverture;

        return $this;
    }


    public function __toString(): string
    {
        return $this->nom ?? 'PointRelais';
    }

}



----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Participation.php -----
<?php

namespace App\Entity;

use App\Repository\ParticipationRepository;
use App\Enum\ParticipationStatus;
use Doctrine\ORM\Mapping as ORM;
use DateTime;
use DateTimeInterface;

#[ORM\Entity(repositoryClass: ParticipationRepository::class)]
#[ORM\Table(name: 'participation')]
class Participation
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\ManyToOne(targetEntity: Event::class, inversedBy: 'participations')]
    #[ORM\JoinColumn(name: 'eventId', referencedColumnName: 'id', nullable: false)]
    private ?Event $event = null;

    #[ORM\Column(name: 'dateInscription', type: 'datetime', nullable: true)]
    private ?DateTimeInterface $dateInscription = null;

    #[ORM\Column(name: 'statut', type: 'string', enumType: ParticipationStatus::class)]
    private ?ParticipationStatus $statut = null;

    #[ORM\ManyToOne(targetEntity: Utilisateur::class, inversedBy: 'participations')]
    #[ORM\JoinColumn(name: 'utilisateurId', referencedColumnName: 'id', nullable: true)]
    private ?Utilisateur $utilisateur = null;

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getEvent(): ?Event
    {
        return $this->event;
    }

    public function setEvent(?Event $event): static
    {
        $this->event = $event;
        return $this;
    }

    public function getDateInscription(): ?DateTimeInterface
    {
        return $this->dateInscription;
    }

    public function setDateInscription(?DateTimeInterface $dateInscription): static
    {
        $this->dateInscription = $dateInscription;
        return $this;
    }

    public function getStatut(): ?ParticipationStatus
    {
        return $this->statut;
    }

    public function setStatut(ParticipationStatus $statut): static
    {
        $this->statut = $statut;
        return $this;
    }

    public function getUtilisateur(): ?Utilisateur
    {
        return $this->utilisateur;
    }

    public function setUtilisateur(?Utilisateur $utilisateur): static
    {
        $this->utilisateur = $utilisateur;
        return $this;
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Reservation.php -----
<?php
// src/Entity/Reservation.php
namespace App\Entity;

use App\Repository\ReservationRepository;
use Doctrine\DBAL\Types\Types;
use Doctrine\ORM\Mapping as ORM;
use App\Enum\Paiement;
use App\Enum\ReservationStatus;
use Symfony\Component\Validator\Constraints as Assert;
use DateTimeInterface;

#[ORM\Entity(repositoryClass: ReservationRepository::class)]
#[ORM\Table(name: 'reservation')] // Explicit table name
class Reservation
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\ManyToOne(targetEntity: Utilisateur::class, inversedBy: 'reservations')]
    #[ORM\JoinColumn(name: 'utilisateur_id', referencedColumnName: 'id', nullable: false)]
    #[Assert\NotNull(message: 'L\'utilisateur est requis.')]
    private ?Utilisateur $utilisateur = null;

    #[ORM\ManyToOne(targetEntity: Trottinette::class, inversedBy: 'reservations')]
    #[ORM\JoinColumn(name: 'trottinette_id', referencedColumnName: 'id', nullable: false)]
    #[Assert\NotNull(message: 'La trottinette est requise.')]
    private ?Trottinette $trottinette = null;

    #[ORM\Column(type: Types::DATETIME_MUTABLE)] // Changed name
    #[Assert\NotNull(message: 'La date de début de réservation est obligatoire.')]
    #[Assert\Type("\DateTimeInterface")]
    #[Assert\GreaterThanOrEqual("today", message: "La date de début ne peut pas être dans le passé.")]
    private ?DateTimeInterface $dateDebut = null;

    #[ORM\Column(type: Types::DATETIME_MUTABLE)] // Added dateFin
    #[Assert\NotNull(message: 'La date de fin de réservation est obligatoire.')]
    #[Assert\Type("\DateTimeInterface")]
    #[Assert\GreaterThan(propertyPath: "dateDebut", message: "La date de fin doit être postérieure à la date de début.")]
    private ?DateTimeInterface $dateFin = null;

    #[ORM\Column(type: Types::DECIMAL, precision: 10, scale: 2)] // Use scale 2 for currency
    #[Assert\NotBlank(message: 'Le montant est requis.')]
    #[Assert\PositiveOrZero(message: 'Le montant doit être positif ou nul.')] // Changed to PositiveOrZero
    private ?string $montant = null;

    #[ORM\Column(type: Types::STRING, enumType: ReservationStatus::class)]
    #[Assert\NotNull(message: 'Le statut est requis.')]
    private ?ReservationStatus $status = ReservationStatus::PENDING; // Default

    #[ORM\Column(type: Types::STRING, enumType: Paiement::class)]
    #[Assert\NotNull(message: 'Le mode de paiement est requis.')]
    private ?Paiement $paiement = null;

    #[ORM\Column(type: Types::DATETIME_MUTABLE)] // Added dateCreation
    private ?DateTimeInterface $dateCreation;

    public function __construct()
    {
        $this->dateCreation = new \DateTime(); // Set dateCreation
    }

    // Getters & Setters (Standard for all properties)
    public function getId(): ?int { return $this->id; }
    public function getUtilisateur(): ?Utilisateur { return $this->utilisateur; }
    public function setUtilisateur(?Utilisateur $utilisateur): static { $this->utilisateur = $utilisateur; return $this; }
    public function getTrottinette(): ?Trottinette { return $this->trottinette; }
    public function setTrottinette(?Trottinette $trottinette): static { $this->trottinette = $trottinette; return $this; }
    public function getDateDebut(): ?DateTimeInterface { return $this->dateDebut; }
    public function setDateDebut(?DateTimeInterface $dateDebut): static { $this->dateDebut = $dateDebut; return $this; }
    public function getDateFin(): ?DateTimeInterface { return $this->dateFin; }
    public function setDateFin(?DateTimeInterface $dateFin): static { $this->dateFin = $dateFin; return $this; }
    public function getMontant(): ?string { return $this->montant; }
    public function setMontant(?string $montant): static { $this->montant = $montant; return $this; }
    public function getStatus(): ?ReservationStatus { return $this->status; }
    public function setStatus(?ReservationStatus $status): self { $this->status = $status; return $this; }
    public function getPaiement(): ?Paiement { return $this->paiement; }
    public function setPaiement(?Paiement $paiement): self { $this->paiement = $paiement; return $this; }
    public function getDateCreation(): ?DateTimeInterface { return $this->dateCreation; }
    public function setDateCreation(DateTimeInterface $dateCreation): static { $this->dateCreation = $dateCreation; return $this; }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/ResetPasswordRequest.php -----
<?php
namespace App\Entity;

use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
class ResetPasswordRequest
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Trottinette.php -----
<?php

namespace App\Entity;

use App\Repository\TrottinetteRepository;
use Doctrine\ORM\Mapping as ORM;
use DateTime;
use App\Enum\TrottinetteStatus;
use Symfony\Component\Validator\Constraints as Assert;
use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;

#[ORM\Entity(repositoryClass: TrottinetteRepository::class)]
#[ORM\Table(name: 'trottinette')]
#[UniqueEntity(fields: ['numeroSerie'], message: 'Ce numéro de série est déjà utilisé par une autre trottinette.')]
class Trottinette
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\ManyToOne(targetEntity: Utilisateur::class)]
    #[ORM\JoinColumn(name: 'idUser', referencedColumnName: 'id')]
    #[Assert\Valid]
    private ?Utilisateur $utilisateur = null;

    #[ORM\Column(name: 'modele', length: 100, nullable: true)]
    #[Assert\NotBlank(message: 'Le modèle est obligatoire')]
    #[Assert\Length(
        min: 2,
        max: 100,
        minMessage: 'Le modèle doit contenir au moins {{ limit }} caractères',
        maxMessage: 'Le modèle ne peut pas dépasser {{ limit }} caractères.'
    )]
    #[Assert\Regex(
        pattern: '/^[A-Za-z0-9\s\-\.]+$/',
        message: 'Le modèle ne peut contenir que des lettres, des chiffres, des espaces, des points et des tirets.'
    )]
    private ?string $modele = null;

    #[ORM\Column(name: 'numeroSerie', length: 100, nullable: true)]
    #[Assert\NotBlank(message: 'Le numéro de série est obligatoire')]
    #[Assert\Length(
        min: 4,
        max: 100,
        minMessage: 'Le numéro de série doit contenir au moins {{ limit }} caractères',
        maxMessage: 'Le numéro de série ne peut pas dépasser {{ limit }} caractères.'
    )]
    #[Assert\Regex(
        pattern: '/^[A-Za-z0-9\-]+$/',
        message: 'Le numéro de série ne peut contenir que des lettres, des chiffres et des tirets'
    )]
    private ?string $numeroSerie = null;

    #[ORM\Column(name: 'etat', type: 'string', enumType: TrottinetteStatus::class)]
    #[Assert\NotBlank(message: 'L\'état est obligatoire')]
    private TrottinetteStatus $etat = TrottinetteStatus::DISPONIBLE;

    #[ORM\Column(name: 'batterie', nullable: true)]
    #[Assert\NotBlank(message: 'batterie est obligatoire')]
    #[Assert\Type(
        type: 'integer',
        message: 'La valeur {{ value }} n\'est pas un nombre entier valide.'
    )]
    #[Assert\Range(
        min: 0,
        max: 100,
        notInRangeMessage: 'La batterie doit être comprise entre {{ min }}% et {{ max }}%'
    )]
    private ?int $batterie = null;

    #[ORM\Column(name: 'localisation', length: 100, nullable: true)]
    #[Assert\NotBlank(message: 'La localisation est obligatoire')]
    #[Assert\Length(
        max: 100,
        maxMessage: 'La localisation ne peut pas dépasser {{ limit }} caractères.'
    )]
    private ?string $localisation = null;

    #[ORM\Column(name: 'dateAjout', type: 'datetime', nullable: true)]
    #[Assert\Type("\DateTime", message: 'La valeur {{ value }} n\'est pas une date valide.')]
    #[Assert\LessThanOrEqual('now', message: 'La date d\'ajout ne peut pas être dans le futur.')]
    private ?DateTime $dateAjout = null;

    #[ORM\ManyToOne(targetEntity: PointRelais::class)]
    #[ORM\JoinColumn(name: 'pointRelaisId', referencedColumnName: 'id', nullable: true)]  // Define the foreign key
    private ?PointRelais $pointRelais = null;


    #[ORM\Column(name: 'autonomie', length: 45, nullable: true)]
    #[Assert\NotBlank(message: 'L\'autonomie est obligatoire')]
    #[Assert\Length(
        max: 45,
        maxMessage: 'L\'autonomie ne peut pas dépasser {{ limit }} caractères.'
    )]
    #[Assert\Regex(
        pattern: '/^\d+\s*(km|heures?)$/i',
        message: 'Le format d\'autonomie doit être comme "25 km" ou "2 heures"'
    )]
    private ?string $autonomie = null;

    #[Assert\Callback]
    public function validateBatteryAndAutonomy($context)
    {
        if ($this->batterie !== null && $this->batterie < 10 && $this->etat === TrottinetteStatus::DISPONIBLE) {
            $context->buildViolation('Une trottinette disponible doit avoir au moins 10% de batterie.')
                ->atPath('batterie')
                ->addViolation();
        }

        if ($this->etat === TrottinetteStatus::EN_MAINTENANCE && $this->batterie > 95) {
            $context->buildViolation('Une trottinette en maintenance ne devrait pas avoir une batterie presque pleine.')
                ->atPath('batterie')
                ->addViolation();
        }
    }

    // ======== GETTERS & SETTERS ========

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getUtilisateur(): ?Utilisateur
    {
        return $this->utilisateur;
    }

    public function setUtilisateur(?Utilisateur $utilisateur): self
    {
        $this->utilisateur = $utilisateur;
        return $this;
    }

    public function getModele(): ?string
    {
        return $this->modele;
    }

    public function setModele(?string $modele): self
    {
        $this->modele = $modele;
        return $this;
    }

    public function getNumeroSerie(): ?string
    {
        return $this->numeroSerie;
    }

    public function setNumeroSerie(?string $numeroSerie): self
    {
        $this->numeroSerie = $numeroSerie;
        return $this;
    }

    public function getEtat(): TrottinetteStatus
    {
        return $this->etat;
    }

    public function setEtat($etat): self
    {
        if (is_string($etat)) {
            $this->etat = TrottinetteStatus::from($etat);
        } else {
            $this->etat = $etat;
        }
        return $this;
    }

    public function getBatterie(): ?int
    {
        return $this->batterie;
    }

    public function setBatterie(?int $batterie): self
    {
        $this->batterie = $batterie;
        return $this;
    }

    public function getLocalisation(): ?string
    {
        return $this->localisation;
    }

    public function setLocalisation(?string $localisation): self
    {
        $this->localisation = $localisation;
        return $this;
    }

    public function getDateAjout(): ?DateTime
    {
        return $this->dateAjout;
    }

    public function setDateAjout(?DateTime $dateAjout): self
    {
        $this->dateAjout = $dateAjout;
        return $this;
    }

    public function getPointRelais(): ?PointRelais
    {
        return $this->pointRelais;
    }

    public function setPointRelais(?PointRelais $pointRelais): self
    {
        $this->pointRelais = $pointRelais;
        return $this;
    }


    public function getAutonomie(): ?string
    {
        return $this->autonomie;
    }

    public function setAutonomie(?string $autonomie): self
    {
        $this->autonomie = $autonomie;
        return $this;
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Entity/Reclamation.php -----
<?php

namespace App\Entity;

use App\Repository\ReclamationRepository;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Validator\Constraints as Assert;

#[ORM\Entity(repositoryClass: ReclamationRepository::class)]
#[ORM\Table(name: 'reclamation')]
class Reclamation
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\Column(length: 255)]
    #[Assert\NotBlank(message: 'Le titre ne peut pas être vide.')]
    #[Assert\Length(
        min: 5,
        max: 255,
        minMessage: 'Le titre doit comporter au moins {{ limit }} caractères.',
        maxMessage: 'Le titre ne peut pas dépasser {{ limit }} caractères.'
    )]
    private ?string $titre = null;

    #[ORM\Column(type: 'text')]
    #[Assert\NotBlank(message: 'La description ne peut pas être vide.')]
    #[Assert\Length(
        min: 10,
        minMessage: 'La description doit comporter au moins {{ limit }} caractères.'
    )]
    private ?string $description = null;

    #[ORM\Column(name: 'date_creation', type: 'datetime')]
    #[Assert\NotNull(message: 'La date de création est requise.')]
    #[Assert\LessThanOrEqual('now', message: 'La date de création ne peut pas être dans le futur.')]
    private ?\DateTimeInterface $dateCreation;

    #[ORM\Column(name: 'type_reclamation', length: 255)]
    #[Assert\NotBlank(message: 'Le type de réclamation ne peut pas être vide.')]
    #[Assert\Choice(
        choices: ['TECHNIQUE', 'SERVICE', 'FACTURATION', 'AUTRE'],
        message: 'Le type choisi n\'est pas valide. Types autorisés: TECHNIQUE, SERVICE, FACTURATION, AUTRE.'
    )]
    private ?string $typeReclamation = null;

    #[ORM\Column(name: 'user_email', length: 255)]
    #[Assert\NotBlank(message: 'L\'email de l\'utilisateur ne peut pas être vide.')]
    #[Assert\Email(
        message: 'L\'adresse email {{ value }} n\'est pas valide.'
    )]
    #[Assert\Length(
        max: 255,
        maxMessage: 'L\'email ne peut pas dépasser {{ limit }} caractères.'
    )]
    private ?string $userEmail = null;

    public function __construct()
    {
        $this->dateCreation = new \DateTime();
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getTitre(): ?string
    {
        return $this->titre;
    }

    public function setTitre(string $titre): self
    {
        $this->titre = $titre;
        return $this;
    }

    public function getDescription(): ?string
    {
        return $this->description;
    }

    public function setDescription(string $description): self
    {
        $this->description = $description;
        return $this;
    }

    public function getDateCreation(): ?\DateTimeInterface
    {
        return $this->dateCreation;
    }

    public function setDateCreation(\DateTimeInterface $dateCreation): self
    {
        $this->dateCreation = $dateCreation;
        return $this;
    }

    public function getTypeReclamation(): ?string
    {
        return $this->typeReclamation;
    }

    public function setTypeReclamation(string $typeReclamation): self
    {
        $this->typeReclamation = $typeReclamation;
        return $this;
    }

    public function getUserEmail(): ?string
    {
        return $this->userEmail;
    }

    public function setUserEmail(string $userEmail): self
    {
        $this->userEmail = $userEmail;
        return $this;
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Enum/ParticipationStatus.php -----
<?php

namespace App\Enum;

enum ParticipationStatus: string
{
    case INSCRIT = 'INSCRIT';
    case ANNULE = 'ANNULE';
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Enum/GouvernoratEnum.php -----
<?php

namespace App\Enum;

enum GouvernoratEnum: string
{
    case ARIANA = 'Ariana';
    case BEJA = 'Béja';
    case BEN_AROUS = 'Ben Arous';
    case BIZERTE = 'Bizerte';
    case GABES = 'Gabès';
    case GAFSA = 'Gafsa';
    case JENDOUBA = 'Jendouba';
    case KAIROUAN = 'Kairouan';
    case KASSERINE = 'Kasserine';
    case KEBILI = 'Kébili';
    case KEF = 'Le Kef';
    case MAHDIA = 'Mahdia';
    case MANOUBA = 'La Manouba';
    case MEDENINE = 'Médenine';
    case MONASTIR = 'Monastir';
    case NABEUL = 'Nabeul';
    case SFAX = 'Sfax';
    case SIDI_BOUZID = 'Sidi Bouzid';
    case SILIANA = 'Siliana';
    case SOUSSE = 'Sousse';
    case TATAOUINE = 'Tataouine';
    case TOZEUR = 'Tozeur';
    case TUNIS = 'Tunis';
    case ZAGHOUAN = 'Zaghouan';
    
    /**
     * Returns all available choices as an array
     * @return array<string, string>
     */
    public static function getChoicesForForm(): array
    {
        $choices = [];
        foreach (self::cases() as $case) {
            $choices[$case->value] = $case->name;
        }
        return $choices;
    }


    
    /**
     * Returns the string representation of this enum (its value)
     * @return string
     */
    public function toString(): string
    {

        return $this->value;
    }

    /**
     * Retourne une étiquette lisible (label) pour chaque case.
     */
    public function label(): string
    {

        return match ($this) {
            self::ARIANA => 'Ariana',
            self::BEJA => 'Béja',
            self::BEN_AROUS => 'Ben Arous',
            self::BIZERTE => 'Bizerte',
            self::GABES => 'Gabès',
            self::GAFSA => 'Gafsa',
            self::JENDOUBA => 'Jendouba',
            self::KAIROUAN => 'Kairouan',
            self::KASSERINE => 'Kasserine',
            self::KEBILI => 'Kébili',
            self::KEF => 'Le Kef',
            self::MAHDIA => 'Mahdia',
            self::MANOUBA => 'La Manouba',
            self::MEDENINE => 'Médenine',
            self::MONASTIR => 'Monastir',
            self::NABEUL => 'Nabeul',
            self::SFAX => 'Sfax',
            self::SIDI_BOUZID => 'Sidi Bouzid',
            self::SILIANA => 'Siliana',
            self::SOUSSE => 'Sousse',
            self::TATAOUINE => 'Tataouine',
            self::TOZEUR => 'Tozeur',
            self::TUNIS => 'Tunis',
            self::ZAGHOUAN => 'Zaghouan',
        };
    }



}


----- /Users/mac/Downloads/my_project_troti-vf/src/Enum/ReservationStatus.php -----
<?php

namespace App\Enum;

enum ReservationStatus: string
{
    case PENDING = 'pending';
    case CONFIRMED = 'confirmed';
    case CANCELLED = 'cancelled';

    public function label(): string
    {
        return match($this) {
            self::PENDING => 'Pending',
            self::CONFIRMED => 'Confirmed',
            self::CANCELLED => 'Cancelled',
        };
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Enum/TrottinetteStatus.php -----
<?php

namespace App\Enum;

enum TrottinetteStatus: string
{
    case DISPONIBLE = 'DISPONIBLE';
    case EN_LOCATION = 'EN_LOCATION';
    case EN_MAINTENANCE = 'EN_MAINTENANCE';

    public function toString(): string
    {
        return match($this) {
            self::DISPONIBLE => 'Disponible',
            self::EN_LOCATION => 'En Location',
            self::EN_MAINTENANCE => 'En Maintenance'
        };
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Enum/Paiement.php -----
<?php
namespace App\Enum;

enum Paiement: string
{
    case CARTE = 'carte';
    case CHEQUE = 'cheque';
    case ESPECE = 'espece';

    public function label(): string
    {
        return match($this) {
            self::CARTE => 'Carte bancaire',
            self::CHEQUE => 'Chèque',
            self::ESPECE => 'Espèce',
        };
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Enum/MaintenanceStatus.php -----
<?php

namespace App\Enum;

enum MaintenanceStatus: string
{
    case EN_COURS = 'EN_COURS';
    case TERMINE = 'TERMINE';
    case ANNULEE = 'ANNULEE';


}


----- /Users/mac/Downloads/my_project_troti-vf/src/Enum/MaintenanceType.php -----
<?php

namespace App\Enum;

enum MaintenanceType: string
{
    const REPARATION = 'REPARATION';
    const ENTRETIEN = 'ENTRETIEN';
    const VERIFICATION = 'VERIFICATION';
    const AUTRE = 'AUTRE';


}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/HomeController.php -----
<?php
// src/Controller/HomeController.php

namespace App\Controller;

use App\Repository\EventRepository;
use App\Repository\TrottinetteRepository;
use Psr\Log\LoggerInterface; // Import Logger
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route; // Use Attribute instead if using PHP 8+

// Using #[Route] attribute for the route definition
class HomeController extends AbstractController
{
    private LoggerInterface $logger;

    // Inject repositories and logger via constructor
    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    #[Route('/', name: 'app_home', methods: ['GET'])] // Define the route here
    public function index(
        TrottinetteRepository $trottinetteRepository,
        EventRepository $eventRepository
    ): Response {
        $this->logger->info('HomeController::index processing started.');

        $scootersForView = [];
        $eventsForView = [];

        try {

            // Fetch available scooters (e.g., limit to 4 for homepage)
            $availableScooters = $trottinetteRepository->findBy([], ['dateAjout' => 'DESC'], 4);

            $this->logger->info(sprintf('Fetched %d available scooters.', count($availableScooters)));

            // Fetch upcoming events (e.g., limit to 3 for homepage)
            if (method_exists($eventRepository, 'findUpcomingEvents')) {
                $upcomingEvents = $eventRepository->findUpcomingEvents();

            } else {
                $this->logger->warning('Method findUpcomingEvents not found in EventRepository.');
                $upcomingEvents = $eventRepository->findBy([], ['dateDebut' => 'ASC'], 3);
            }
            $this->logger->info(sprintf('Fetched %d upcoming events.', count($upcomingEvents)));

            // --- Prepare Scooter Card Data ---
            foreach ($availableScooters as $scooter) {
                $scootersForView[] = [
                    'entity' => $scooter,
                    'distanceString' => "Adresse: " . ($scooter->getLocalisation() ?: 'Inconnue'), // Placeholder
                    'pricePerMinute' => "0.15 TND/min", // Placeholder
                    'image_url' => null // Add logic if needed
                ];
            }

            // --- Prepare Event Card Data ---
            foreach ($upcomingEvents as $event) {
                $eventsForView[] = [
                    'entity' => $event,
                    // Use state (Gouvernorat) for location if available
                    'location' => $event->getState()?->label() ?? 'Lieu à définir'
                ];
            }

        } catch (\Exception $e) {
            $this->logger->error('Error preparing homepage data: ' . $e->getMessage(), ['exception' => $e]);
            $this->addFlash('error', 'Une erreur est survenue lors du chargement des données.');
            // Keep arrays empty on error
            $scootersForView = [];
            $eventsForView = [];
        }

        // --- Prepare Context for Rendering ---
        $context = [
            'scooters' => $scootersForView,         // Pass the prepared array for scooters
            'upcoming_events' => $eventsForView,    // Pass the prepared array for events
            'heroTitle' => 'Découvrez la ville autrement',
            'heroSubtitle' => 'Louez nos trottinettes électriques facilement. Disponibles 24/7, écologiques et fun !',
        ];

        $this->logger->debug('Rendering home/index.html.twig with keys: ' . implode(', ', array_keys($context)));

        // Render the specific template 'home/index.html.twig'
        return $this->render('home/index.html.twig', $context);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/SecurityController.php -----
<?php
// src/Controller/SecurityController.php

namespace App\Controller;

use App\Entity\Utilisateur;
use App\Repository\UtilisateurRepository; // Use the specific Repository
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\RedirectResponse; // For redirects
use Symfony\Component\HttpFoundation\Session\SessionInterface;
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface; // Needed for manual token setting
use Symfony\Component\Security\Core\Authentication\Token\UsernamePasswordToken; // Needed for manual token creation
use Symfony\Component\Security\Csrf\CsrfToken; // Needed for CSRF check
use Symfony\Component\Security\Csrf\CsrfTokenManagerInterface; // Needed for CSRF check
use Symfony\Component\Security\Http\SecurityRequestAttributes; // For LAST_USERNAME constant

class SecurityController extends AbstractController
{
    // =========================================================================
    // == MANUAL AUTHENTICATION IMPLEMENTATION (REVISED & CORRECTED)        ==
    // =========================================================================
    // == WARNING: This implements login/logout manually. While corrected to ==
    // == integrate with Symfony's session context for authorization        ==
    // == (#[IsGranted], access_control), it bypasses standard authenticators.==
    // == Ensure thorough testing and understanding.                          ==
    // =========================================================================

    #[Route('/connexion', name: 'app_login', methods: ['GET', 'POST'])]
    public function login(
        Request $request,
        UtilisateurRepository $userRepository, // Use specific repository
        UserPasswordHasherInterface $passwordHasher,
        CsrfTokenManagerInterface $csrfTokenManager,
        TokenStorageInterface $tokenStorage,
        SessionInterface $session
    ): Response {
        // --- Redirect if already logged in ---
        // Check if a security token exists AND represents an authenticated user
        if ($session->has('_security_main') && $tokenStorage->getToken()?->getUser() instanceof Utilisateur) {
            $roles = $tokenStorage->getToken()->getRoleNames(); // Get roles from the active token
            if (in_array('ROLE_ADMIN', $roles, true)) {
                return $this->redirectToRoute('admin_dashboard'); // Use your actual route names
            }
            if (in_array('ROLE_PARTENAIRE', $roles, true)) {
                return $this->redirectToRoute('app_partenaire_dashboard'); // Use your actual route names
            }
            if (in_array('ROLE_CLIENT', $roles, true)) {
                return $this->redirectToRoute('client_dashboard'); // Use your actual route names
            }
            // Fallback if roles don't match expected dashboards
            return $this->redirectToRoute('app_home');
        }

        $error = null;
        // Get last username entered (if any) for pre-filling the form
        $lastUsername = $request->getSession()->get(SecurityRequestAttributes::LAST_USERNAME);

        if ($request->isMethod('POST')) {
            $email = $request->request->get('email'); // Use '_username' as standard convention
            $password = $request->request->get('password'); // Use '_password' as standard convention
            $csrfToken = $request->request->get('_csrf_token');

            // Store the submitted email in the session for pre-filling if login fails
            $request->getSession()->set(SecurityRequestAttributes::LAST_USERNAME, $email);

            // 1. CSRF Validation (CRITICAL for security)
            $token = new CsrfToken('authenticate', $csrfToken);


            // 2. Find User by Email
            $user = $userRepository->findOneBy(['email' => $email]);
// **New**: Block if not active
            if ($user && !$user->isActive()) {
                $this->addFlash('error', 'Votre compte a été désactivé. Contactez un administrateur.');
                return $this->render('security/login.html.twig', [
                    'last_username' => $email,
                    'error'         => 'Votre compte est désactivé.',
                ]);
            }

            // 3. Validate User and Password
            if (!$user || !$passwordHasher->isPasswordValid($user, $password)) {
                $this->addFlash('error', 'Identifiants invalides.');
                // Render the login form again
                return $this->render('security/login.html.twig', [
                    'last_username' => $email,
                    'error' => 'Identifiants invalides.',
                ]);
            }

            // --- If validation passes: MANUAL SESSION START & TOKEN CREATION ---

            // 4. Create the Security Token
            // 'main' MUST match the firewall name in security.yaml
            $securityToken = new UsernamePasswordToken($user, 'main', $user->getRoles());

            // 5. Manually set the token in the Token Storage for the current request
            $tokenStorage->setToken($securityToken);

            // 6. Manually store the token in the session for subsequent requests.
            // This is the key part for making #[IsGranted], access_control, etc., work.
            // Symfony's ContextListener should pick this up. Use the conventional key.
            $session->set('_security_main', serialize($securityToken));

            // 7. Regenerate session ID to prevent session fixation attacks
            $session->migrate(true);

            // 8. Clear the last username from session after successful login
            $request->getSession()->remove(SecurityRequestAttributes::LAST_USERNAME);

            $this->addFlash('success', 'Connexion réussie ! Bienvenue ' . $user->getPrenom() . '.');

            // 9. Redirect based on role
            $roles = $user->getRoles(); // Use roles from the user entity
            if (in_array('ROLE_ADMIN', $roles, true)) {
                return $this->redirectToRoute('admin_dashboard'); // Use your actual route names
            } elseif (in_array('ROLE_PARTENAIRE', $roles, true)) {
                return $this->redirectToRoute('app_partenaire_dashboard'); // Use your actual route names
            } else { // Default for ROLE_CLIENT or ROLE_USER
                return $this->redirectToRoute('client_dashboard'); // Use your actual route names
            }
        }

        // --- Render the login form on GET request or if POST validation failed before step 4 ---
        // Check for authentication errors stored by previous attempts (e.g., if using firewall exceptions)
        // Note: With this fully manual approach, direct errors are less common here unless
        // you explicitly throw Symfony security exceptions. Flash messages are primary.
        // $authError = $request->getSession()->get(SecurityRequestAttributes::AUTHENTICATION_ERROR);
        // if ($authError) {
        //     $error = $authError->getMessageKey(); // Or getMessage()
        //     $request->getSession()->remove(SecurityRequestAttributes::AUTHENTICATION_ERROR); // Clear error
        //     $this->addFlash('error', $error); // Add as flash message
        // }


        return $this->render('security/login.html.twig', [
            'last_username' => $lastUsername,
            'error' => $error, // Pass any direct error message (though flash is preferred)
        ]);
    }

    #[Route('/deconnexion', name: 'app_logout', methods: ['GET'])]
    public function logout(
        Request $request, // Request might be needed if clearing cookies etc.
        TokenStorageInterface $tokenStorage,
        SessionInterface $session
    ): Response {
        // MANUAL LOGOUT IMPLEMENTATION

        // 1. Clear the security token from token storage for the current request
        $tokenStorage->setToken(null);

        // 2. Remove the security token from the session storage
        $session->remove('_security_main');

        // 3. Invalidate the entire session and regenerate CSRF token
        // This clears all session data and generates a new session ID.
        $session->invalidate();

        $this->addFlash('success', 'Vous avez été déconnecté.');

        // Redirect to homepage or login page
        return $this->redirectToRoute('app_home');

        // NOTE: Symfony's security.yaml 'logout' path configuration is NOT used here.
        // The route '/deconnexion' directly triggers this manual logout action.
        // Throwing an exception here is unnecessary and typically not done for logout.
        // throw new \LogicException('This method should not be reached!');
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/ParticipationController.php -----
<?php
// src/Controller/ParticipationController.php
namespace App\Controller;

use App\Entity\Participation;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Symfony\Component\Routing\Annotation\Route;

class ParticipationController extends AbstractController
{
    #[Route('/participation/{id}/details', name: 'participation_details', requirements: ['id' => '\d+'], methods: ['GET'])]
    public function showDetails(Participation $participation): Response
    {
        // ParamConverter automatically fetches the Participation by ID.
        // If not found, it throws a 404 exception.

        $event = $participation->getEvent();
        $user = $participation->getUtilisateur();

        if (!$event || !$user) {
            // This should ideally not happen if data integrity is maintained
            throw new NotFoundHttpException('Données associées à la participation introuvables.');
        }

        return $this->render('participation/details.html.twig', [
            'participation' => $participation,
            'event' => $event,
            'user' => $user,
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/TrottinetteController.php -----
<?php

namespace App\Controller;

use App\Entity\Trottinette;
use App\Entity\Utilisateur;
use App\Form\TrottinetteType;
use App\Repository\TrottinetteRepository;
use App\Repository\UtilisateurRepository;
use App\Service\DataFixturesService;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Form\FormError;

#[Route('/trottinette')]
class TrottinetteController extends AbstractController
{
   
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/EventController.php -----
<?php

namespace App\Controller;

use App\Entity\Event;
use App\Entity\Participation;
use App\Entity\Utilisateur;
use App\Enum\ParticipationStatus;
use App\Form\EventType;
use App\Repository\EventRepository;
use App\Repository\ParticipationRepository; // Make sure this is injected
use App\Repository\UtilisateurRepository;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Mailer\Exception\TransportExceptionInterface;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\HttpFoundation\RedirectResponse; // Added for redirects
use Symfony\Component\Mailer\MailerInterface;        // ← import this
use Symfony\Component\Mime\Email;                    // ← and this
use Symfony\Contracts\HttpClient\HttpClientInterface;

#[Route('/event')]
class EventController extends AbstractController
{
    // Inject ParticipationRepository in the constructor if it's used in multiple methods often
    private ParticipationRepository $participationRepository;
    private EntityManagerInterface $entityManager;
    private HttpClientInterface $client;

    public function __construct(ParticipationRepository $participationRepository, EntityManagerInterface $entityManager,HttpClientInterface $client)
    {
        $this->participationRepository = $participationRepository;
        $this->entityManager = $entityManager;
        $this->client = $client;

    }

    #[Route('/', name: 'app_event_index', methods: ['GET'])]
    public function index(EventRepository $eventRepository): Response
    {
        // Consider showing upcoming events by default for a better user experience
        return $this->render('event/index.html.twig', [
            'events' => $eventRepository->findUpcomingEvents(), // Or findAll() if intended
        ]);
    }

    #[Route('/new', name: 'app_event_new', methods: ['GET', 'POST'])]
    public function new(Request $request): Response // EntityManager injected via constructor
    {
        $event = new Event();
        // $event->setStatut('active'); // This 'active' status seems incorrect based on the entity enum/choices ('A_VENIR', etc.)
        $event->setStatut('A_VENIR'); // Set a valid default status

        $form = $this->createForm(EventType::class, $event);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->persist($event);
            $this->entityManager->flush();
            $this->addFlash('success', 'Événement créé avec succès.');
            return $this->redirectToRoute('app_event_index');
        }

        return $this->render('event/new.html.twig', [
            'event' => $event,
            'form' => $form->createView(), // Pass form view
        ]);
    }

    #[Route('/{id}/participate', name: 'app_event_participate', methods: ['POST'])]
    public function participate(Request $request, Event $event, UtilisateurRepository $utilisateurRepository,

                                MailerInterface $mailer        // ← inject it here

    ): Response // EntityManager injected via constructor
    {

        // WARNING: No security check! Relies on getUser() or fallback.
        $user = $this->getUser();
        if (!$user) {
            // Using the fallback test user logic from your original code
            $user = $utilisateurRepository->findOneBy(['email' => 'test@example.com']);
            if (!$user) {
                // Create a default test user for participation testing
                $user = new Utilisateur();
                $user->setEmail('test@example.com');
                $user->setNom('Test');
                $user->setPrenom('User');
                // Note: Password hashing should ideally use the PasswordHasher service
                $user->setPassword(password_hash('test1234', PASSWORD_DEFAULT)); // Use default hash
                $user->setRoleInterne('client'); // Use setRoleInterne
                $user->setTelephone('0123456789'); // Required field in database
                $user->setIsVerified(true); // Assume verified for test
                $this->entityManager->persist($user);
                $this->entityManager->flush();
            }
        }
         $email = (new Email())
            ->from('aymen.labidi@esprit.tn')
            ->to('aymenlabidi21@gmail.com')
            ->subject('Hello via SMTP!')
            ->text('This email was sent over SMTP using Symfony Mailer.')
            ->html('<p>This email was sent over <strong>SMTP</strong> using Symfony Mailer.</p>');
        $dateDebut = $event->getDateDebut()->format('d/m/Y \à H\hi'); // e.g. "27/04/2025 à 14h30"
        $dateFin   = $event->getDateFin()  ->format('d/m/Y \à H\hi'); // e.g. "27/04/2025 à 16h00"

        $url = 'https://hook.eu1.make.com/36nvslbc06ues77g2f69w5nloy1ra98j';

                            $body = <<<EOT
                    Bonjour,</br>
                    
                    Félicitations ! Vous êtes inscrit(e) à l'événement "{$event->getTitre()}". ✅</br>
                    
                    📅 Date : {$dateDebut} - {$dateFin}</br>
                    📍 Lieu : {$event->getLieuValue()} ({$event->getState()->label()})</br>
                    ⚡ Autonomie minimale requise pour les trottinettes : {$event->getTrottinetteMinAutonomie()} km</br>
                    
                    🎫 Présentez ce mail comme preuve de votre inscription.</br>
                    
                    À très bientôt ! 🚀
                    EOT;
        $payload = [
            'email' => $user->getEmail(),
            'body'  => $body,
            'title' => "Confirmation de participation à 'événement",
        ];
        $headers = [
            'Content-Type' => 'application/json',
            'Cookie'       => '__cf_bm=hfXrt7n0TJKswki1VkcZXgyCGyrUOG7LcPSmsuwLAUQ-1745745305-1.0.1.1-N9CHYn3bbnDqxifvbWFL9WPEDH1DMGIol16jHCmyIGxdm1RMOXrxAOUN4k6iNJtOlX35E0QzCR8t.BZudJltHyTg0nWihxkmMK5TL2.ia28',
        ];

        $response = $this->client->request('POST', $url, [
            'headers' => $headers,
            'json'    => $payload,
        ]);

        // get status and body if you want
        $status  = $response->getStatusCode();
        $content = $response->getContent(false);


        try {

            $mailer->send($email);
            $this->addFlash('success', 'Email envoyé !');



        } catch (TransportExceptionInterface $e) {
            // SMTP refused it, DNS failure, auth error, etc.
            $this->addFlash('error', 'L’email n’a pas pu être envoyé : '.$e->getMessage());

            // In dev, you might re-throw to see the full trace
            if ($this->getParameter('kernel.debug')) {
                throw $e;
            }
        }


        // Check if user already actively registered
        $activeParticipation = $this->participationRepository->findOneBy([
            'event' => $event,
            'utilisateur' => $user,
            'statut' => ParticipationStatus::INSCRIT
        ]);

        if ($activeParticipation) {
            $this->addFlash('warning', 'Vous êtes déjà inscrit à cet événement.');
            return $this->redirectToRoute('app_event_show', ['id' => $event->getId()]);
        }

        // Check if user has a cancelled registration for this event
        $cancelledParticipation = $this->participationRepository->findOneBy([
            'event' => $event,
            'utilisateur' => $user,
            'statut' => ParticipationStatus::ANNULE
        ]);

        if ($cancelledParticipation) {
            // Reactivate the cancelled participation
            $cancelledParticipation->setStatut(ParticipationStatus::INSCRIT);
            $cancelledParticipation->setDateInscription(new \DateTime()); // Update inscription date
            $this->entityManager->persist($cancelledParticipation);
            $this->addFlash('success', 'Votre inscription a été réactivée !');
        } else {
            // Create a new participation if none exists (active or cancelled)
            $participation = new Participation();
            // WARNING: Using potentially non-unique ID. Database composite key (eventId, userId) is preferred.
            $participation->setEvent($event);
            $participation->setUtilisateur($user);
            $participation->setDateInscription(new \DateTime());
            $participation->setStatut(ParticipationStatus::INSCRIT);
            $this->entityManager->persist($participation);
            $this->addFlash('success', 'Vous êtes maintenant inscrit à cet événement !');
        }

        $this->entityManager->flush();

        return $this->redirectToRoute('app_event_show', ['id' => $event->getId()]);
    }

    // --- Added Action to Cancel Participation ---
    #[Route('/{id}/cancel-participation', name: 'app_event_cancel_participation', methods: ['POST'])]
    public function cancelParticipation(Request $request, Event $event, UtilisateurRepository $utilisateurRepository): Response // EntityManager injected via constructor
    {
        // WARNING: No security check!
        $user = $this->getUser();
        if (!$user) {
            // Using the fallback test user logic from your original code (less ideal for cancel)
            $user = $utilisateurRepository->findOneBy(['email' => 'test@example.com']);
            if (!$user) {
                $this->addFlash('warning', 'Utilisateur non trouvé pour annuler la participation.');
                return $this->redirectToRoute('app_event_show', ['id' => $event->getId()]);
            }
        }

        // Find the ACTIVE participation to cancel
        $participation = $this->participationRepository->findOneBy([
            'event' => $event,
            'utilisateur' => $user,
            'statut' => ParticipationStatus::INSCRIT // Only cancel if currently 'INSCRIT'
        ]);

        if (!$participation) {
            $this->addFlash('warning', 'Vous n\'êtes pas activement inscrit à cet événement.');
            return $this->redirectToRoute('app_event_show', ['id' => $event->getId()]);
        }

        // Change status to Cancelled
        $participation->setStatut(ParticipationStatus::ANNULE);
        $this->entityManager->persist($participation); // Persist the change
        $this->entityManager->flush();

        $this->addFlash('success', 'Votre participation à l\'événement a été annulée.');
        return $this->redirectToRoute('app_event_show', ['id' => $event->getId()]);
    }
    // --- End Added Action ---


    #[Route('/{id}', name: 'app_event_show', methods: ['GET'])]
    public function show(Event $event): Response // ParticipationRepository injected via constructor
    {
        $user = $this->getUser();
        $user_participation = null;
        if ($user instanceof Utilisateur) {
            // Find specific participation (active or cancelled) for this user/event
            $user_participation = $this->participationRepository->findOneBy(['event' => $event, 'utilisateur' => $user]);
        }

        return $this->render('event/show.html.twig', [
            'event' => $event,
            // Pass the specific participation object (or null) to the template
            'user_participation' => $user_participation
        ]);
    }

    #[Route('/{id}/edit', name: 'app_event_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Event $event): Response // EntityManager injected via constructor
    {
        $form = $this->createForm(EventType::class, $event);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->flush();
            $this->addFlash('success', 'Événement mis à jour.');
            // Redirect back to the show page or index
            return $this->redirectToRoute('app_event_show', ['id' => $event->getId()]);
        }

        return $this->render('event/edit.html.twig', [
            'event' => $event,
            'form' => $form->createView(), // Pass form view
        ]);
    }

    #[Route('/{id}', name: 'app_event_delete', methods: ['POST'])]
    public function delete(Request $request, Event $event): Response // EntityManager injected via constructor
    {
        // WARNING: Original code has Csrf check but redirects to admin dashboard.
        // Keeping the CSRF check as it's good practice, even if other security is removed.
        // Redirecting to event index instead of admin dashboard.
        // Also, need to handle deletion of related participations.
        if (true) {

            // Manually remove participations before removing event (if cascade={"remove"} isn't set or doesn't work)
            $participations = $this->participationRepository->findBy(['event' => $event]);
            foreach ($participations as $participation) {
                $this->entityManager->remove($participation);
            }
            // Flush removals if necessary, though often can be done in one flush
            // $this->entityManager->flush();

            $this->entityManager->remove($event);
            $this->entityManager->flush();
            $this->addFlash('success', 'Événement supprimé.');
        } else {
            $this->addFlash('danger', 'Action invalide (CSRF token mismatch).');
            return $this->redirectToRoute('app_event_show', ['id' => $event->getId()]); // Redirect back if token fails
        }

        return $this->redirectToRoute('app_admin_events'); // Redirect to event list
    }

    #[Route('/{id}/participants', name: 'app_event_participants', methods: ['GET'])]
    public function participants(Event $event): Response // ParticipationRepository injected via constructor
    {
        // This action remains the same, just lists participants.
        $participants = $this->participationRepository->findByEvent($event);

        // Render the view for showing participants (assuming this view exists and is correct)
        return $this->render('event/participants.html.twig', [
            'event' => $event,
            'participants' => $participants,
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/LoginController.php -----
<?php
// src/Controller/LoginController.php
namespace App\Controller;

use App\Entity\Utilisateur;
use App\Repository\UtilisateurRepository;
use App\Service\FacialRecognitionService;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Session\SessionInterface; // Needed for manual login
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface; // Needed? Maybe not here.
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface; // Needed for manual login
use Symfony\Component\Security\Core\Authentication\Token\UsernamePasswordToken; // Needed for manual login
use Symfony\Component\Security\Core\Exception\CustomUserMessageAccountStatusException; // For errors
use Symfony\Component\Security\Http\Authentication\AuthenticationUtils;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface; // For redirects

class LoginController extends AbstractController
{
    private UrlGeneratorInterface $urlGenerator;

    public function __construct(UrlGeneratorInterface $urlGenerator)
    {
        $this->urlGenerator = $urlGenerator;
    }

    /**
     * Displays the login page.
     */
    #[Route('/connexion-page', name: 'app_login_page', methods: ['GET'])]
    public function loginPage(AuthenticationUtils $authenticationUtils): Response
    {
        // Logic to redirect if already logged in
        if ($this->getUser()) {
            // Redirect logic... (as before)
            if ($this->isGranted('ROLE_ADMIN')) return $this->redirectToRoute('admin_dashboard');
            if ($this->isGranted('ROLE_PARTENAIRE')) return $this->redirectToRoute('app_partenaire_dashboard');
            return $this->redirectToRoute('client_dashboard');
        }

        $error = $authenticationUtils->getLastAuthenticationError();
        $lastUsername = $authenticationUtils->getLastUsername();

        return $this->render('security/login.html.twig', [
            'last_username' => $lastUsername,
            'error' => $error,
        ]);
    }

    /**
     * Route for password form submission (handled by PasswordOnlyAuthenticator)
     */
    #[Route('/login/authenticate-password', name: 'app_login_authenticate_password', methods: ['POST'])]
    public function loginAuthenticatePassword(): void
    {
        // Handled by PasswordOnlyAuthenticator::authenticate()
        throw new \LogicException('This method should not be reached. Check security firewall.');
    }

    /**
     * AJAX: Checks email existence and available login methods.
     */
    #[Route('/login/check-email-caps', name: 'app_login_check_email_caps', methods: ['POST'])]
    public function checkEmailAndCapabilities(Request $request, UtilisateurRepository $userRepository): JsonResponse
    {
        $email = $request->request->get('email');
        if (empty($email)) {
            return new JsonResponse(['success' => false, 'message' => 'Email manquant.'], Response::HTTP_BAD_REQUEST);
        }

        /** @var Utilisateur|null $user */
        $user = $userRepository->findOneBy(['email' => $email]);

        if (!$user) {
            return new JsonResponse(['success' => false, 'message' => 'Aucun compte trouvé pour cet email.'], Response::HTTP_NOT_FOUND);
        }

        // Determine capabilities
        $canLoginWithPassword = !empty($user->getPassword()); // Check if password hash exists
        $canLoginWithFace = !empty($user->getFaceEmbedding());

        if (!$canLoginWithPassword && !$canLoginWithFace) {
            return new JsonResponse(['success' => false, 'message' => 'Aucune méthode de connexion configurée pour ce compte.'], Response::HTTP_FORBIDDEN);
        }

        // Optional: Add checks for isActive and isVerified here for better UX
        if (!$user->isActive()) {
            return new JsonResponse(['success' => false, 'message' => 'Ce compte est désactivé.'], Response::HTTP_FORBIDDEN);
        }
        if (!$user->isVerified()) {
            return new JsonResponse(['success' => false, 'message' => 'Ce compte n\'est pas vérifié. Consultez votre e-mail.'], Response::HTTP_FORBIDDEN);
        }

        return new JsonResponse([
            'success' => true,
            'canLoginWithPassword' => $canLoginWithPassword,
            'canLoginWithFace' => $canLoginWithFace,
            'message' => 'Choisissez votre méthode de connexion.'
        ]);
    }

    /**
     * AJAX: Handles facial login attempt and performs manual authentication.
     */
    #[Route('/login/authenticate-face', name: 'app_login_authenticate_face', methods: ['POST'])]
    public function authenticateFace(
        Request $request,
        UtilisateurRepository $userRepository,
        FacialRecognitionService $faceRecService,
        TokenStorageInterface $tokenStorage, // For manual login
        SessionInterface $session // For manual login
    ): JsonResponse {
        $email = $request->request->get('email');
        $faceData = $request->request->get('face_data'); // Expect comma-separated string

        if (empty($email) || empty($faceData)) {
            return new JsonResponse(['success' => false, 'message' => 'Données email ou faciales manquantes.'], Response::HTTP_BAD_REQUEST);
        }

        /** @var Utilisateur|null $user */
        $user = $userRepository->findOneBy(['email' => $email]);

        // Verify user exists and has face data configured
        if (!$user || empty($user->getFaceEmbedding())) {
            return new JsonResponse(['success' => false, 'message' => 'Utilisateur ou configuration faciale introuvable.'], Response::HTTP_NOT_FOUND);
        }

        // --- CRITICAL CHECKS before expensive face comparison ---
        if (!$user->isActive()) {
            return new JsonResponse(['success' => false, 'message' => 'Ce compte est désactivé.'], Response::HTTP_FORBIDDEN);
        }
        if (!$user->isVerified()) {
            return new JsonResponse(['success' => false, 'message' => 'Ce compte n\'est pas vérifié.'], Response::HTTP_FORBIDDEN);
        }
        // --- END CRITICAL CHECKS ---

        // Compare Faces using the Service
        $isMatch = $faceRecService->compareFaces($faceData, $user->getFaceEmbedding());

        if ($isMatch) {
            // Face matches! Manually Authenticate the User
            try {
                // 1. Create the Security Token ('main' = firewall name)
                $securityToken = new UsernamePasswordToken($user, 'main', $user->getRoles());

                // 2. Set token in Token Storage (for current request)
                $tokenStorage->setToken($securityToken);

                // 3. Set token in Session (for subsequent requests)
                // Use the standard key Symfony's ContextListener looks for
                $session->set('_security_main', serialize($securityToken));

                // 4. Regenerate session ID
                $session->migrate(true);

                // 5. Determine Redirect URL
                $redirectUrl = $session->get('_security.main.target_path'); // <--- CORRECT LINE (assuming firewall name is 'main')
                if (!$redirectUrl) {
                    $roles = $user->getRoles();
                    if (in_array('ROLE_ADMIN', $roles, true)) $redirectUrl = $this->urlGenerator->generate('admin_dashboard');
                    elseif (in_array('ROLE_PARTENAIRE', $roles, true)) $redirectUrl = $this->urlGenerator->generate('app_partenaire_dashboard');
                    else $redirectUrl = $this->urlGenerator->generate('client_dashboard');
                }

                // 6. Return success with redirect URL for JS
                return new JsonResponse([
                    'success' => true,
                    'message' => 'Authentification faciale réussie.',
                    'redirectUrl' => $redirectUrl
                ]);

            } catch (\Exception $e) {
                // Log internal errors during token creation/session setting
                error_log("Manual facial login error: " . $e->getMessage());
                return new JsonResponse(['success' => false, 'message' => 'Erreur interne lors de la connexion.'], Response::HTTP_INTERNAL_SERVER_ERROR);
            }
        } else {
            // Face does not match
            return new JsonResponse([
                'success' => false,
                'message' => 'Visage non reconnu. Réessayez.'
            ], Response::HTTP_UNAUTHORIZED); // 401 Unauthorized
        }
    }

    #[Route(path: '/logout', name: 'app_logout')]
    public function logout(): void
    {
        // Intercepted by the logout key in security.yaml
        throw new \LogicException('This method can be blank - intercepted by the logout key.');
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/TrottinetteController.php -----
<?php

// src/Controller/Admin/TrottinetteController.php
namespace App\Controller\Admin;

use App\Entity\Trottinette;
use App\Form\TrottinetteType;
use App\Repository\TrottinetteRepository;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Annotation\Route;
use Doctrine\ORM\EntityManagerInterface;
use App\Repository\UtilisateurRepository;
use App\Service\DataFixturesService;
use Symfony\Component\HttpFoundation\Response;
use App\Entity\PointRelais;
use Symfony\Contracts\HttpClient\HttpClientInterface;

#[Route('/admin/trottinettes')]
class TrottinetteController extends AbstractController
{
    private $entityManager;
    private DataFixturesService $dataFixturesService;
    private HttpClientInterface $client;

    public function __construct(EntityManagerInterface $entityManager, DataFixturesService $dataFixturesService,HttpClientInterface $client)
    {
        $this->entityManager = $entityManager;
        $this->dataFixturesService = $dataFixturesService;
        $this->client = $client;

    }

    #[Route('/', name: 'admin_trottinette_index')]
    public function index(Request $request, TrottinetteRepository $repository)
    {

            // Get the criteria from the request or default to an empty array
            $criteria = $request->query->get('criteria');  // Do not pass an array as default
            if (!$criteria) {
                $criteria = [];  // If no 'criteria' is found, default to an empty array
            }
            
            // Continue with the rest of the logic
            $page = $request->query->get('page', 1);
            $limit = $request->query->get('limit', 15);
            
            // Now pass the criteria properly
            $trottinettes = $repository->findByCriteria($criteria, $page, $limit);

        return $this->render('admin/trottinette/index.html.twig', [
            'trottinettes' => $trottinettes,
        ]);
    }

  
    #[Route('/new', name: 'admin_trottinette_new', methods: ['GET', 'POST'])]
    public function new(Request $request, UtilisateurRepository $utilisateurRepository): Response
    {
        $trottinette = new Trottinette();
        
        // Set default values for PointRelais and Utilisateur
        $defaultPointRelaisId = $this->dataFixturesService->getDefaultPointRelaisId();
        $pointRelais = $this->entityManager->getRepository(PointRelais::class)->find($defaultPointRelaisId);
        if ($pointRelais) {
            $trottinette->setPointRelais($pointRelais);
        }
    
        $defaultUserId = $this->dataFixturesService->getDefaultUserId();
        if ($defaultUserId) {
            $utilisateur = $utilisateurRepository->find($defaultUserId);
            if ($utilisateur) {
                $trottinette->setUtilisateur($utilisateur);
            }
        }
        
        // Create the form
        $form = $this->createForm(TrottinetteType::class, $trottinette);
        $form->handleRequest($request);
    
        if ($form->isSubmitted() && $form->isValid()) {
            $trottinette->setDateAjout(new \DateTime()); // Set the date of creation
            // Création du SMS
            $trottinetteInfo = 'Trottinette #' . $trottinette->getId() . ' (' . $trottinette->getModele() . ')';
            $smsMessage = "Nouvelle trottinette ajoutée: {$trottinetteInfo}.";

            // Envoi SMS via Webhook
            $this->client = \Symfony\Component\HttpClient\HttpClient::create();

            $payload = [
                'body' => $smsMessage,
            ];
            $headers = [
                'Content-Type' => 'application/json',
            ];

            $this->client->request('POST', "https://hook.eu1.make.com/ndgogmlq27hd1j6toex8eusathvnag8q", [
                'headers' => $headers,
                'json' => $payload,
            ]);

            try {
                $this->entityManager->persist($trottinette);
                $this->entityManager->flush();
                $this->addFlash('success', 'La trottinette a été ajoutée avec succès.');
                return $this->redirectToRoute('admin_trottinette_index');
            } catch (\Exception $e) {
                $this->addFlash('error', 'Erreur lors de l\'ajout de la trottinette: ' . $e->getMessage());
            }
        }
    
        return $this->render('admin/trottinette/new.html.twig', [
            'form' => $form->createView(),
        ]);
    }
    #[Route('/admin/trottinettes/{id}', name: 'admin_trottinette_show', methods: ['GET'])]          
    public function show(int $id, TrottinetteRepository $trottinetteRepository): Response
    {
        // Retrieve the trottinette by its ID
        $trottinette = $trottinetteRepository->find($id);

        // Check if the trottinette exists
        if (!$trottinette) {
            throw $this->createNotFoundException('Trottinette not found');
        }

        // Render the template and pass the trottinette entity
        return $this->render('admin/trottinette/show.html.twig', [
            'trottinette' => $trottinette,
        ]);
    }
    

    #[Route('/{id}/edit', name: 'admin_trottinette_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Trottinette $trottinette, EntityManagerInterface $entityManager, UtilisateurRepository $utilisateurRepository): Response
    {
        $form = $this->createForm(TrottinetteType::class, $trottinette);
        $form->handleRequest($request);

        if ($form->isSubmitted()) {
            if ($form->isValid()) {
                try {
                    $entityManager->flush();
                    $this->addFlash('success', 'La trottinette a été modifiée avec succès.');
                    return $this->redirectToRoute('admin_trottinette_index');
                } catch (\Exception $e) {
                    $this->addFlash('error', 'Erreur lors de la modification de la trottinette: ' . $e->getMessage());
                }
            }
        }    
        return $this->render('admin/trottinette/edit.html.twig', [
            'trottinette' => $trottinette,
            'form' => $form,
        ]);
    }

    #[Route('/{id}', name: 'admin_trottinette_delete', methods: ['POST'])]
    public function delete(Request $request, Trottinette $trottinette, EntityManagerInterface $entityManager): Response
    {
        if ($this->isCsrfTokenValid('delete'.$trottinette->getId(), $request->request->get('_token'))) {
            $entityManager->remove($trottinette);
            $entityManager->flush();
            $this->addFlash('success', 'La trottinette a été supprimée avec succès.');
        }

        return $this->redirectToRoute('admin_trottinette_index');
    }

    // CRUD actions...
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/EventController.php -----
<?php

namespace App\Controller\Admin;

use App\Entity\Event;
use App\Form\EventType; // Needed for New/Edit actions
use App\Repository\EventRepository;
use App\Repository\ParticipationRepository; // Needed for Participants action
use App\Enum\GouvernoratEnum; // Potentially needed for filters
use Doctrine\ORM\EntityManagerInterface;
use Psr\Log\LoggerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Http\Attribute\IsGranted;
use Symfony\Component\HttpFoundation\JsonResponse;
use Knp\Component\Pager\PaginatorInterface;

#[IsGranted('ROLE_ADMIN')] // Secure the entire controller for Admins
#[Route('/admin/events')] // Base route for admin event actions
class EventController extends AbstractController
{
    private LoggerInterface $logger;
    private EntityManagerInterface $entityManager;

    // Inject necessary services
    public function __construct(
        LoggerInterface $logger,
        EntityManagerInterface $entityManager
    ) {
        $this->logger = $logger;
        $this->entityManager = $entityManager;
    }

    /**
     * Lists all events with filtering, sorting, and pagination for Admins.
     */
// ---------------------------------------------------------------------
//  Lists events (search + filter + sort + pagination)
// ---------------------------------------------------------------------
    #[Route('/', name: 'app_admin_events', methods: ['GET'])]
    public function index(
        EventRepository    $events,
        Request            $request,
        PaginatorInterface $paginator,
    ): Response
    {
        /* ---------- query parameters & sane defaults -------------------- */
        $search    = trim((string)$request->query->get('search', ''));
        $filter    =              $request->query->get('filter', 'all');
        $page      = max(1, (int) $request->query->get('page',   1));
        $limit     = max(1, (int) $request->query->get('limit', 10));

        // full DQL paths - MUST match the <th> links below
        $allowed   = [
            'e.titre',
            'e.dateDebut',
            'e.state',
            'e.statut',
        ];
        $sort      = $request->query->get('sort',      'e.dateDebut');
        $direction = strtolower($request->query->get('direction', 'desc'));

        if (!in_array($sort, $allowed, true))        { $sort = 'e.dateDebut'; }
        if (!in_array($direction, ['asc','desc']))   { $direction = 'desc';   }

        /* ---------- query builder --------------------------------------- */
        $qb = $events->createQueryBuilder('e')
            ->leftJoin('e.participations', 'p')
            ->addSelect('COUNT(p.id) AS participantCount')
            ->groupBy('e.id');

        if ($search !== '') {
            $qb->andWhere(
                $qb->expr()->orX(
                    'LOWER(e.titre)       LIKE :q',
                    'LOWER(e.description) LIKE :q',
                    'LOWER(e.state)       LIKE :q'
                )
            )->setParameter('q', '%'.mb_strtolower($search).'%');
        }

        $now = new \DateTimeImmutable();
        switch ($filter) {
            case 'upcoming': $qb->andWhere('e.dateDebut >= :now')->setParameter('now',$now); break;
            case 'past':     $qb->andWhere('e.dateDebut <  :now')->setParameter('now',$now); break;
            case 'a_venir':  $qb->andWhere('e.statut = :s')->setParameter('s','A_VENIR');    break;
            case 'en_cours': $qb->andWhere('e.statut = :s')->setParameter('s','EN_COURS');   break;
            case 'termine':  $qb->andWhere('e.statut = :s')->setParameter('s','TERMINE');    break;
            case 'annule':   $qb->andWhere('e.statut = :s')->setParameter('s','ANNULE');     break;
            // default: no extra constraint
        }

        /* ---------- pagination (KNP adds ORDER BY automatically) --------- */
        $pagination = $paginator->paginate(
            $qb,
            $page,
            $limit,
            [
                'sortFieldParameterName'     => 'sort',
                'sortDirectionParameterName' => 'direction',
                'defaultSortFieldName'       => $sort,
                'defaultSortDirection'       => $direction,
                'distinct'                   => true,
            ]
        );

        /* ---------- view ------------------------------------------------- */
        return $this->render('admin/events.html.twig', [
            'pagination'     => $pagination,
            'current_filter' => $filter,
            'search_term'    => $search,
            'limit'          => $limit,
            'sort'           => $sort,
            'direction'      => $direction,
        ]);
    }

    /**
     * Displays a form to create a new Event entity.
     */
    #[Route('/new', name: 'app_admin_event_new', methods: ['GET', 'POST'])]
    public function new(Request $request): Response
    {
        $event = new Event();
        $event->setStatut('A_VENIR'); // Sensible default

        // Tell the form it's NOT an admin edit to hide the status field
        $form = $this->createForm(EventType::class, $event, ['is_admin_edit' => false]);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->persist($event);
            $this->entityManager->flush();

            $this->addFlash('success', 'Événement créé avec succès.');
            return $this->redirectToRoute('app_admin_events'); // Redirect to index
        }

        return $this->render('admin/event_form.html.twig', [ // Use a generic form template
            'event' => $event,
            'form' => $form->createView(),
            'page_title' => 'Nouvel Événement',
            'button_label' => 'Créer',
        ]);
    }

    /**
     * Displays a specific Event entity.
     */
    #[Route('/{id}', name: 'app_admin_event_show', methods: ['GET'])]
    public function show(Event $event): Response
    {
        // You might want a dedicated admin show template or reuse a public one
        return $this->render('admin/event_show.html.twig', [
            'event' => $event,
        ]);
    }

    /**
     * Displays a form to edit an existing Event entity.
     */
    #[Route('/{id}/edit', name: 'app_admin_event_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Event $event): Response
    {
        // Tell the form it IS an admin edit to show the status field
        $form = $this->createForm(EventType::class, $event, ['is_admin_edit' => true]);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->flush();

            $this->addFlash('success', 'Événement mis à jour avec succès.');
            return $this->redirectToRoute('app_admin_events'); // Redirect to index
        }

        return $this->render('admin/event_form.html.twig', [ // Use a generic form template
            'event' => $event,
            'form' => $form->createView(),
            'page_title' => 'Modifier l\'Événement',
            'button_label' => 'Mettre à jour',
        ]);
    }

    /**
     * "Deletes" (Cancels) an Event entity via POST request.
     */
    #[Route('/{id}', name: 'app_admin_event_delete', methods: ['POST'])]
    public function delete(Request $request, Event $event): Response
    {
        // Use a unique token name, e.g., 'delete_admin_' prefix
        if ($this->isCsrfTokenValid('delete_admin_' . $event->getId(), $request->request->get('_token'))) {
            $newStatus = $event->getStatut(); // Keep current status by default
            $message = '';
            $success = false;

            // Instead of removing, change status to ANNULE if applicable
            if (!in_array($event->getStatut(), ['TERMINE', 'ANNULE'])) {
                $event->setStatut('ANNULE'); // Use correct status value
                $this->entityManager->flush();
                $message = 'Événement annulé avec succès.';
                $success = true;
                $newStatus = 'ANNULE';
            } else {
                $message = 'L\'événement est déjà terminé ou annulé.';
                $success = false; // Indicate no change was made
            }

            // Handle AJAX request
            if ($request->isXmlHttpRequest()) {
                return new JsonResponse([
                    'success' => $success,
                    'message' => $message,
                    'newStatut' => $newStatus // Send back new status for potential UI update
                ]);
            }

            // Standard flash message for non-AJAX requests
            $this->addFlash($success ? 'success' : 'warning', $message);

        } else {
            if ($request->isXmlHttpRequest()) {
                return new JsonResponse(['success' => false, 'error' => 'Token CSRF invalide.'], Response::HTTP_BAD_REQUEST);
            }
            $this->addFlash('error', 'Token CSRF invalide.');
        }

        return $this->redirectToRoute('app_admin_events'); // Redirect to index
    }

    /**
     * Shows participants for a specific event.
     */
    #[Route('/{id}/participants', name: 'app_admin_event_participants')]
    public function eventParticipants(Event $event, ParticipationRepository $participationRepo): Response
    {
        // Fetch participations specifically for this event
        $participations = $participationRepo->findBy(['event' => $event], ['dateInscription' => 'DESC']);

        return $this->render('admin/event_participants.html.twig', [
            'event' => $event,
            'participants' => $participations, // Pass the fetched participations
        ]);
    }
}

// Helper function (can be placed in a utility class or trait if used often)
if (!function_exists('ends_with')) {
    function ends_with(string $haystack, string $needle): bool
    {
        return str_ends_with($haystack, $needle); // Use built-in str_ends_with if PHP 8+
        // Fallback for older PHP: return substr($haystack, -strlen($needle)) === $needle;
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/DashboardController.php -----
<?php
// src/Controller/Admin/DashboardController.php
namespace App\Controller\Admin;

use App\Repository\EventRepository;
use App\Repository\UtilisateurRepository;
use App\Repository\TrottinetteRepository;
use App\Repository\ReservationRepository;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Http\Attribute\IsGranted;

#[Route('/admin')]
#[IsGranted('ROLE_ADMIN')]
class DashboardController extends AbstractController
{
    #[Route('/', name: 'admin_dashboard')]
    public function dashboard(
        UtilisateurRepository $userRepo,
        TrottinetteRepository $trottinetteRepo,
        ReservationRepository $reservationRepo,
        EventRepository $eventRepository
    ) {
        $events = $eventRepository->findAll();

        $eventData = [];
        foreach ($events as $event) {
            $eventData[] = [
                'event' => $event,
                'participantCount' => $event->getParticipations()->count(),
                
            ];
        }

        
        return $this->render('admin/dashboard.html.twig', [
            'eventData' => $eventData,
            'user_count' => $userRepo->count([]),
            'trottinette_count' => $trottinetteRepo->count([]),
            'reservation_count' => $reservationRepo->count([]),
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/ReservationController.php -----
<?php

namespace App\Controller\Admin;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

class ReservationController extends AbstractController
{
    // TODO: actions
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/UtilisateurController.php -----
<?php
// src/Controller/Admin/UtilisateurController.php
namespace App\Controller\Admin;

use App\Entity\Utilisateur;
use App\Form\AdminUserType; // Use the specific Admin form
use App\Form\UserFilterType; // Use the filter form
use App\Repository\UtilisateurRepository;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Http\Attribute\IsGranted;

#[Route('/admin/utilisateurs')] // Base route for admin user management
#[IsGranted('ROLE_ADMIN')] // Ensure only admins can access
class UtilisateurController extends AbstractController
{
    private UserPasswordHasherInterface $passwordHasher;
    private EntityManagerInterface $entityManager;

    public function __construct(UserPasswordHasherInterface $passwordHasher, EntityManagerInterface $entityManager)
    {
        $this->passwordHasher = $passwordHasher;
        $this->entityManager = $entityManager;
    }

    #[Route('/', name: 'admin_utilisateur_index', methods: ['GET'])]
    public function index(Request $request, UtilisateurRepository $utilisateurRepository): Response
    {
        $filterForm = $this->createForm(UserFilterType::class);
        $filterForm->handleRequest($request);

        $pagination = $utilisateurRepository->findByCriteria(
            $filterForm->isSubmitted() && $filterForm->isValid() ? $filterForm->getData() : [],
            $request->query->getInt('page', 1),
            15 // Items per page
        );

        return $this->render('admin/utilisateur/index.html.twig', [
            'pagination' => $pagination, // Pass the Paginator object
            'filterForm' => $filterForm->createView(),
        ]);
    }

    #[Route('/new', name: 'admin_utilisateur_new', methods: ['GET', 'POST'])]
    public function new(Request $request): Response
    {
        $utilisateur = new Utilisateur();
        // Set default role if needed, e.g., $utilisateur->setRoleInterne('client');
        $form = $this->createForm(AdminUserType::class, $utilisateur);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            // Handle password
            $plainPassword = $form->get('plainPassword')->getData();
            if (!empty($plainPassword)) {
                $hashedPassword = $this->passwordHasher->hashPassword(
                    $utilisateur,
                    $plainPassword
                );
                $utilisateur->setPassword($hashedPassword);
            } else {
                // Handle case where password is required for new user but left empty
                // This shouldn't happen if constraints are set, but good practice
                $this->addFlash('danger', 'Le mot de passe est obligatoire pour un nouvel utilisateur.');
                return $this->render('admin/utilisateur/new.html.twig', [
                    'utilisateur' => $utilisateur,
                    'form' => $form->createView(),
                ]);
            }

            // Set default verification status if needed, e.g., $utilisateur->setIsVerified(true);
            // Or trigger verification email flow

            $this->entityManager->persist($utilisateur);
            $this->entityManager->flush();

            $this->addFlash('success', 'Utilisateur créé avec succès.');

            return $this->redirectToRoute('admin_utilisateur_index', [], Response::HTTP_SEE_OTHER);
        }

        return $this->render('admin/utilisateur/new.html.twig', [
            'utilisateur' => $utilisateur,
            'form' => $form->createView(),
        ]);
    }

    #[Route('/{id}', name: 'admin_utilisateur_show', methods: ['GET'])]
    public function show(Utilisateur $utilisateur): Response
    {
        // Prevent admins from showing their own profile via this route? Optional.
        // if ($utilisateur === $this->getUser()) { ... }

        return $this->render('admin/utilisateur/show.html.twig', [
            'utilisateur' => $utilisateur,
        ]);
    }

    #[Route('/{id}/edit', name: 'admin_utilisateur_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Utilisateur $utilisateur): Response
    {
        // Prevent admins from editing their own profile via this route? Optional.
        //if ($utilisateur === $this->getUser()) {
        //   $this->addFlash('warning', 'Pour modifier votre propre profil, utilisez la section Mon Profil.');
        //   return $this->redirectToRoute('admin_utilisateur_index');
        //}

        $form = $this->createForm(AdminUserType::class, $utilisateur);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            // Handle password update ONLY if a new one was entered
            $plainPassword = $form->get('plainPassword')->getData();
            if (!empty($plainPassword)) {
                $hashedPassword = $this->passwordHasher->hashPassword(
                    $utilisateur,
                    $plainPassword
                );
                $utilisateur->setPassword($hashedPassword);
            }

            $this->entityManager->flush();

            $this->addFlash('success', 'Utilisateur mis à jour avec succès.');

            return $this->redirectToRoute('admin_utilisateur_index', [], Response::HTTP_SEE_OTHER);
        }

        return $this->render('admin/utilisateur/edit.html.twig', [
            'utilisateur' => $utilisateur,
            'form' => $form->createView(),
        ]);
    }

    #[Route('/{id}', name: 'admin_utilisateur_delete', methods: ['POST'])]
    public function delete(Request $request, Utilisateur $utilisateur): Response
    {
        // Prevent admins from deleting themselves
        if ($utilisateur === $this->getUser()) {
            $this->addFlash('danger', 'Vous ne pouvez pas supprimer votre propre compte administrateur.');
            return $this->redirectToRoute('admin_utilisateur_index');
        }

        if ($this->isCsrfTokenValid('delete'.$utilisateur->getId(), $request->request->get('_token'))) {
            try {
                $this->entityManager->remove($utilisateur);
                $this->entityManager->flush();
                $this->addFlash('success', 'Utilisateur supprimé avec succès.');
            } catch (\Exception $e) {
                // Catch potential DB constraint issues if user has related records
                $this->addFlash('danger', 'Impossible de supprimer l\'utilisateur. Il est peut-être lié à d\'autres enregistrements (réservations, etc.). Détails: ' . $e->getMessage());
            }
        } else {
            $this->addFlash('danger', 'Token CSRF invalide.');
        }


        return $this->redirectToRoute('admin_utilisateur_index', [], Response::HTTP_SEE_OTHER);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/PointRelaisController.php -----
<?php

namespace App\Controller\Admin;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

class PointRelaisController extends AbstractController
{
    // TODO: actions
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/MaintenanceController.php -----
<?php

namespace App\Controller\Admin;

use App\Entity\Maintenance;
use App\Enum\MaintenanceStatus;
use App\Enum\TrottinetteStatus;
use App\Form\MaintenanceType;
use App\Repository\EventRepository;
use App\Repository\MaintenanceRepository;
use App\Repository\ParticipationRepository;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

use Symfony\Contracts\HttpClient\HttpClientInterface;

#[Route('/admin/maintenance')]
class MaintenanceController extends AbstractController
{
    private HttpClientInterface $client;
    public function __construct(HttpClientInterface $client
                     // Inject EventRepository

    )
    {
        $this->client = $client;

    }
    #[Route('/', name: 'admin_maintenance_index', methods: ['GET'])]
    public function index(MaintenanceRepository $maintenanceRepository): Response
    {
        return $this->render('maintenance/index.html.twig', [
            'maintenances' => $maintenanceRepository->findAll(),
        ]);
    }

    // --- NEW ACTION FOR CALENDAR VIEW ---
    #[Route('/calendar', name: 'admin_maintenance_calendar', methods: ['GET'])]
    public function calendarView(MaintenanceRepository $maintenanceRepository): Response
    {
        // Fetch ALL maintenance records (Consider limiting by date range for performance if needed)
        $maintenances = $maintenanceRepository->findAll();

        $calendarEvents = [];
        foreach ($maintenances as $maintenance) {
            $trottinetteInfo = $maintenance->getTrottinette()
                ? 'Trott. #' . $maintenance->getTrottinetteId() . ' (' . $maintenance->getTrottinette()->getModele() . ')'
                : 'Trott. #' . $maintenance->getTrottinetteId();

            // Determine color based on status
            $color = match($maintenance->getStatut()) {
                'EN_COURS' => '#facc15', // yellow-400 approx
                'TERMINEE' => '#4ade80', // green-400 approx
                'ANNULEE' => '#f87171', // red-400 approx
                default => '#9ca3af', // gray-400 approx
            };

            // Format data for FullCalendar
            $calendarEvents[] = [
                'id' => $maintenance->getId(),
                'title' => $trottinetteInfo, // Title shown on the calendar event
                'start' => $maintenance->getDateDebut()->format('Y-m-d H:i:s'), // ISO8601 format
                // FullCalendar handles events without end dates correctly
                'end' => $maintenance->getDateFin()?->format('Y-m-d H:i:s'), // Nullable end date
                'color' => $color, // Background color for the event
                'extendedProps' => [ // Store extra data accessible on click
                    'description' => $maintenance->getDescription() ?: 'N/A',
                    'statut' => $maintenance->getStatut(),
                    'trottinetteId' => $maintenance->getTrottinetteId(),
                    'trottinetteModele' => $maintenance->getTrottinette()?->getModele(),
                    'trottinetteNumeroSerie' => $maintenance->getTrottinette()?->getNumeroSerie(),
                    'dateFinFormatted' => $maintenance->getDateFin() ? $maintenance->getDateFin()->format('d/m/Y H:i') : 'En cours',
                    'detailsUrl' => $this->generateUrl('admin_maintenance_show', ['id' => $maintenance->getId()]) // Link to detail page
                ]
            ];
        }

        // Pass the JSON encoded data to the Twig template
        return $this->render('maintenance/calendar.html.twig', [
            'maintenanceEventsJson' => json_encode($calendarEvents)
        ]);
    }
    // --- END NEW ACTION ---

    #[Route('/new', name: 'admin_maintenance_new', methods: ['GET', 'POST'])]
    public function new(Request $request, EntityManagerInterface $entityManager): Response
    {
        $maintenance = new Maintenance();
        $form = $this->createForm(MaintenanceType::class, $maintenance);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            // Set the trottinette ID from the selected trottinette
            if ($maintenance->getTrottinette()) {
                $maintenance->setTrottinetteId($maintenance->getTrottinette()->getId());
                
                // Update trottinette status to EN_MAINTENANCE
                $trottinette = $maintenance->getTrottinette();
                $trottinette->setEtat(TrottinetteStatus::EN_MAINTENANCE);
            }
            
            $entityManager->persist($maintenance);
            $entityManager->flush();

            // Add a flash message to confirm successful creation
            $this->addFlash('success', 'La maintenance a été créée avec succès.');

            return $this->redirectToRoute('admin_maintenance_index', [], Response::HTTP_SEE_OTHER);
        }

        return $this->renderForm('maintenance/new.html.twig', [
            'maintenance' => $maintenance,
            'form' => $form,
        ]);
    }

    #[Route('/{id}', name: 'admin_maintenance_show', methods: ['GET'])]
    public function show(Maintenance $maintenance): Response
    {
        return $this->render('maintenance/show.html.twig', [
            'maintenance' => $maintenance,
        ]);
    }

    #[Route('/{id}/edit', name: 'admin_maintenance_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Maintenance $maintenance, EntityManagerInterface $entityManager): Response
    {
        $form = $this->createForm(MaintenanceType::class, $maintenance);

        // Remove any code that might be setting form['cout']
        // Remove any code that might be setting form['technicien']

        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            // Remove any code that might be setting maintenance.cout
            // Remove any code that might be setting maintenance.technicien


            if ($maintenance->getStatut() === MaintenanceStatus::TERMINE ||$maintenance->getStatut() === "TERMINEE") {

                $trottinette = $maintenance->getTrottinette();
                if ($trottinette) {
                    $trottinette->setEtat(TrottinetteStatus::DISPONIBLE);
                }


                $trottinetteInfo = $trottinette
                    ? 'Trottinette #' . $maintenance->getTrottinetteId() . ' (' . $trottinette->getModele() . ')'
                    : 'Trottinette #' . $maintenance->getTrottinetteId();

                // Create a concise plain text message for SMS
                $smsMessage = "Maintenance terminée pour {$trottinetteInfo}. Elle est maintenant disponible.";
                // You could add more details if needed, but keep SMS length in mind
                // $smsMessage .= " ID: " . $maintenance->getId();


                $payload = [
                    'body'  => $smsMessage,
                ];
                $headers = [
                    'Content-Type' => 'application/json',
                ];

                $response = $this->client->request('POST', "https://hook.eu1.make.com/ndgogmlq27hd1j6toex8eusathvnag8q", [
                    'headers' => $headers,
                    'json'    => $payload,
                ]);
            }
            
            $entityManager->flush();

            // Add a flash message to confirm successful update
            $this->addFlash('success', 'La maintenance a été mise à jour avec succès.');

            return $this->redirectToRoute('admin_maintenance_index', [], Response::HTTP_SEE_OTHER);
        }

        return $this->renderForm('maintenance/edit.html.twig', [
            'maintenance' => $maintenance,
            'form' => $form,
        ]);
    }

    #[Route('/{id}', name: 'admin_maintenance_delete', methods: ['POST'])]
    public function delete(Request $request, Maintenance $maintenance, EntityManagerInterface $entityManager): Response
    {
        if ($this->isCsrfTokenValid('delete'.$maintenance->getId(), $request->request->get('_token'))) {
            $trottinette = $maintenance->getTrottinette();
            if ($trottinette && $trottinette->getEtat() === TrottinetteStatus::EN_MAINTENANCE) {
                $trottinette->setEtat(TrottinetteStatus::DISPONIBLE);
            }
            
            $entityManager->remove($maintenance);
            $entityManager->flush();
            $this->addFlash('success', 'La maintenance a été supprimée avec succès.');
        }

        return $this->redirectToRoute('admin_maintenance_index');
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Admin/ReclamationController.php -----
<?php

namespace App\Controller\Admin;

use App\Entity\Reponse; // Importer l'entité Reponse
use App\Form\ReponseType; // Importer le formulaire Reponse
use App\Entity\Reclamation;
use App\Form\ReclamationType;
use App\Repository\ReclamationRepository;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

#[Route('/reclamation')]
class ReclamationController extends AbstractController
{
    // Route pour afficher toutes les réclamations
    #[Route('', name: 'reclamation_index', methods: ['GET'])]
    public function index(ReclamationRepository $reclamationRepository): Response
    {
        return $this->render('reclamation/index.html.twig', [
            'reclamations' => $reclamationRepository->findAll(),
        ]);
    }

    // Route pour la création d'une nouvelle réclamation
    #[Route('/new', name: 'reclamation_new', methods: ['GET', 'POST'])]
    public function new(Request $request, EntityManagerInterface $em): Response
    {
        $reclamation = new Reclamation();

        // Associer l'utilisateur connecté à la réclamation
        if ($this->getUser()) {
            $reclamation->setUtilisateur($this->getUser());
        } else {
            // Si pas connecté, rediriger vers la page de connexion
            $this->addFlash('error', 'Vous devez être connecté pour créer une réclamation.');
            return $this->redirectToRoute('app_login');
        }

        $form = $this->createForm(ReclamationType::class, $reclamation);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            if ($reclamation->getDateCreation() === null) {
                $reclamation->setDateCreation(new \DateTime());
            }

            $em->persist($reclamation);
            $em->flush();

            $this->addFlash('success', 'Réclamation créée avec succès.');
            return $this->redirectToRoute('reclamation_index');
        }

        return $this->render('reclamation/new.html.twig', [
            'form' => $form->createView(),
        ]);
    }
    // Route pour afficher une réclamation spécifique
    #[Route('/{id}', name: 'reclamation_show', methods: ['GET'])]
    public function show(Reclamation $reclamation): Response
    {
        return $this->render('reclamation/show.html.twig', [
            'reclamation' => $reclamation,
        ]);
    }

    // Route pour modifier une réclamation existante
    #[Route('/{id}/edit', name: 'reclamation_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Reclamation $reclamation, EntityManagerInterface $em): Response
    {
        $form = $this->createForm(ReclamationType::class, $reclamation);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $em->flush();

            $this->addFlash('success', 'Réclamation mise à jour.');
            return $this->redirectToRoute('reclamation_index');
        }

        return $this->render('reclamation/edit.html.twig', [
            'reclamation' => $reclamation,
            'form' => $form->createView(),
        ]);
    }

    // Route pour supprimer une réclamation
    #[Route('/{id}', name: 'reclamation_delete', methods: ['POST'])]
    public function delete(Request $request, Reclamation $reclamation, EntityManagerInterface $em): Response
    {
        if ($this->isCsrfTokenValid('delete'.$reclamation->getId(), $request->request->get('_token'))) {
            $em->remove($reclamation);
            $em->flush();

            $this->addFlash('success', 'Réclamation supprimée.');
        }

        return $this->redirectToRoute('reclamation_index');
    }

    // Route pour répondre à une réclamation spécifique
    #[Route('/reclamation/{id}/repondre', name: 'reclamation_repondre', methods: ['GET', 'POST'])]
    public function repondre(Request $request, Reclamation $reclamation, EntityManagerInterface $em): Response
    {
        // Crée une nouvelle réponse
        $reponse = new Reponse();
        $reponse->setReclamation($reclamation);
        $reponse->setAuteur($this->getUser()); // Assigner l'auteur de la réponse (l'utilisateur connecté)

        // Créer et gérer le formulaire
        $form = $this->createForm(ReponseType::class, $reponse);
        $form->handleRequest($request);

        // Si le formulaire est soumis et valide
        if ($form->isSubmitted() && $form->isValid()) {
            $em->persist($reponse);
            $em->flush();  // Sauvegarde la réponse dans la base de données

            $this->addFlash('success', 'Votre réponse a été ajoutée avec succès.');

            return $this->redirectToRoute('reclamation_show', ['id' => $reclamation->getId()]);
        }

        // Rendu du formulaire de réponse
        return $this->render('reclamation/repondre.html.twig', [
            'form' => $form->createView(),
            'reclamation' => $reclamation,
        ]);
    }

}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/RegistrationController.php -----
<?php
// src/Controller/RegistrationController.php

namespace App\Controller;

use App\Entity\Utilisateur;
use App\Form\RegistrationFormType;
use App\Security\EmailVerifier; // Import EmailVerifier
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bridge\Twig\Mime\TemplatedEmail; // For email template
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Mime\Address; // For email address
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use Symfony\Component\Routing\Annotation\Route;
// use SymfonyCasts\Bundle\VerifyEmail\Exception\VerifyEmailExceptionInterface; // Import if handling exceptions here

class RegistrationController extends AbstractController
{
    private EmailVerifier $emailVerifier;

    // Inject EmailVerifier
    public function __construct(EmailVerifier $emailVerifier)
    {
        $this->emailVerifier = $emailVerifier;
    }

    #[Route('/inscription', name: 'app_register', methods: ['GET', 'POST'])]
    public function register(Request $request, UserPasswordHasherInterface $passwordHasher, EntityManagerInterface $entityManager): Response
    {
        // Redirect if already logged in
        if ($this->getUser()) {
            return $this->redirectToRoute('app_home'); // Or client dashboard
        }

        $user = new Utilisateur();
        $form = $this->createForm(RegistrationFormType::class, $user);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            // Get plain password from the form
            $plainPassword = $form->get('plainPassword')->getData();

            // Ensure password is not empty (should be caught by constraints, but double-check)
            if (empty($plainPassword)) {
                $this->addFlash('danger', 'Le mot de passe ne peut être vide.');
                return $this->render('registration/register.html.twig', [
                    'registrationForm' => $form->createView(),
                ]);
            }

            // Encode the plain password
            $user->setPassword(
                $passwordHasher->hashPassword(
                    $user,
                    $plainPassword
                )
            );

            // Set default role (e.g., 'client')
            $user->setRoleInterne('client'); // Use the setter for internal role string
            $user->setIsVerified(false); // User starts as unverified
            $user->setIsActive(true); // User starts as active

            // --- REMOVE FACE EMBEDDING LOGIC ---
            // $faceEmbeddingString = $form->get('face_embedding_data')->getData();
            // if (!empty($faceEmbeddingString)) {
            //     $user->setFaceEmbedding($faceEmbeddingString); // Save the embedding string
            // } else {
            //     // This should not happen if JS/validation works, but handle it
            //     $this->addFlash('danger', 'Erreur: Données faciales manquantes après validation.');
            //     return $this->render('registration/register.html.twig', [
            //         'registrationForm' => $form->createView(),
            //     ]);
            // }
            // --- END REMOVAL ---

            $entityManager->persist($user);
            $entityManager->flush();

            // Generate a signed URL and email it to the user
            try {
                $this->emailVerifier->sendEmailConfirmation(
                    'app_verify_email', // Route name of your verification action
                    $user,
                    (new TemplatedEmail())
                        ->from(new Address('mailer@yourdomain.com', 'TrottiCare Mail Bot')) // Change sender
                        ->to(new Address($user->getEmail(), $user->getFullName()))
                        ->subject('Veuillez confirmer votre email pour TrottiCare')
                        ->htmlTemplate('registration/confirmation_email.html.twig') // Path to your email template
                );
                $this->addFlash('success', 'Inscription réussie ! Un email de vérification a été envoyé à ' . $user->getEmail() . '. Veuillez cliquer sur le lien pour activer votre compte.');

            } catch (\Symfony\Component\Mailer\Exception\TransportExceptionInterface $e) {
                $this->addFlash('error', 'Impossible d\'envoyer l\'email de vérification. Erreur: ' . $e->getMessage());
                // Consider logging the error more formally
                // Optionally, you might want to remove the user if email fails critically,
                // or mark them for manual verification.
            }


            // Redirect to login page after sending email
            return $this->redirectToRoute('app_login_page');

        } elseif ($form->isSubmitted()) {
            // Add a generic error if submitted but invalid (specific errors are shown by fields)
            $this->addFlash('danger', 'Le formulaire contient des erreurs. Veuillez vérifier.');
        }

        return $this->render('registration/register.html.twig', [
            'registrationForm' => $form->createView(),
        ]);
    }

    // --- ADD EMAIL VERIFICATION ACTION ---
    // This route needs to be defined (e.g., in routes.yaml or here)
    // Make sure it matches the name used in sendEmailConfirmation ('app_verify_email')
    #[Route('/verify/email', name: 'app_verify_email')]
    public function verifyUserEmail(Request $request, EntityManagerInterface $entityManager): Response // Removed UserRepository, not needed directly here if using VerifyEmailHelper
    {
        // This requires the user to be logged in *before* verifying.
        // If you want verification without login, the approach changes slightly (see bundle docs).
        $this->denyAccessUnlessGranted('IS_AUTHENTICATED_FULLY'); // Ensure user is logged in

        /** @var Utilisateur $user */
        $user = $this->getUser();
        if (!$user) {
            $this->addFlash('danger', 'Utilisateur non trouvé pour la vérification.');
            return $this->redirectToRoute('app_register'); // Or login
        }

        // Validate email confirmation link, sets User::isVerified=true and persists
        try {
            // Use the injected EmailVerifier service
            $this->emailVerifier->handleEmailConfirmation($request, $user); // Pass the user entity
        } catch (\SymfonyCasts\Bundle\VerifyEmail\Exception\VerifyEmailExceptionInterface $exception) {
            $this->addFlash('danger', $exception->getReason()); // Use getReason() for user-friendly messages
            return $this->redirectToRoute('app_register'); // Or login
        }

        // If successful, handleEmailConfirmation already flushes the entity manager

        $this->addFlash('success', 'Votre adresse email a été vérifiée. Vous pouvez maintenant vous connecter.');

        // Redirect to login or maybe client dashboard if you want auto-login after verification
        return $this->redirectToRoute('app_login_page');
    }

}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/ReservationController.php -----
<?php

namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;
use App\Repository\ReservationRepository;
use Symfony\Component\HttpFoundation\Request;
use Doctrine\ORM\EntityManagerInterface;
use App\Entity\Reservation;
use App\Form\ReservationType;
use Symfony\Component\Security\Core\Security;



#[Route('/admin/reservations')]
final class ReservationController extends AbstractController
{

    private Security $security;
    private EntityManagerInterface $entityManager;

    public function __construct(Security $security, EntityManagerInterface $entityManager)
    {
        $this->security = $security;
        $this->entityManager = $entityManager;
    }

    
    #[Route('/', name: 'reservation_index', methods: ['GET'])]
    public function index(ReservationRepository $reservationRepository): Response
    {
        return $this->render('reservation/index.html.twig', [
            'reservations' => $reservationRepository->findAll(),
        ]);
    }
    #[Route('/new', name: 'reservation_new', methods: ['GET', 'POST'])]
    public function new(Request $request): Response
    {
        // Crée une nouvelle réservation
        $reservation = new Reservation();

        // Récupérer l'utilisateur authentifié
        $utilisateur = $this->security->getUser();
        if ($utilisateur) {
            // Associer l'utilisateur à la réservation
            $reservation->setUtilisateur($utilisateur);
        }

        // Créer le formulaire pour la réservation
        $form = $this->createForm(ReservationType::class, $reservation);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            // Sauvegarder la réservation dans la base de données
            $this->entityManager->persist($reservation);
            $this->entityManager->flush();

            // Ajouter un message flash de succès
            $this->addFlash('success', 'Réservation effectuée avec succès.');

            // Rediriger l'utilisateur vers une autre page après la soumission du formulaire
            return $this->redirectToRoute('reservation_index'); // Ajustez le chemin de redirection
        }

        // Afficher le formulaire
        return $this->render('reservation/new.html.twig', [
            'form' => $form->createView(),
        ]);
    }

#[Route('/{id}', name: 'reservation_show', methods: ['GET'])]
public function show(Reservation $reservation): Response
{
    return $this->render('reservation/show.html.twig', [
        'reservation' => $reservation,
    ]);
}

#[Route('/{id}/edit', name: 'reservation_edit', methods: ['GET', 'POST'])]
public function edit(Request $request, Reservation $reservation, EntityManagerInterface $em): Response
{
    $form = $this->createForm(ReservationType::class, $reservation);
    $form->handleRequest($request);

    if ($form->isSubmitted() && $form->isValid()) {
        $em->flush();

        $this->addFlash('success', 'Réservation mise à jour.');
        return $this->redirectToRoute('reservation_index');
    }

    return $this->render('reservation/edit.html.twig', [
        'reservation' => $reservation,
        'form' => $form->createView(),
    ]);
}

#[Route('/{id}', name: 'reservation_delete', methods: ['POST'])]
public function delete(Request $request, Reservation $reservation, EntityManagerInterface $em): Response
{
    if ($this->isCsrfTokenValid('delete'.$reservation->getId(), $request->request->get('_token'))) {
        $em->remove($reservation);
        $em->flush();

        $this->addFlash('success', 'Réservation supprimée.');
    }

    return $this->redirectToRoute('reservation_index');
}

}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Public/HomeController.php -----
<?php

namespace App\Controller\Public;

use App\Repository\EventRepository;
use App\Repository\TrottinetteRepository;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;
use Psr\Log\LoggerInterface;

class HomeController extends AbstractController
{
    private LoggerInterface $logger;

    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    #[Route('/', name: 'app_home', methods: ['GET'])]
    public function index(TrottinetteRepository $trottinetteRepository, EventRepository $eventRepository): Response
    {
        $this->logger->info('Public\HomeController::index processing started (No Map).');

        $availableScooters = [];
        $upcomingEvents = [];
        $scootersForView = [];
        $eventsForView = [];

        try {
            // Fetch available scooters
            $availableScooters = $trottinetteRepository->findBy(['etat' => 'DISPONIBLE'], ['dateAjout' => 'DESC'], 8); // Limit to 8 scooters
            $this->logger->info(sprintf('Fetched %d available scooters.', count($availableScooters)));

            // Fetch upcoming events
            if (method_exists($eventRepository, 'findUpcomingEvents')) {
                $upcomingEvents = $eventRepository->findUpcomingEvents(3); // Limit to 3 events
            } else {
                $this->logger->warning('Method findUpcomingEvents not found in EventRepository.');
                $upcomingEvents = $eventRepository->findBy([], ['dateDebut' => 'ASC'], 3);
            }
            $this->logger->info(sprintf('Fetched %d upcoming events.', count($upcomingEvents)));

            // --- Prepare Scooter Card Data ---
            foreach ($availableScooters as $scooter) {
                $scootersForView[] = [
                    'entity' => $scooter,
                    'distanceString' => "Adresse: " . ($scooter->getLocalisation() ?: 'Inconnue'), // Placeholder
                    'pricePerMinute' => "0.15 €/min", // Placeholder
                    'image_url' => null // Add logic if needed
                ];
            }

            // --- Prepare Event Card Data ---
            foreach ($upcomingEvents as $event) {
                $eventsForView[] = [
                    'entity' => $event,
                    // Use state (Gouvernorat) for location if available
                    'location' => $event->getState()?->label() ?? 'Lieu à définir'
                ];
            }

        } catch (\Exception $e) {
            $this->logger->error('Error preparing homepage data: ' . $e->getMessage(), ['exception' => $e]);
            $this->addFlash('error', 'Une erreur est survenue lors du chargement de la page.');
            $scootersForView = [];
            $eventsForView = [];
        }

        // --- Prepare Context for Rendering (NO MAP DATA) ---
        $context = [
            'controller_name' => 'HomeController',
            'scooters' => $scootersForView,
            'upcoming_events' => $eventsForView,
            // 'markersJson' => REMOVED,
            // 'mapCenterLat' => REMOVED,
            // 'mapCenterLng' => REMOVED,
            // 'mapZoom' => REMOVED,
            'heroTitle' => 'Découvrez la ville autrement',
            'heroSubtitle' => 'Louez nos trottinettes électriques facilement. Disponibles 24/7, écologiques et fun !',
        ];

        $this->logger->debug('Rendering public/home/index.html.twig (No Map) with keys: ' . implode(', ', array_keys($context)));

        // --- Render View ---
        return $this->render('public/home/index.html.twig', $context);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Public/RegistrationController.php -----
<?php

namespace App\Controller\Public;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

class RegistrationController extends AbstractController
{
    // TODO: actions
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Public/PublicTrottinetteController.php -----
<?php

namespace App\Controller\Public;

use App\Entity\Trottinette;
use App\Enum\TrottinetteStatus;
use App\Repository\TrottinetteRepository;
use Knp\Component\Pager\PaginatorInterface; // Use KnpPaginator if installed
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route; // Or use Attribute
use Psr\Log\LoggerInterface;

#[Route('/trottinettes')] // Base route for this controller
class PublicTrottinetteController extends AbstractController
{
    private LoggerInterface $logger;

    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    #[Route('', name: 'public_trottinette_index', methods: ['GET'])]
    public function index(
        Request $request,
        TrottinetteRepository $trottinetteRepository,
        PaginatorInterface $paginator // Inject PaginatorInterface
    ): Response {
        $this->logger->info('Public trottinette index page accessed.');

        // --- Get parameters from request ---
        $search = $request->query->get('search', '');
        $statusFilter = $request->query->get('status', 'all'); // 'all', 'DISPONIBLE', 'EN_MAINTENANCE', etc.
        $sort = $request->query->get('sort', 'date_desc'); // Default sort
        $page = $request->query->getInt('page', 1);
        $limit = $request->query->getInt('limit', 12); // Default items per page (adjust as needed)

        // --- Build Query ---
        $queryBuilder = $trottinetteRepository->createQueryBuilder('t')
            ->leftJoin('t.pointRelais', 'pr'); // Join for potential sorting/filtering by point relais later

        // Apply Search Filter
        if (!empty($search)) {
            $searchTerm = '%' . mb_strtolower($search) . '%';
            $queryBuilder->andWhere(
                $queryBuilder->expr()->orX(
                    $queryBuilder->expr()->like('LOWER(t.modele)', ':search'),
                    $queryBuilder->expr()->like('LOWER(t.numeroSerie)', ':search'),
                    $queryBuilder->expr()->like('LOWER(t.localisation)', ':search'),
                    $queryBuilder->expr()->like('LOWER(pr.nom)', ':search') // Search by point relais name
                )
            )->setParameter('search', $searchTerm);
        }

        // Apply Status Filter (only if not 'all')
        if ($statusFilter !== 'all' && !empty($statusFilter)) {
            // Validate if the status exists in the Enum
            $statusEnumValue = TrottinetteStatus::tryFrom($statusFilter);
            if ($statusEnumValue) {
                $queryBuilder->andWhere('t.etat = :status')
                    ->setParameter('status', $statusEnumValue);
            } else {
                $this->logger->warning(sprintf('Invalid status filter value received: %s', $statusFilter));
                // Maybe add a flash message or ignore the filter
            }
        }

        // Apply Sorting
        switch ($sort) {
            case 'model_asc':
                $queryBuilder->orderBy('t.modele', 'ASC');
                break;
            case 'model_desc':
                $queryBuilder->orderBy('t.modele', 'DESC');
                break;
            case 'battery_asc':
                $queryBuilder->orderBy('t.batterie', 'ASC');
                break;
            case 'battery_desc':
                $queryBuilder->orderBy('t.batterie', 'DESC');
                break;
            case 'date_asc':
                $queryBuilder->orderBy('t.dateAjout', 'ASC');
                break;
            case 'date_desc':
            default: // Default sort
                $queryBuilder->orderBy('t.dateAjout', 'DESC');
                $sort = 'date_desc'; // Ensure sort variable reflects default
                break;
        }

        // --- Paginate ---
        $pagination = $paginator->paginate(
            $queryBuilder->getQuery(), // Doctrine Query object
            $page, // Current page number
            $limit // Limit per page
        );

        $this->logger->info(sprintf('Displaying page %d of trottinettes with limit %d (search: "%s", status: "%s", sort: "%s")', $page, $limit, $search, $statusFilter, $sort));

        // --- Prepare data for the scooter cards (if needed, same as HomeController) ---
        $scootersForView = [];
        foreach ($pagination->getItems() as $scooter) {
            $scootersForView[] = [
                'entity' => $scooter,
                'distanceString' => "Adresse: " . ($scooter->getLocalisation() ?: 'Inconnue'), // Placeholder
                'pricePerMinute' => "0.15 TND/min", // Placeholder - ADJUST CURRENCY/VALUE
                'image_url' => null // Add logic if needed
            ];
        }

        return $this->render('public/trottinette/index.html.twig', [
            'pagination' => $pagination, // Pass the Paginator object
            'scooters_data' => $scootersForView, // Pass prepared data for cards
            'current_search' => $search,
            'current_status' => $statusFilter,
            'current_sort' => $sort,
            'current_limit' => $limit,
            'limit_options' => [3, 6, 12, 20], // Options for items per page dropdown
        ]);
    }

    // You might add a show route here later: #[Route('/{id}', name: 'public_trottinette_show')]
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Public/ResetPasswordController.php -----
<?php

namespace App\Controller\Public;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

class ResetPasswordController extends AbstractController
{
    // TODO: actions
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Partenaire/TrottinetteController.php -----
<?php

namespace App\Controller\Partenaire;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

class TrottinetteController extends AbstractController
{
    // TODO: actions
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Partenaire/DashboardController.php -----
<?php
// src/Controller/Partenaire/DashboardController.php
namespace App\Controller\Partenaire;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Http\Attribute\IsGranted;
// You might inject repositories here later if you need stats
 use App\Repository\TrottinetteRepository;
 use App\Repository\EventRepository;

#[Route('/partenaire')]
// IMPORTANT: Apply security HERE at the controller level, not on individual links in Twig
#[IsGranted('ROLE_PARTENAIRE')]
class DashboardController extends AbstractController
{
    #[Route('/dashboard', name: 'app_partenaire_dashboard')]
    public function index(
        // Inject repositories if needed for stats later
         TrottinetteRepository $trottinetteRepository,
         EventRepository $eventRepository
    ): Response
    {
        $partenaire = $this->getUser(); // Get the logged-in partner

        // Example: Fetch stats later
         $trottinettesCount = $trottinetteRepository->count(['utilisateur' => $partenaire]);
//         $eventsCount = $eventRepository->count(['organisateur' => $partenaire]); // Assuming an 'organisateur' field

        return $this->render('partenaire/dashboard/index.html.twig', [
            'controller_name' => 'PartenaireDashboardController',
            'partenaire' => $partenaire,
            // Pass stats later:
             'trottinettes_count' => $trottinettesCount,
//             'events_count' => $eventsCount,
        ]);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Partenaire/MaintenanceController.php -----
<?php

namespace App\Controller\Partenaire;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

class MaintenanceController extends AbstractController
{
    // TODO: actions
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/PointRelaisController.php -----
<?php

namespace App\Controller;

use App\Entity\PointRelais;
use App\Form\PointRelaisType;
use App\Repository\PointRelaisRepository;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

#[Route('/admin/point-relais')]
final class PointRelaisController extends AbstractController
{
    #[Route('/', name: 'point_relais_index', methods: ['GET'])]
    public function index(PointRelaisRepository $pointRelaisRepository): Response
    {
        return $this->render('point_relais/index.html.twig', [
            'point_relais' => $pointRelaisRepository->findAll(),
        ]);
    }

    #[Route('/new', name: 'point_relais_new', methods: ['GET', 'POST'])]
    public function new(Request $request, EntityManagerInterface $em): Response
    {
        $pointRelais = new PointRelais();
        $form = $this->createForm(PointRelaisType::class, $pointRelais);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $em->persist($pointRelais);
            $em->flush();

            $this->addFlash('success', 'Point relais créé avec succès.');
            return $this->redirectToRoute('point_relais_index');
        }
        if ($form->isSubmitted() && !$form->isValid()) {
            $this->addFlash('danger', 'Le formulaire contient des erreurs. Veuillez corriger les champs.');
        }

        return $this->render('point_relais/new.html.twig', [
            'form' => $form->createView(),
        ]);
    }

    #[Route('/{id}', name: 'point_relais_show', methods: ['GET'])]
    public function show(PointRelais $pointRelais): Response
    {
        return $this->render('point_relais/show.html.twig', [
            'point_relais' => $pointRelais,
        ]);
    }

    #[Route('/{id}/edit', name: 'point_relais_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, PointRelais $pointRelais, EntityManagerInterface $em): Response
    {
        $form = $this->createForm(PointRelaisType::class, $pointRelais);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $em->flush();
            $this->addFlash('success', 'Point relais mis à jour avec succès.');

            return $this->redirectToRoute('point_relais_index');
        }
        if ($form->isSubmitted() && !$form->isValid()) {
            $this->addFlash('danger', 'Le formulaire contient des erreurs. Veuillez corriger les champs.');
        }
        
        return $this->render('point_relais/edit.html.twig', [
            'form' => $form->createView(),
            'point_relais' => $pointRelais,
        ]);
    }

    #[Route('/{id}', name: 'point_relais_delete', methods: ['POST'])]
    public function delete(Request $request, PointRelais $pointRelais, EntityManagerInterface $em): Response
    {
        if ($this->isCsrfTokenValid('delete' . $pointRelais->getId(), $request->request->get('_token'))) {
            $em->remove($pointRelais);
            $em->flush();
            $this->addFlash('success', 'Point relais supprimé.');
        }

        return $this->redirectToRoute('point_relais_index');
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/ReclamationController.php -----
<?php

namespace App\Controller;

use App\Entity\Reponse;
use App\Form\ReponseType;
use App\Entity\Reclamation;
use App\Form\ReclamationType;
use App\Repository\ReclamationRepository;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Http\Attribute\IsGranted;

#[Route('/reclamation')]
class ReclamationController extends AbstractController
{
    #[Route('', name: 'reclamation_index', methods: ['GET'])]
    public function index(ReclamationRepository $reclamationRepository): Response
    {
        return $this->render('reclamation/index.html.twig', [
            'reclamations' => $reclamationRepository->findAll(),
        ]);
    }

    #[IsGranted('ROLE_USER')]
    #[Route('/new', name: 'reclamation_new', methods: ['GET', 'POST'])]
    public function new(Request $request, EntityManagerInterface $em): Response
    {
        $reclamation = new Reclamation();
        $reclamation->setUtilisateur($this->getUser());

        $form = $this->createForm(ReclamationType::class, $reclamation);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            if ($reclamation->getDateCreation() === null) {
                $reclamation->setDateCreation(new \DateTime());
            }

            $em->persist($reclamation);
            $em->flush();

            $this->addFlash('success', 'Réclamation créée avec succès.');
            return $this->redirectToRoute('reclamation_index');
        }

        return $this->render('reclamation/new.html.twig', [
            'form' => $form->createView(),
        ]);
    }

    #[Route('/{id}', name: 'reclamation_show', methods: ['GET'])]
    public function show(Reclamation $reclamation): Response
    {
        return $this->render('reclamation/show.html.twig', [
            'reclamation' => $reclamation,
        ]);
    }

    #[Route('/{id}/edit', name: 'reclamation_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Reclamation $reclamation, EntityManagerInterface $em): Response
    {
        $form = $this->createForm(ReclamationType::class, $reclamation);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $em->flush();

            $this->addFlash('success', 'Réclamation mise à jour.');
            return $this->redirectToRoute('reclamation_index');
        }

        return $this->render('reclamation/edit.html.twig', [
            'reclamation' => $reclamation,
            'form' => $form->createView(),
        ]);
    }

    #[Route('/{id}', name: 'reclamation_delete', methods: ['POST'])]
    public function delete(Request $request, Reclamation $reclamation, EntityManagerInterface $em): Response
    {
        if ($this->isCsrfTokenValid('delete' . $reclamation->getId(), $request->request->get('_token'))) {
            $em->remove($reclamation);
            $em->flush();
            $this->addFlash('success', 'Réclamation supprimée.');
        }

        return $this->redirectToRoute('reclamation_index');
    }

    #[IsGranted('ROLE_ADMIN')]
    #[Route('/{id}/repondre', name: 'reclamation_repondre', methods: ['GET', 'POST'])]
    public function repondre(Request $request, Reclamation $reclamation, EntityManagerInterface $em): Response
    {
        $reponse = new Reponse();
        $reponse->setReclamation($reclamation);
        $reponse->setAuteur($this->getUser());

        $form = $this->createForm(ReponseType::class, $reponse);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $em->persist($reponse);
            $em->flush();

            $this->addFlash('success', 'Votre réponse a été ajoutée avec succès.');
            return $this->redirectToRoute('reclamation_show', ['id' => $reclamation->getId()]);
        }

        return $this->render('reclamation/repondre.html.twig', [
            'form' => $form->createView(),
            'reclamation' => $reclamation,
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/PublicEventController.php -----
<?php
// src/Controller/PublicEventController.php
namespace App\Controller; // Adjust namespace if needed (e.g., App\Controller\Public)

use App\Entity\Event;
use App\Entity\Utilisateur;
use App\Enum\ParticipationStatus;
use App\Repository\EventRepository;
use App\Repository\ParticipationRepository; // Optional: If checking participation status
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route; // Or use Attribute if PHP 8+
use Psr\Log\LoggerInterface;
use Symfony\Component\Security\Http\Attribute\IsGranted; // For security attribute
use Knp\Snappy\Pdf; // Import Snappy's PDF service
use Endroid\QrCodeBundle\Response\QrCodeResponse; // Or use the generator interface
use Endroid\QrCode\Builder\BuilderInterface; // Use the Builder for more control
use Endroid\QrCode\Encoding\Encoding;
use Endroid\QrCode\ErrorCorrectionLevel;
use Endroid\QrCode\Writer\PngWriter;

#[Route('/events')] // Base route for event actions
class PublicEventController extends AbstractController
{
    private LoggerInterface $logger;
    private EventRepository $eventRepository;
    private ParticipationRepository $participationRepository; // Optional
    // Inject BuilderInterface for QR codes and Pdf for Snappy
    private BuilderInterface $qrCodeBuilder;
    private Pdf $snappyPdf;

    public function __construct(
        LoggerInterface $logger,
        EventRepository $eventRepository,
        ParticipationRepository $participationRepository,
        BuilderInterface $qrCodeBuilder, // Inject QR Code Builder
        Pdf $snappyPdf // Inject Snappy PDF Service
    ) {
        $this->logger = $logger;
        $this->eventRepository = $eventRepository;
        $this->participationRepository = $participationRepository;
        $this->qrCodeBuilder = $qrCodeBuilder;
        $this->snappyPdf = $snappyPdf;
    }

    #[Route('', name: 'public_event_index', methods: ['GET'])]
    public function index(Request $request): Response
    {
        $this->logger->info('Public event index page accessed.');

        // --- Filtering Logic (Example) ---
        $filter = $request->query->get('filter', 'all'); // 'all', 'upcoming', 'past'
        $search = $request->query->get('search', '');

        // ... (QueryBuilder logic remains the same) ...
        $queryBuilder = $this->eventRepository->createQueryBuilder('e')
            ->orderBy('e.dateDebut', 'DESC');

        if ($filter === 'upcoming') {
            $queryBuilder->andWhere('e.dateDebut >= :now')->setParameter('now', new \DateTimeImmutable());
        } elseif ($filter === 'past') {
            $queryBuilder->andWhere('e.dateDebut < :now')->setParameter('now', new \DateTimeImmutable());
        }

        if (!empty($search)) {
            $queryBuilder->andWhere(
                $queryBuilder->expr()->orX(
                    $queryBuilder->expr()->like('LOWER(e.titre)', ':search'),
                    $queryBuilder->expr()->like('LOWER(e.description)', ':search'),
                    // Assuming state holds GouvernoratEnum which stringifies to its value
                    $queryBuilder->expr()->like('LOWER(e.state)', ':search')
                )
            )->setParameter('search', '%' . mb_strtolower($search) . '%');
        }
        $events = $queryBuilder->getQuery()->getResult();
        // ...

        // --- Optional: Check participation status ---
        $userParticipations = [];
        // ... (participation check logic remains the same) ...

        // Prepare data for view
        $eventsForView = [];
        foreach($events as $event) {
            // ... (duration calculation and array creation remains the same) ...
            $duration = null;
            if ($event->getDateDebut() && $event->getDateFin()) {
                $diff = $event->getDateFin()->diff($event->getDateDebut());
                $duration = sprintf('%dh %02dmin', $diff->h + ($diff->days * 24), $diff->i);
            }
            $eventsForView[] = [
                'entity' => $event,
                'duration' => $duration,
                'user_participation_status' => $userParticipations[$event->getId()] ?? null
            ];
        }

        // --- **THE FIX IS HERE** ---
        // Ensure 'current_filter' is included in the context array passed to render
        return $this->render('public/event/index.html.twig', [
            'events_data' => $eventsForView,
            'current_filter' => $filter, // <-- PASS THE VARIABLE HERE
            'search_term' => $search,
        ]);
    }


    #[Route('/{id}', name: 'public_event_show', requirements: ['id' => '\d+'], methods: ['GET'])]
    public function show(int $id): Response
    {
        $event = $this->eventRepository->find($id);
        if (!$event) {
            $this->logger->warning(sprintf('Event with ID %d not found.', $id));
            throw $this->createNotFoundException('L\'événement demandé n\'existe pas.');
        }
        $this->logger->info(sprintf('Showing details for event ID %d: "%s".', $id, $event->getTitre()));

        $duration = null;
        if ($event->getDateDebut() && $event->getDateFin()) {
            try {
                $diff = $event->getDateFin()->diff($event->getDateDebut());
                $duration = sprintf('%dh %02dmin', $diff->h + ($diff->days * 24), $diff->i);
            } catch (\Exception $e) {
                $this->logger->error(sprintf('Error calculating duration for event ID %d: %s', $id, $e->getMessage()));
            }
        }

        $userParticipationStatus = null;
        $participation = null; // Keep track of the participation entity if found
        $user = $this->getUser();
        if ($user instanceof Utilisateur) { // Use your specific User entity class
            $participation = $this->participationRepository->findOneByUserAndEvent($user,$event);
            $userParticipationStatus = $participation?->getStatut(); // Get the Enum object or null
            $this->logger->debug(sprintf('User %d participation status for event %d: %s', $user->getId(), $id, $userParticipationStatus?->value ?? 'null'));
        }

        return $this->render('public/event/show.html.twig', [
            'event' => $event,
            'duration' => $duration,
            'user_participation_status' => $userParticipationStatus, // Pass the Enum object or null
            'participation' => $participation // Pass the participation entity itself (needed for ticket ID)
        ]);
    }

    // --- NEW ACTION FOR DOWNLOADING TICKET ---
    #[Route('/{id}/ticket', name: 'public_event_download_ticket', methods: ['GET'])]
    #[IsGranted('ROLE_USER')] // Ensure user is logged in
    public function downloadTicket(Event $event): Response // Use ParamConverter for Event
    {
        $user = $this->getUser();
        if (!$user instanceof Utilisateur) {
            // Should not happen due to IsGranted, but good practice
            $this->logger->warning('Attempted ticket download without valid user.');
            throw $this->createAccessDeniedException('Vous devez être connecté pour télécharger un billet.');
        }

        // Find the specific *active* participation record
        $participation = $this->participationRepository->findOneBy([
            'event' => $event,
            'utilisateur' => $user,
            'statut' => ParticipationStatus::INSCRIT // Only allow download for INSCRIT status
        ]);

        if (!$participation) {
            $this->logger->warning(sprintf('User %d tried to download ticket for event %d without active participation.', $user->getId(), $event->getId()));
            throw $this->createNotFoundException('Participation non trouvée ou inactive pour cet événement.'); // Or AccessDenied
        }

        // --- Generate QR Code ---
        // Define the data for the QR code (make it unique and verifiable)
        $qrData = json_encode([
            'type' => 'event_ticket',
            'participation_id' => $participation->getId(),
            'event_id' => $event->getId(),
            'user_id' => $user->getId(),
            'timestamp' => time(), // Optional: add timestamp
        ]);

        try {

            $qrCodeResult = $this->qrCodeBuilder->build(
                writer: new PngWriter(),
                data: $qrData,
                encoding: new Encoding('UTF-8'),
                errorCorrectionLevel: ErrorCorrectionLevel::High,
                size: 150,
                // only needed if you want to override the writer configured
                // in your endroid_qr_code.yaml:
                margin: 10
            );

            // Build the result object



            // Get QR code as a base64 encoded data URI string to embed in HTML/Twig
            $qrCodeBase64 = $qrCodeResult->getDataUri();

        } catch (\Exception $e) {
            dd($e->getMessage());
            $this->logger->error('QR Code generation failed: ' . $e->getMessage());
            // Handle error appropriately - maybe show an error page or default PDF
            throw new \RuntimeException('Impossible de générer le code QR pour le billet.');
        }

        // --- Render HTML for PDF ---
        $html = $this->renderView('public/event/ticket_pdf.html.twig', [
            'event' => $event,
            'user' => $user,
            'participation' => $participation,
            'qrCodeBase64' => $qrCodeBase64, // Pass the base64 string
        ]);

        // --- Generate PDF using Snappy ---
        $filename = sprintf('billet-event-%d-user-%d.pdf', $event->getId(), $user->getId());

        try {
            return new Response(
                $this->snappyPdf->getOutputFromHtml($html),
                Response::HTTP_OK, // 200 status code
                [
                    'Content-Type'        => 'application/pdf',
                    // 'inline' displays in browser, 'attachment' forces download
                    'Content-Disposition' => sprintf('inline; filename="%s"', $filename),
                ]
            );
        } catch (\Exception $e) {
            dd($e);
            $this->logger->error('PDF generation failed: ' . $e->getMessage(), ['exception' => $e]);
            // Provide a user-friendly error response
            return new Response('Impossible de générer le billet PDF. Veuillez réessayer plus tard.', Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }
    // --- Add Participation/Cancel Logic (Requires login, CSRF protection recommended) ---
    // #[Route('/{id}/participate', name: 'public_event_participate', methods: ['POST'])]
    // #[IsGranted('ROLE_USER')]
    // public function participate(...) { ... }

    // #[Route('/{id}/cancel-participation', name: 'public_event_cancel_participation', methods: ['POST'])]
    // #[IsGranted('ROLE_USER')]
    // public function cancelParticipation(...) { ... }
    // --- Add Participation/Cancel Logic (Requires login) ---
    // #[Route('/{id}/participate', name: 'public_event_participate', methods: ['POST'])]
    // #[IsGranted('ROLE_USER')] // Make sure users are logged in
    // public function participate(Request $request, Event $event, EntityManagerInterface $em): Response { ... }

    // #[Route('/{id}/cancel-participation', name: 'public_event_cancel_participation', methods: ['POST'])]
    // #[IsGranted('ROLE_USER')]
    // public function cancelParticipation(Request $request, Event $event, EntityManagerInterface $em): Response { ... }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Client/EventController.php -----
<?php

namespace App\Controller\Client;

use App\Entity\Event;
use App\Entity\Participation;
use App\Entity\Utilisateur;
use App\Enum\ParticipationStatus;
use App\Form\EventType;
use App\Repository\EventRepository;
use App\Repository\ParticipationRepository; // Make sure this is injected
use App\Repository\UtilisateurRepository;
use Doctrine\ORM\EntityManagerInterface;
use Knp\Component\Pager\PaginatorInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Mailer\Exception\TransportExceptionInterface;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\HttpFoundation\RedirectResponse; // Added for redirects
use Symfony\Component\Mailer\MailerInterface;        // ← import this
use Symfony\Component\Mime\Email;                    // ← and this
use Symfony\Contracts\HttpClient\HttpClientInterface;
use Endroid\QrCode\Builder\BuilderInterface; // QR Code Builder
use Endroid\QrCode\Encoding\Encoding;
use Endroid\QrCode\ErrorCorrectionLevel;
use Endroid\QrCode\Writer\PngWriter;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface; // URL Generator

#[Route('/client/event')]
class EventController extends AbstractController
{
    // Inject ParticipationRepository in the constructor if it's used in multiple methods often
    private ParticipationRepository $participationRepository;
    private EntityManagerInterface $entityManager;
    private HttpClientInterface $client;
    private EventRepository $eventRepository; // Add repository property if used elsewhere
    private BuilderInterface $qrCodeBuilder; // Inject QR Code Builder
    private UrlGeneratorInterface $urlGenerator; // Inject URL Generator

    public function __construct(ParticipationRepository $participationRepository, EntityManagerInterface $entityManager,HttpClientInterface $client,
            EventRepository $eventRepository // Inject EventRepository
        ,
                                BuilderInterface $qrCodeBuilder, // Inject
                                UrlGeneratorInterface $urlGenerator // Inject


    )
    {
        $this->participationRepository = $participationRepository;
        $this->entityManager = $entityManager;
        $this->client = $client;
        $this->eventRepository = $eventRepository; // Store it
        $this->qrCodeBuilder = $qrCodeBuilder; // Store
        $this->urlGenerator = $urlGenerator; // Store

    }

    #[Route('/', name: 'client_event_index', methods: ['GET'])]
    public function index(
        // EventRepository $eventRepository, // Now injected via constructor
        Request            $request,
        PaginatorInterface $paginator,
        ParticipationRepository $participationRepo // Inject here if only needed here
    ): Response
    {
        /* ---------- query parameters & sane defaults -------------------- */
        $search    = trim((string)$request->query->get('search', ''));
        $filter    =              $request->query->get('filter', 'all'); // Default filter
        $page      = max(1, (int) $request->query->get('page',   1));
        $limit     = max(1, (int) $request->query->get('limit', 12)); // Default items per page
        $sort      = $request->query->get('sort',      'e.dateDebut'); // KNP Default field
        $direction = strtolower($request->query->get('direction', 'desc')); // KNP Default direction

        // Validate sort field against an allowed list
        $allowedSortFields = ['e.titre', 'e.dateDebut', 'e.state', 'e.statut'];
        if (!in_array($sort, $allowedSortFields, true)) {
            $sort = 'e.dateDebut'; // Fallback to default
        }
        if (!in_array($direction, ['asc', 'desc'])) {
            $direction = 'desc';   // Fallback to default
        }

        /* ---------- query builder --------------------------------------- */
        // Use the injected repository property
        $qb = $this->eventRepository->createQueryBuilder('e')
            // Optional: Select only necessary fields if performance is critical
            // ->select('e', 'p') // Select event and participation related fields if needed later
            ->leftJoin('e.participations', 'p')
            // Note: Counting here can sometimes interfere with pagination counts.
            // It might be better to fetch participations separately if needed per event.
            // ->addSelect('COUNT(p.id) AS participantCount') // Removed for simplicity on index
            ->groupBy('e.id'); // Grouping might still be needed depending on joins/selects

        // Apply Search filter
        if ($search !== '') {
            $qb->andWhere(
                $qb->expr()->orX(
                    'LOWER(e.titre)       LIKE :q',
                    'LOWER(e.description) LIKE :q',
                    'LOWER(e.state)       LIKE :q' // state is Enum, search by its string value
                )
            )->setParameter('q', '%'.mb_strtolower($search).'%');
        }

        // Apply Status/Date Filters
        $now = new \DateTimeImmutable();
        switch ($filter) {
            case 'upcoming': $qb->andWhere('e.dateDebut >= :now')->setParameter('now',$now); break;
            case 'past':     $qb->andWhere('e.dateDebut <  :now')->setParameter('now',$now); break;
            case 'a_venir':  $qb->andWhere('e.statut = :s')->setParameter('s','A_VENIR');    break;
            case 'en_cours': $qb->andWhere('e.statut = :s')->setParameter('s','EN_COURS');   break;
            case 'termine':  $qb->andWhere('e.statut = :s')->setParameter('s','TERMINE');    break;
            case 'annule':   $qb->andWhere('e.statut = :s')->setParameter('s','ANNULE');     break;
            // default: case 'all' - no extra constraint
        }

        /* ---------- pagination (KNP adds ORDER BY automatically) --------- */
        $pagination = $paginator->paginate(
            $qb->getQuery(), // Pass the Query object, not the QueryBuilder
            $page,
            $limit,
            [
                'pageParameterName'          => 'page', // Standard KNP params
                'sortFieldParameterName'     => 'sort',
                'sortDirectionParameterName' => 'direction',
                'defaultSortFieldName'       => $sort,       // Use validated sort field
                'defaultSortDirection'       => $direction,  // Use validated direction
                'distinct'                   => false, // Set to false unless you have complex joins needing it
                'allowEmptyFields'           => true,  // Allows sorting by fields not explicitly selected
            ]
        );

        // --- OPTIONAL: Get participation status for events ON THIS PAGE ---
        $userParticipationMap = [];
        $user = $this->getUser();
        if ($user instanceof Utilisateur) {
            $eventIdsOnPage = [];
            foreach ($pagination->getItems() as $eventRow) {
                // Handle potential array structure from COUNT/GROUP BY if re-added
                $eventEntity = is_array($eventRow) ? $eventRow[0] : $eventRow;
                if ($eventEntity instanceof Event) {
                    $eventIdsOnPage[] = $eventEntity->getId();
                }
            }

            if (!empty($eventIdsOnPage)) {
                $participations = $participationRepo->findBy([
                    'utilisateur' => $user,
                    'event' => $eventIdsOnPage // Query for participations of these specific events
                ]);
                foreach ($participations as $p) {
                    // Map event ID to the participation status Enum or its value
                    $userParticipationMap[$p->getEvent()->getId()] = $p->getStatut(); // Store the Enum case
                }
            }
        }
        // --- END OPTIONAL ---


        /* ---------- view ------------------------------------------------- */
        return $this->render('client/event/index.html.twig', [
            // Pass the $pagination object itself. Twig loops over this.
            'pagination'             => $pagination,
            // Pass the participation map (Event ID => ParticipationStatus Enum or null)
            'userParticipationMap' => $userParticipationMap,


            // Keep filter/sort parameters for the form state
            'current_filter'         => $filter,
            'search_term'            => $search,
            'limit'                  => $limit,
            'sort'                   => $sort,       // Current sort field
            'direction'              => $direction,  // Current sort direction
        ]);
    }


    #[Route('/new', name: 'client_event_new', methods: ['GET', 'POST'])]
    public function new(Request $request): Response // EntityManager injected via constructor
    {
        $event = new Event();
        // $event->setStatut('active'); // This 'active' status seems incorrect based on the entity enum/choices ('A_VENIR', etc.)
        $event->setStatut('A_VENIR'); // Set a valid default status

        $form = $this->createForm(EventType::class, $event);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->persist($event);
            $this->entityManager->flush();
            $this->addFlash('success', 'Événement créé avec succès.');
            return $this->redirectToRoute('client_event_index');
        }

        return $this->render('client/event/new.html.twig', [
            'event' => $event,
            'form' => $form->createView(), // Pass form view
        ]);
    }

    #[Route('/{id}/participate', name: 'client_event_participate', methods: ['POST'])]
    public function participate(Request $request, Event $event, UtilisateurRepository $utilisateurRepository,

                                MailerInterface $mailer        // ← inject it here

    ): Response // EntityManager injected via constructor
    {
//        $this->client->request('POST', "https://hook.eu1.make.com/ndgogmlq27hd1j6toex8eusathvnag8q", [
//            'json' => [
//                'title' => $event->getTitre(),
//                'description' => $event->getDescription(),
//                'start_time' => $event->getDateDebut()->format('c'), // ISO 8601 format
//                'end_time' => $event->getDateFin()->format('c'),
//                'location' => $event->getState()->value ?? null, // Assuming GouvernoratEnum has value "Ariana" etc.
//                'status' => $event->getStatut(),
//            ],
//        ]);
        // WARNING: No security check! Relies on getUser() or fallback.
        $user = $this->getUser();
        if (!$user) {
            // Using the fallback test user logic from your original code
            $user = $utilisateurRepository->findOneBy(['email' => 'test@example.com']);
            if (!$user) {
                // Create a default test user for participation testing
                $user = new Utilisateur();
                $user->setEmail('test@example.com');
                $user->setNom('Test');
                $user->setPrenom('User');
                // Note: Password hashing should ideally use the PasswordHasher service
                $user->setPassword(password_hash('test1234', PASSWORD_DEFAULT)); // Use default hash
                $user->setRoleInterne('client'); // Use setRoleInterne
                $user->setTelephone('0123456789'); // Required field in database
                $user->setIsVerified(true); // Assume verified for test
                $this->entityManager->persist($user);
                $this->entityManager->flush();
            }
        }
         $email = (new Email())
            ->from('aymen.labidi@esprit.tn')
            ->to('aymenlabidi21@gmail.com')
            ->subject('Hello via SMTP!')
            ->text('This email was sent over SMTP using Symfony Mailer.')
            ->html('<p>This email was sent over <strong>SMTP</strong> using Symfony Mailer.</p>');
        $dateDebut = $event->getDateDebut()->format('d/m/Y \à H\hi'); // e.g. "27/04/2025 à 14h30"
        $dateFin   = $event->getDateFin()  ->format('d/m/Y \à H\hi'); // e.g. "27/04/2025 à 16h00"

        $url = 'https://hook.eu1.make.com/36nvslbc06ues77g2f69w5nloy1ra98j';

                            $body = <<<EOT
                    Bonjour,</br>
                    
                    Félicitations ! Vous êtes inscrit(e) à l'événement "{$event->getTitre()}". ✅</br>
                    
                    📅 Date : {$dateDebut} - {$dateFin}</br>
                    📍 Lieu : {$event->getLieuValue()} ({$event->getState()->label()})</br>
                    ⚡ Autonomie minimale requise pour les trottinettes : {$event->getTrottinetteMinAutonomie()} km</br>
                    
                    🎫 Présentez ce mail comme preuve de votre inscription.</br>
                    
                    À très bientôt ! 🚀
                    EOT;
        $payload = [
            'calendar_title' => $event->getTitre(),
                'description' => $event->getDescription(),
                'start_time' => $event->getDateDebut()->format('c'), // ISO 8601 format
                'end_time' => $event->getDateFin()->format('c'),
                'location' => $event->getState()->value ?? null, // Assuming GouvernoratEnum has value "Ariana" etc.
                'status' => $event->getStatut(),
            'email' => $user->getEmail(),
            'body'  => $body,
            'title' => "Confirmation de participation à 'événement",
        ];
        $headers = [
            'Content-Type' => 'application/json',
            'Cookie'       => '__cf_bm=hfXrt7n0TJKswki1VkcZXgyCGyrUOG7LcPSmsuwLAUQ-1745745305-1.0.1.1-N9CHYn3bbnDqxifvbWFL9WPEDH1DMGIol16jHCmyIGxdm1RMOXrxAOUN4k6iNJtOlX35E0QzCR8t.BZudJltHyTg0nWihxkmMK5TL2.ia28',
        ];

        $response = $this->client->request('POST', $url, [
            'headers' => $headers,
            'json'    => $payload,
        ]);

        // get status and body if you want
        $status  = $response->getStatusCode();
        $content = $response->getContent(false);


        try {

            $mailer->send($email);
            $this->addFlash('success', 'Email envoyé !');



        } catch (TransportExceptionInterface $e) {
            // SMTP refused it, DNS failure, auth error, etc.
            $this->addFlash('error', 'L’email n’a pas pu être envoyé : '.$e->getMessage());

            // In dev, you might re-throw to see the full trace
            if ($this->getParameter('kernel.debug')) {
                throw $e;
            }
        }


        // Check if user already actively registered
        $activeParticipation = $this->participationRepository->findOneBy([
            'event' => $event,
            'utilisateur' => $user,
            'statut' => ParticipationStatus::INSCRIT
        ]);

        if ($activeParticipation) {
            $this->addFlash('warning', 'Vous êtes déjà inscrit à cet événement.');
            return $this->redirectToRoute('client_event_show', ['id' => $event->getId()]);
        }

        // Check if user has a cancelled registration for this event
        $cancelledParticipation = $this->participationRepository->findOneBy([
            'event' => $event,
            'utilisateur' => $user,
            'statut' => ParticipationStatus::ANNULE
        ]);
        $participationToConfirm = null; // Variable to hold the participation object

        if ($cancelledParticipation) {
            // Reactivate the cancelled participation
            $cancelledParticipation->setStatut(ParticipationStatus::INSCRIT);
            $cancelledParticipation->setDateInscription(new \DateTime()); // Update inscription date
            $this->entityManager->persist($cancelledParticipation);
            $this->addFlash('success', 'Votre inscription a été réactivée !');
            $participationToConfirm = $cancelledParticipation; // Use this participation object

        } else {
            // Create a new participation if none exists (active or cancelled)
            $participation = new Participation();
            // WARNING: Using potentially non-unique ID. Database composite key (eventId, userId) is preferred.
            $participation->setEvent($event);
            $participation->setUtilisateur($user);
            $participation->setDateInscription(new \DateTime());
            $participation->setStatut(ParticipationStatus::INSCRIT);
            $this->entityManager->persist($participation);
            $this->addFlash('success', 'Vous êtes maintenant inscrit à cet événement !');
            $participationToConfirm = $participation; // Use the new participation object

        }

        $this->entityManager->flush();

        // --- Redirect to the NEW Confirmation Page ---
        if ($participationToConfirm && $participationToConfirm->getId()) {
            return $this->redirectToRoute('client_participation_confirmation', ['id' => $participationToConfirm->getId()]);
        } else {
            // Fallback if something went wrong getting the ID
            $this->addFlash('error', 'Erreur lors de la récupération de l\'ID de participation.');
            return $this->redirectToRoute('client_event_show', ['id' => $event->getId()]);
        }    }

    // --- Added Action to Cancel Participation ---
    #[Route('/{id}/cancel-participation', name: 'client_event_cancel_participation', methods: ['POST'])]
    public function cancelParticipation(Request $request, Event $event, UtilisateurRepository $utilisateurRepository): Response // EntityManager injected via constructor
    {
        // WARNING: No security check!
        $user = $this->getUser();
        if (!$user) {
            // Using the fallback test user logic from your original code (less ideal for cancel)
            $user = $utilisateurRepository->findOneBy(['email' => 'test@example.com']);
            if (!$user) {
                $this->addFlash('warning', 'Utilisateur non trouvé pour annuler la participation.');
                return $this->redirectToRoute('client_event_show', ['id' => $event->getId()]);
            }
        }

        // Find the ACTIVE participation to cancel
        $participation = $this->participationRepository->findOneBy([
            'event' => $event,
            'utilisateur' => $user,
            'statut' => ParticipationStatus::INSCRIT // Only cancel if currently 'INSCRIT'
        ]);

        if (!$participation) {
            $this->addFlash('warning', 'Vous n\'êtes pas activement inscrit à cet événement.');
            return $this->redirectToRoute('client_event_show', ['id' => $event->getId()]);
        }

        // Change status to Cancelled
        $participation->setStatut(ParticipationStatus::ANNULE);
        $this->entityManager->persist($participation); // Persist the change
        $this->entityManager->flush();

        $this->addFlash('success', 'Votre participation à l\'événement a été annulée.');
        return $this->redirectToRoute('client_event_show', ['id' => $event->getId()]);
    }
    // --- End Added Action ---


    #[Route('/{id}', name: 'client_event_show', methods: ['GET'])]
    public function show(Event $event): Response // ParticipationRepository injected via constructor
    {
        $user = $this->getUser();
        $user_participation = null;
        if ($user instanceof Utilisateur) {
            // Find specific participation (active or cancelled) for this user/event
            $user_participation = $this->participationRepository->findOneBy(['event' => $event, 'utilisateur' => $user]);
        }

        $user_participation_status = $user_participation?->getStatut();

        return $this->render('client/event/show.html.twig', [
            'event' => $event,
            // Pass the specific participation object (or null) to the template
            'user_participation' => $user_participation,           // Participation object or null
            'user_participation_status' => $user_participation_status   // Status Enum or null
        ]);
    }

    #[Route('/{id}/edit', name: 'client_event_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Event $event): Response // EntityManager injected via constructor
    {
        $form = $this->createForm(EventType::class, $event);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $this->entityManager->flush();
            $this->addFlash('success', 'Événement mis à jour.');
            // Redirect back to the show page or index
            return $this->redirectToRoute('client_event_show', ['id' => $event->getId()]);
        }

        return $this->render('client/event/edit.html.twig', [
            'event' => $event,
            'form' => $form->createView(), // Pass form view
        ]);
    }

    #[Route('/{id}', name: 'client_event_delete', methods: ['POST'])]
    public function delete(Request $request, Event $event): Response // EntityManager injected via constructor
    {
        // WARNING: Original code has Csrf check but redirects to admin dashboard.
        // Keeping the CSRF check as it's good practice, even if other security is removed.
        // Redirecting to event index instead of admin dashboard.
        // Also, need to handle deletion of related participations.
        if (true) {

            // Manually remove participations before removing event (if cascade={"remove"} isn't set or doesn't work)
            $participations = $this->participationRepository->findBy(['event' => $event]);
            foreach ($participations as $participation) {
                $this->entityManager->remove($participation);
            }
            // Flush removals if necessary, though often can be done in one flush
            // $this->entityManager->flush();

            $this->entityManager->remove($event);
            $this->entityManager->flush();
            $this->addFlash('success', 'Événement supprimé.');
        } else {
            $this->addFlash('danger', 'Action invalide (CSRF token mismatch).');
            return $this->redirectToRoute('client_event_show', ['id' => $event->getId()]); // Redirect back if token fails
        }

        return $this->redirectToRoute('client_event_index'); // Redirect to event list
    }

    #[Route('/{id}/participants', name: 'client_event_participants', methods: ['GET'])]
    public function participants(Event $event): Response // ParticipationRepository injected via constructor
    {
        // This action remains the same, just lists participants.
        $participants = $this->participationRepository->findByEvent($event);

        // Render the view for showing participants (assuming this view exists and is correct)
        return $this->render('client/event/participants.html.twig', [
            'event' => $event,
            'participants' => $participants,
        ]);
    }
    #[Route('/participation/{id}/confirmation', name: 'client_participation_confirmation', requirements: ['id' => '\d+'], methods: ['GET'])]
    public function participationConfirmation(Participation $participation): Response
    {
        // --- Security Check: Ensure the logged-in user owns this participation ---
        $currentUser = $this->getUser();
        if (!$currentUser instanceof Utilisateur || $participation->getUtilisateur() !== $currentUser) {
            $this->addFlash('danger', 'Accès non autorisé à cette confirmation.');
            // Redirect to a safe page, maybe their dashboard or event index
            return $this->redirectToRoute('client_event_index');
        }
        // --- End Security Check ---

        $event = $participation->getEvent();
        if (!$event) {
            throw $this->createNotFoundException('Événement associé non trouvé.');
        }

        $qrCodeDataUri = null;
        try {
            // 1. Generate the URL for the details page

            // 2. Generate the QR Code Result object
                            $dateDebut = $event->getDateDebut()->format('d/m/Y H:i');
                            $dateFin   = $event->getDateFin()  ->format('d/m/Y H:i');
                            $lieu      = $event->getState()?->label() ?? 'Non défini';
                            $desc      = trim(strip_tags($event->getDescription()));

                            $noteText = <<<EOT
                Événement : {$event->getTitre()}
                📅 Date : {$dateDebut} – {$dateFin}
                📍 Lieu  : {$lieu}
                
                ℹ️ Description :
                {$desc}
                EOT;

            $qrCodeResult = $this->qrCodeBuilder->build(
                data:                 $noteText,
                encoding:             new Encoding('UTF-8'),
                errorCorrectionLevel: ErrorCorrectionLevel::Low,
                size:                 200,
                margin:               10
            );

            // 3. Get the Data URI (base64 string)
            $qrCodeDataUri = $qrCodeResult->getDataUri();

        } catch (\Exception $e) {
            $this->addFlash('error', 'Impossible de générer le code QR : ' . $e->getMessage());
            // Log the error ($this->logger->error(...))
        }

        return $this->render('client/event/participation_confirmation.html.twig', [
            'participation' => $participation,
            'event' => $event,
            'qrCodeDataUri' => $qrCodeDataUri, // Pass the base64 URI to Twig
        ]);
    }


}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Client/DashboardController.php -----
<?php
// src/Controller/Client/DashboardController.php
namespace App\Controller\Client;

use App\Repository\TrottinetteRepository;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Http\Attribute\IsGranted;
use App\Repository\EventRepository;
use App\Repository\ParticipationRepository;
use App\Repository\PointRelaisRepository;
use App\Repository\ReservationRepository;

use App\Entity\Utilisateur; // Import User entity
use App\Enum\ReservationStatus; // Import ReservationStatus Enum
use App\Enum\ParticipationStatus; // Import ParticipationStatus Enum
use Psr\Log\LoggerInterface;


#[Route('/client')]
#[IsGranted('ROLE_USER')]
class DashboardController extends AbstractController
{
    private LoggerInterface $logger;
    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    #[Route('/dashboard', name: 'client_dashboard')]
    public function dashboard(
        EventRepository $eventRepository,
        ParticipationRepository $participationRepository,
        ReservationRepository $reservationRepository,
        // TrottinetteRepository $trottinetteRepository, // Keep if needed for stats
        // PointRelaisRepository $pointRelaisRepository // Keep if needed for stats
    ): Response {
        /** @var Utilisateur $user */
        $user = $this->getUser(); // Get the currently logged-in user

        if (!$user) {
            // Should not happen due to IsGranted, but good practice
            $this->logger->warning('Client dashboard accessed without authenticated user.');
            return $this->redirectToRoute('app_login');
        }

        $this->logger->info(sprintf('Client dashboard accessed by user ID %d.', $user->getId()));

        // --- Fetch User-Specific Data ---
        $upcomingEvents = [];
        $userActiveReservations = [];
        $participatingEventIds = [];

        try {
            // 1. Fetch upcoming events (can show all or only those participated in)
            // Option A: Show all upcoming events
            $upcomingEvents = $eventRepository->findUpcomingEvents(5); // Limit for dashboard view

            // Option B: Show only events user is participating in (uncomment if preferred)
            // $participations = $participationRepository->findBy(['utilisateur' => $user, 'statut' => ParticipationStatus::INSCRIT]);
            // foreach ($participations as $p) {
            //    $event = $p->getEvent();
            //    // Check if the event is actually upcoming
            //    if ($event && $event->getDateDebut() >= new \DateTimeImmutable()) {
            //        $upcomingEvents[] = $event;
            //    }
            // }
            // // Sort them if needed
            // usort($upcomingEvents, fn($a, $b) => $a->getDateDebut() <=> $b->getDateDebut());
            // $upcomingEvents = array_slice($upcomingEvents, 0, 5); // Limit


            // 2. Fetch user's active/current reservations
            // Adjust status based on your application's logic for "rented"
            $userActiveReservations = $reservationRepository->findBy(
                ['utilisateur' => $user, 'status' => ReservationStatus::CONFIRMED], // Assuming CONFIRMED means active
                ['dateFin' => 'ASC'], // Show ending soonest first
                5 // Limit for dashboard view
            );

            // 3. Get IDs of events user is actively participating in (for button state)
            $activeParticipations = $participationRepository->findBy(['utilisateur' => $user, 'statut' => ParticipationStatus::INSCRIT]);
            foreach ($activeParticipations as $participation) {
                $participatingEventIds[] = $participation->getEvent()->getId();
            }

            $this->logger->info(sprintf('User %d has %d active reservations and participates in %d upcoming events shown.', $user->getId(), count($userActiveReservations), count($upcomingEvents)));

        } catch (\Exception $e) {
            $this->logger->error('Error fetching client dashboard data for user ID ' . $user->getId() . ': ' . $e->getMessage(), ['exception' => $e]);
            $this->addFlash('error', 'Erreur lors du chargement de vos informations.');
        }


        // --- Prepare Data for View ---
        // Prepare events data (calculate duration, add participation status if needed)
        $eventsForView = [];
        foreach($upcomingEvents as $event) {
            $duration = null;
            if ($event->getDateDebut() && $event->getDateFin()) {
                $diff = $event->getDateFin()->diff($event->getDateDebut());
                $duration = sprintf('%dh %02dmin', $diff->h + ($diff->days * 24), $diff->i);
            }
            $eventsForView[] = [
                'entity' => $event,
                'duration' => $duration,
                // Status is checked directly using participatingEventIds in Twig now
            ];
        }

        // No extra prep needed for reservations, pass them directly

        return $this->render('client/dashboard/index.html.twig', [
            'utilisateur' => $user,
            'upcoming_events' => $eventsForView, // Use the prepared array
            'user_reservations' => $userActiveReservations, // User's active reservations
            'participatingEventIds' => $participatingEventIds, // IDs for button state
            // Remove data not directly used in this specific template
            // 'trottinettes' => $trottinettes,
            // 'pointRelais' => $pointRelais,
            // 'reservations' => $reservations, // Use user_reservations instead
            // 'registerTrottIds' => $registerTrottIds,
        ]);
    }
    #[Route('/dashboard/qr-scan', name: 'client_qr_scan', methods: ['GET'])]
    public function qrScan(): Response
    {
        return $this->render('client/dashboard/qr_scan.html.twig');
    }

    #[Route('/dashboard/map', name: 'client_map_display', methods: ['GET'])]
    public function mapDisplay(TrottinetteRepository $trottiRepo): Response
    {
        $trottinettes = $trottiRepo->findAvailable();
        return $this->render('client/dashboard/map.html.twig', [
            'trottinettes' => $trottinettes,
        ]);
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Client/ReservationController.php -----
<?php

namespace App\Controller\Client;

use App\Entity\Reservation;
use App\Entity\Trottinette;
use App\Repository\ReservationRepository;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Core\Security;

class ReservationController extends AbstractController
{
    private EntityManagerInterface $entityManager;
    private ReservationRepository $reservationRepository;
    private Security $security;

    public function __construct(EntityManagerInterface $entityManager, ReservationRepository $reservationRepository, Security $security)
    {
        $this->entityManager = $entityManager;
        $this->reservationRepository = $reservationRepository;
        $this->security = $security;
    }

    #[Route('/reservation/create/{trottinette_id}', name: 'reservation_create', methods: ['POST'])]
    public function create(Request $request, int $trottinette_id): Response
    {
        // Retrieve the trottinette
        $trottinette = $this->entityManager->getRepository(Trottinette::class)->find($trottinette_id);

        // Check if the trottinette exists
        if (!$trottinette) {
            $this->addFlash('danger', 'Cette trottinette n\'existe pas.');
            return $this->redirectToRoute('trottinette_list'); // Change this to your trottinette list route
        }

        // Check if the trottinette is already reserved
        $existingReservation = $this->reservationRepository->findOneBy(['trottinette' => $trottinette]);
        if ($existingReservation) {
            $this->addFlash('danger', 'Cette trottinette est déjà réservée.');
            return $this->redirectToRoute('trottinette_list'); // Redirect to the list or another appropriate page
        }

        // Create new reservation
        $reservation = new Reservation();
        $reservation->setTrottinette($trottinette);
        $reservation->setUtilisateur($this->security->getUser());
        $reservation->setDateDebut(new \DateTime()); // Set current time or based on user input
        $reservation->setDateFin(new \DateTime('+1 hour')); // Example, set 1 hour duration
        $reservation->setMontant('10.00'); // Set a default amount or calculate dynamically
        $reservation->setStatus(ReservationStatus::PENDING); // Default status
        $reservation->setPaiement(Paiement::CASH); // Example payment method

        // Persist and flush the reservation
        $this->entityManager->persist($reservation);
        $this->entityManager->flush();

        // Add a success flash message
        $this->addFlash('success', 'Réservation effectuée avec succès.');

        // Redirect to the reservation list or another page
        return $this->redirectToRoute('reservation_index');
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Client/ProfileController.php -----
<?php
// src/Controller/Client/ProfileController.php
namespace App\Controller\Client;

use App\Entity\Utilisateur;
use App\Form\ProfileType;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Http\Attribute\IsGranted;
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use App\Service\FacialRecognitionService; // Import the service

#[Route('/mon-profil')]
#[IsGranted('ROLE_USER')]
class ProfileController extends AbstractController
{
    private FacialRecognitionService $faceRecService;
    private EntityManagerInterface $entityManager;

    public function __construct(FacialRecognitionService $faceRecService, EntityManagerInterface $entityManager)
    {
        $this->faceRecService = $faceRecService;
        $this->entityManager = $entityManager;
    }

    #[Route('', name: 'app_client_profile_view', methods: ['GET'])]
    public function view(): Response
    {
        /** @var Utilisateur|null $user */
        $user = $this->getUser();

        if (!$user instanceof Utilisateur) {
            $this->addFlash('warning', 'Utilisateur non trouvé.');
            return $this->redirectToRoute('app_login_page');
        }

        return $this->render('client/profile/view.html.twig', [
            'utilisateur' => $user,
            // Pass flag indicating if face embedding exists
            'has_face_setup' => !empty($user->getFaceEmbedding())
        ]);
    }

    #[Route('/edit', name: 'app_client_profile_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, UserPasswordHasherInterface $passwordHasher): Response
    {
        $user = $this->getUser();
        if (!$user instanceof \App\Entity\Utilisateur) {
            return $this->redirectToRoute('app_login_page');
        }

        $form = $this->createForm(ProfileType::class, $user);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            // Handle optional password change if implemented in ProfileType
            // ... (logic for hashing new password if provided) ...

            $this->entityManager->flush();
            $this->addFlash('success', 'Profil mis à jour avec succès.');
            return $this->redirectToRoute('app_client_profile_view');
        }

        return $this->render('client/profile/edit.html.twig', [
            'utilisateur' => $user,
            'profileForm' => $form->createView(),
        ]);
    }

    // --- NEW: Action for Facial Recognition Setup/Update ---
    #[Route('/setup-face', name: 'app_client_profile_setup_face', methods: ['POST'])]
    public function setupFacialRecognition(Request $request): JsonResponse
    {
        /** @var Utilisateur|null $user */
        $user = $this->getUser();
        if (!$user instanceof Utilisateur) {
            return new JsonResponse(['success' => false, 'message' => 'Authentification requise.'], Response::HTTP_UNAUTHORIZED);
        }

        // Expecting comma-separated descriptor string from frontend JS
        $embeddingData = $request->request->get('face_embedding_data'); // Match the key used in JS fetch body

        if (empty($embeddingData) || !is_string($embeddingData)) {
            return new JsonResponse(['success' => false, 'message' => 'Données faciales manquantes ou invalides.'], Response::HTTP_BAD_REQUEST);
        }

        // Basic format validation (comma-separated numbers)
        if (!preg_match('/^[-0-9.,]+$/', $embeddingData)) {
            return new JsonResponse(['success' => false, 'message' => 'Format de données faciales invalide.'], Response::HTTP_BAD_REQUEST);
        }
        // Optional: More robust check (count commas, etc.)
        if (substr_count($embeddingData, ',') !== 127) { // 128 values have 127 commas
            return new JsonResponse(['success' => false, 'message' => 'Nombre incorrect de valeurs faciales.'], Response::HTTP_BAD_REQUEST);
        }

        try {
            // Directly save the embedding string provided by the JS (which came from face-api)
            $user->setFaceEmbedding($embeddingData);
            $this->entityManager->flush(); // Save changes

            // Flash message will be shown on next page load (after JS potentially reloads)
            $this->addFlash('success', 'Reconnaissance faciale configurée avec succès!');

            return new JsonResponse(['success' => true, 'message' => 'Configuration faciale enregistrée.']);

        } catch (\Exception $e) {
            // Log the error server-side
            error_log('Facial recognition setup DB error for user ' . $user->getId() . ': ' . $e->getMessage());
            return new JsonResponse(['success' => false, 'message' => 'Erreur interne lors de l\'enregistrement. Veuillez réessayer.'], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }
    // --- END NEW ACTION ---
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Controller/Client/ReclamationController.php -----
<?php

namespace App\Controller\Client;

use App\Entity\Reponse; // Importer l'entité Reponse
use App\Form\ReponseType; // Importer le formulaire Reponse
use App\Entity\Reclamation;
use App\Form\ReclamationType;
use App\Repository\ReclamationRepository;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

#[Route('/reclamation')]
class ReclamationController extends AbstractController
{
    // Route pour afficher toutes les réclamations
    #[Route('', name: 'reclamation_index', methods: ['GET'])]
    public function index(ReclamationRepository $reclamationRepository): Response
    {
        return $this->render('reclamation/index.html.twig', [
            'reclamations' => $reclamationRepository->findAll(),
        ]);
    }

    // Route pour la création d'une nouvelle réclamation
    #[Route('/new', name: 'reclamation_new', methods: ['GET', 'POST'])]
    public function new(Request $request, EntityManagerInterface $em): Response
    {
        $reclamation = new Reclamation();

        // Associer l'utilisateur connecté à la réclamation
        if ($this->getUser()) {
            $reclamation->setUtilisateur($this->getUser());
        } else {
            // Si pas connecté, rediriger vers la page de connexion
            $this->addFlash('error', 'Vous devez être connecté pour créer une réclamation.');
            return $this->redirectToRoute('app_login');
        }

        $form = $this->createForm(ReclamationType::class, $reclamation);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            if ($reclamation->getDateCreation() === null) {
                $reclamation->setDateCreation(new \DateTime());
            }

            $em->persist($reclamation);
            $em->flush();

            $this->addFlash('success', 'Réclamation créée avec succès.');
            return $this->redirectToRoute('reclamation_index');
        }

        return $this->render('reclamation/new.html.twig', [
            'form' => $form->createView(),
        ]);
    }
    // Route pour afficher une réclamation spécifique
    #[Route('/{id}', name: 'reclamation_show', methods: ['GET'])]
    public function show(Reclamation $reclamation): Response
    {
        return $this->render('reclamation/show.html.twig', [
            'reclamation' => $reclamation,
        ]);
    }

    // Route pour modifier une réclamation existante
    #[Route('/{id}/edit', name: 'reclamation_edit', methods: ['GET', 'POST'])]
    public function edit(Request $request, Reclamation $reclamation, EntityManagerInterface $em): Response
    {
        $form = $this->createForm(ReclamationType::class, $reclamation);
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $em->flush();

            $this->addFlash('success', 'Réclamation mise à jour.');
            return $this->redirectToRoute('reclamation_index');
        }

        return $this->render('reclamation/edit.html.twig', [
            'reclamation' => $reclamation,
            'form' => $form->createView(),
        ]);
    }

    // Route pour supprimer une réclamation
    #[Route('/{id}', name: 'reclamation_delete', methods: ['POST'])]
    public function delete(Request $request, Reclamation $reclamation, EntityManagerInterface $em): Response
    {
        if ($this->isCsrfTokenValid('delete'.$reclamation->getId(), $request->request->get('_token'))) {
            $em->remove($reclamation);
            $em->flush();

            $this->addFlash('success', 'Réclamation supprimée.');
        }

        return $this->redirectToRoute('reclamation_index');
    }

    // Route pour répondre à une réclamation spécifique
    #[Route('/reclamation/{id}/repondre', name: 'reclamation_repondre', methods: ['GET', 'POST'])]
    public function repondre(Request $request, Reclamation $reclamation, EntityManagerInterface $em): Response
    {
        // Crée une nouvelle réponse
        $reponse = new Reponse();
        $reponse->setReclamation($reclamation);
        $reponse->setAuteur($this->getUser()); // Assigner l'auteur de la réponse (l'utilisateur connecté)

        // Créer et gérer le formulaire
        $form = $this->createForm(ReponseType::class, $reponse);
        $form->handleRequest($request);

        // Si le formulaire est soumis et valide
        if ($form->isSubmitted() && $form->isValid()) {
            $em->persist($reponse);
            $em->flush();  // Sauvegarde la réponse dans la base de données

            $this->addFlash('success', 'Votre réponse a été ajoutée avec succès.');

            return $this->redirectToRoute('reclamation_show', ['id' => $reclamation->getId()]);
        }

        // Rendu du formulaire de réponse
        return $this->render('reclamation/repondre.html.twig', [
            'form' => $form->createView(),
            'reclamation' => $reclamation,
        ]);
    }

}


----- /Users/mac/Downloads/my_project_troti-vf/src/Service/FacialRecognitionService.php -----
<?php
// src/Service/FacialRecognitionService.php
namespace App\Service;

use Symfony\Component\HttpClient\HttpClient; // Example if calling an external API
use Symfony\Contracts\HttpClient\HttpClientInterface; // Interface for HttpClient

class FacialRecognitionService
{
    private const EUCLIDEAN_THRESHOLD = 0.43; // Adjust as needed
    private HttpClientInterface $httpClient;
    private string $faceApiEndpoint; // URL of your Python API/service

    // Inject HttpClient and potentially the API endpoint URL
    public function __construct(HttpClientInterface $httpClient, string $faceApiEndpoint = 'http://127.0.0.1:5001/extract') // Example endpoint
    {
        $this->httpClient = $httpClient;
        $this->faceApiEndpoint = $faceApiEndpoint;
    }

    /**
     * Extracts embedding by calling an external service (e.g., Python Flask API).
     *
     * @param string $base64ImageData Base64 encoded image string (with prefix like data:image/jpeg;base64,)
     * @return string|null Comma-separated float string representing the embedding, or null on failure.
     */
    public function extractEmbedding(string $base64ImageData): ?string
    {
        // Remove the base64 prefix (e.g., "data:image/jpeg;base64,")
        $base64CleanData = preg_replace('#^data:image/\w+;base64,#i', '', $base64ImageData);
        if (empty($base64CleanData)) {
            error_log("Face Embedding Extraction Error: Invalid base64 prefix or empty data.");
            return null;
        }

        try {
            $response = $this->httpClient->request('POST', $this->faceApiEndpoint, [
                'json' => ['image_base64' => $base64CleanData]
                // Or use 'body' => json_encode(...) depending on API expectation
                // Add headers if needed: 'headers' => ['Content-Type' => 'application/json']
            ]);

            $statusCode = $response->getStatusCode();
            $content = $response->toArray(false); // false to not throw on non-2xx codes

            if ($statusCode === 200 && isset($content['embedding']) && is_array($content['embedding'])) {
                // API should return an array of floats/numbers
                // Ensure they are floats and join them into a string
                $embeddingArray = array_map('floatval', $content['embedding']);
                if (count($embeddingArray) === 128) { // Check expected dimension
                    return implode(',', $embeddingArray);
                } else {
                    error_log("Face Embedding Extraction Error: API returned embedding with incorrect dimension: " . count($embeddingArray));
                    return null;
                }
            } else {
                // Log the error from the API if available
                $errorMessage = $content['error'] ?? ('API Error: Status ' . $statusCode);
                error_log("Face Embedding Extraction Error: " . $errorMessage);
                return null;
            }

        } catch (\Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface $e) {
            error_log("Face Embedding API Transport Error: " . $e->getMessage());
            return null; // Network or connection error
        } catch (\Symfony\Contracts\HttpClient\Exception\ExceptionInterface $e) {
            error_log("Face Embedding API Client/Server Error: " . $e->getMessage());
            return null; // Other client/server errors
        } catch (\JsonException $e) {
            error_log("Face Embedding API Response JSON Error: " . $e->getMessage());
            return null; // Could not decode JSON response
        } catch (\Exception $e) {
            error_log("Face Embedding Unknown Error: " . $e->getMessage());
            return null; // General error
        }
    }


    /**
     * Compares a submitted face descriptor string with a stored descriptor string.
     * Uses Euclidean distance.
     *
     * @param string $submittedDescriptorString Comma-separated descriptor floats.
     * @param string $storedDescriptorString Comma-separated descriptor floats.
     * @return bool True if faces match within threshold, false otherwise.
     */
    public function compareFaces(string $submittedDescriptorString, string $storedDescriptorString): bool
    {
        if (empty($submittedDescriptorString) || empty($storedDescriptorString)) {
            error_log("Comparison failed: Missing submitted or stored descriptor string.");
            return false;
        }

        try {
            $submittedEmbedding = array_map('floatval', explode(',', $submittedDescriptorString));
            $storedEmbedding = array_map('floatval', explode(',', $storedDescriptorString));

            if (count($submittedEmbedding) !== 128 || count($storedEmbedding) !== 128) {
                error_log("Comparison failed: Invalid descriptor length. Submitted: " . count($submittedEmbedding) . ", Stored: " . count($storedEmbedding));
                return false;
            }

            $distance = $this->euclideanDistance($submittedEmbedding, $storedEmbedding);
            error_log("Face comparison Euclidean distance: " . $distance);

            return $distance <= self::EUCLIDEAN_THRESHOLD;

        } catch (\Exception $e) {
            error_log("Facial recognition comparison error: " . $e->getMessage());
            return false;
        }
    }

    private function euclideanDistance(array $vecA, array $vecB): float
    {
        $sumOfSquares = 0.0;
        $count = count($vecA);

        for ($i = 0; $i < $count; $i++) {
            $diff = ($vecA[$i] ?? 0.0) - ($vecB[$i] ?? 0.0); // Handle potential missing keys just in case
            $sumOfSquares += $diff * $diff;
        }

        return sqrt($sumOfSquares);
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Service/DataFixturesService.php -----
<?php

namespace App\Service;

use App\Entity\PointRelais;
use App\Entity\Utilisateur;
use Doctrine\ORM\EntityManagerInterface;

class DataFixturesService
{
    private EntityManagerInterface $entityManager;
    
    public function __construct(EntityManagerInterface $entityManager)
    {
        $this->entityManager = $entityManager;
    }
    
    public function getOrCreateDefaultPointRelais(): PointRelais
    {
        // Try to find an existing default point relais
        $pointRelais = $this->entityManager->getRepository(PointRelais::class)->find(1);
        
        // If none exists, create one
        if (!$pointRelais) {
            $pointRelais = new PointRelais();
            $pointRelais->setNom('Point Relais par défaut');
            $pointRelais->setAddresse('123 Rue Test');
            
            // Set a valid DateTime value for HoraireOuverture
            // Here, we set the current date and time as the default value
            $pointRelais->setHoraireOuverture(new \DateTime());  // This will use the current date and time
    
            $this->entityManager->persist($pointRelais);
            $this->entityManager->flush();
        }
        
        return $pointRelais;
    }
    
    public function getOrCreateDefaultUser(): ?Utilisateur
    {
        // Try to find an existing default user
        $user = $this->entityManager->getRepository(Utilisateur::class)->find(1);
        
        // If none exists, create one
        if (!$user) {
            $user = new Utilisateur();
            $user->setEmail('test@example.com');
            $user->setNom('User');
            $user->setPrenom('Test');
            $user->setTelephone('0123456789');
            $user->setPassword('password');  // In a real app, you'd hash this
            $user->setRole('client');
            
            $this->entityManager->persist($user);
            $this->entityManager->flush();
        }
        
        return $user;
    }
    
    public function getDefaultPointRelaisId(): int
    {
        return $this->getOrCreateDefaultPointRelais()->getId();
    }
    
    public function getDefaultUserId(): ?int
    {
        $user = $this->getOrCreateDefaultUser();
        return $user ? $user->getId() : null;
    }
}


----- /Users/mac/Downloads/my_project_troti-vf/src/Twig/AppExtension.php -----
<?php

namespace App\Twig;

use App\Enum\GouvernoratEnum;
use Twig\Extension\AbstractExtension;
use Twig\TwigFilter;

class AppExtension extends AbstractExtension
{
    public function getFilters()
    {
        return [
            new TwigFilter('enum_value', [$this, 'getEnumValue']),
        ];
    }

    public function getEnumValue($enum)
    {
        if ($enum instanceof GouvernoratEnum) {
            return $enum->value;
        }
        
        if (is_object($enum) && property_exists($enum, 'value')) {
            return $enum->value;
        }
        
        return (string) $enum;
    }
}



----- /Users/mac/Downloads/my_project_troti-vf/src/Kernel.php -----
<?php

namespace App;

use Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait;
use Symfony\Component\HttpKernel\Kernel as BaseKernel;

class Kernel extends BaseKernel
{
    use MicroKernelTrait;
}


